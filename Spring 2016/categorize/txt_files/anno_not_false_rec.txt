0
---------------------bad------------------------
let rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
--------------------fix-------------------------
let rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;
-------------------anno bad--------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
---------------------annofix------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;

1
---------------------bad------------------------
let rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
--------------------fix-------------------------
let rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;
-------------------anno bad--------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
---------------------annofix------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;

2
---------------------bad------------------------
let rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
--------------------fix-------------------------
let rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;
-------------------anno bad--------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
---------------------annofix------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;

3
---------------------bad------------------------
let rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
--------------------fix-------------------------
let rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;
-------------------anno bad--------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;
---------------------annofix------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;

4
---------------------bad------------------------
let rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
--------------------fix-------------------------
let rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;
-------------------anno bad--------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
---------------------annofix------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;

5
---------------------bad------------------------
let rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
--------------------fix-------------------------
let rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;
-------------------anno bad--------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
---------------------annofix------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;

6
---------------------bad------------------------
let rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
--------------------fix-------------------------
let rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;
-------------------anno bad--------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
---------------------annofix------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;

7
---------------------bad------------------------
let rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
--------------------fix-------------------------
let rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;
-------------------anno bad--------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
---------------------annofix------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;

8
---------------------bad------------------------
let rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
--------------------fix-------------------------
let rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;
-------------------anno bad--------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;
---------------------annofix------------------------
let rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;

9
---------------------bad------------------------
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence n =
  if n < 10
  then []
  else
    (let myList = digits n in
     let num = sumList myList in num + (additivePersistence num));;
--------------------fix-------------------------
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence n =
  if n < 10
  then 0
  else
    (let myList = digits n in
     let num = sumList myList in num + (additivePersistence num));;
-------------------anno bad--------------------------
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence  : int -> int = fun n  -> 
  if n < 10
  then []
  else
    (let myList = digits n in
     let num = sumList myList in num + (additivePersistence num));;
---------------------annofix------------------------
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence  : int -> int = fun n  -> 
  if n < 10
  then 0
  else
    (let myList = digits n in
     let num = sumList myList in num + (additivePersistence num));;

10
---------------------bad------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero l1 l2 =
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (a, b)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;
--------------------fix-------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero l1 l2 =
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (l1, l2)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;
-------------------anno bad--------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> 
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (a, b)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;
---------------------annofix------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> 
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (l1, l2)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;

11
---------------------bad------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero l1 l2 =
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (a, b)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;
--------------------fix-------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero l1 l2 =
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (l1, l2)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;
-------------------anno bad--------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> 
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (a, b)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;
---------------------annofix------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> 
  let a = List.length l1 in
  let b = List.length l2 in
  if a = b
  then (l1, l2)
  else
    if a < b
    then (((clone 0 (b - a)) @ l1), l2)
    else (l1, ((clone 0 (a - b)) @ l2));;

12
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval (e,x,y) =
  match e with
  | Thresh (w,t,u,z) ->
      if (eval (w, x, y)) < (eval (t, x, y))
      then eval (u, x, y)
      else eval (z, x, y)
  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))
  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2
  | Cosine t -> cos (pi *. (eval (t, x, y)))
  | Sine t -> sin (pi *. (eval (t, x, y)))
  | VarX  -> x
  | VarY  -> y;;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval (e,x,y) =
  match e with
  | Thresh (w,t,u,z) ->
      if (eval (w, x, y)) < (eval (t, x, y))
      then eval (u, x, y)
      else eval (z, x, y)
  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))
  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0
  | Cosine t -> cos (pi *. (eval (t, x, y)))
  | Sine t -> sin (pi *. (eval (t, x, y)))
  | VarX  -> x
  | VarY  -> y;;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval  : expr * float * float -> float = fun (e,x,y)  -> 
  match e with
  | Thresh (w,t,u,z) ->
      if (eval (w, x, y)) < (eval (t, x, y))
      then eval (u, x, y)
      else eval (z, x, y)
  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))
  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2
  | Cosine t -> cos (pi *. (eval (t, x, y)))
  | Sine t -> sin (pi *. (eval (t, x, y)))
  | VarX  -> x
  | VarY  -> y;;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval  : expr * float * float -> float = fun (e,x,y)  -> 
  match e with
  | Thresh (w,t,u,z) ->
      if (eval (w, x, y)) < (eval (t, x, y))
      then eval (u, x, y)
      else eval (z, x, y)
  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))
  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0
  | Cosine t -> cos (pi *. (eval (t, x, y)))
  | Sine t -> sin (pi *. (eval (t, x, y)))
  | VarX  -> x
  | VarY  -> y;;

13
---------------------bad------------------------
let rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;
--------------------fix-------------------------
let rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;
-------------------anno bad--------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;
---------------------annofix------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;

14
---------------------bad------------------------
let rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;
--------------------fix-------------------------
let rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;
-------------------anno bad--------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;
---------------------annofix------------------------
let rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;

15
---------------------bad------------------------
let rec listReverse l =
  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;
--------------------fix-------------------------
let rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;
-------------------anno bad--------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;
---------------------annofix------------------------
let rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | _::tl -> listReverse tl;;

16
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let buildAverage (e1,e2) = Average (e1, e2);;

let buildCosine e = Cosine e;;

let buildSine e = Sine e;;

let buildTimes (e1,e2) = Times (e1, e2);;

let buildX () = VarX;;

let buildY () = VarY;;

let rec build (rand,depth) =
  match depth with
  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()
  | 1 ->
      let num = rand (1, 10) in
      if (num mod 2) = 0
      then buildSine (build (rand, (depth - 1)))
      else buildCosine (build (rand, (depth - 1)))
  | 2 ->
      let num = rand (1, 30) in
      if (num mod 2) == 0
      then
        buildTimes
          ((buildSine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
      else
        buildTimes
          ((buildCosine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
  | 3 ->
      let num = rand (1, 50) in
      if (num mod 2) = 0
      then
        buildTimes
          ((buildAverage
              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),
            (buildCosine (build (rand, (depth - 1)))))
      else
        buildTimes
          ((buildAverage
              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),
            (buildSine (build (rand, (depth - 1)))))
  | 4 ->
      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 5 ->
      let num = rand (1, 10) in
      if num = 1
      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))
      else
        if num = 2
        then
          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))
        else
          if num = 3
          then buildSine (buildCosine (build (rand, (depth - 1))))
          else buildCosine (buildSine (build (rand, (depth - 1))))
  | 6 ->
      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 7 ->
      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 8 ->
      buildTimes
        ((buildAverage
            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),
          (buildSine (build (rand, (depth - 1)))))
  | 9 ->
      let num = rand (1, 7) in
      if (num mod 2) = 0
      then
        buildAverage
          ((buildSine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
      else
        buildAverage
          ((buildCosine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
  | _ -> build (rand, (depth - num));;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let buildCosine e = Cosine e;;

let buildSine e = Sine e;;

let buildX () = VarX;;

let rec build (rand,depth) =
  match depth with
  | 0 -> buildX ()
  | 1 -> buildSine (build (rand, (depth - 1)))
  | _ -> buildCosine (build (rand, (depth - 1)));;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let buildAverage (e1,e2) = Average (e1, e2);;

let buildCosine e = Cosine e;;

let buildSine e = Sine e;;

let buildTimes (e1,e2) = Times (e1, e2);;

let buildX () = VarX;;

let buildY () = VarY;;

let rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> 
  match depth with
  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()
  | 1 ->
      let num = rand (1, 10) in
      if (num mod 2) = 0
      then buildSine (build (rand, (depth - 1)))
      else buildCosine (build (rand, (depth - 1)))
  | 2 ->
      let num = rand (1, 30) in
      if (num mod 2) == 0
      then
        buildTimes
          ((buildSine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
      else
        buildTimes
          ((buildCosine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
  | 3 ->
      let num = rand (1, 50) in
      if (num mod 2) = 0
      then
        buildTimes
          ((buildAverage
              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),
            (buildCosine (build (rand, (depth - 1)))))
      else
        buildTimes
          ((buildAverage
              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),
            (buildSine (build (rand, (depth - 1)))))
  | 4 ->
      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 5 ->
      let num = rand (1, 10) in
      if num = 1
      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))
      else
        if num = 2
        then
          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))
        else
          if num = 3
          then buildSine (buildCosine (build (rand, (depth - 1))))
          else buildCosine (buildSine (build (rand, (depth - 1))))
  | 6 ->
      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 7 ->
      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 8 ->
      buildTimes
        ((buildAverage
            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),
          (buildSine (build (rand, (depth - 1)))))
  | 9 ->
      let num = rand (1, 7) in
      if (num mod 2) = 0
      then
        buildAverage
          ((buildSine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
      else
        buildAverage
          ((buildCosine (build (rand, (depth - 1)))),
            (build (rand, (depth - 1))))
  | _ -> build (rand, (depth - num));;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let buildCosine e = Cosine e;;

let buildSine e = Sine e;;

let buildX () = VarX;;

let rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> 
  match depth with
  | 0 -> buildX ()
  | 1 -> buildSine (build (rand, (depth - 1)))
  | _ -> buildCosine (build (rand, (depth - 1)));;

17
---------------------bad------------------------
let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
--------------------fix-------------------------
let rec assoc (d,k,l) =
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;
-------------------anno bad--------------------------
let assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
---------------------annofix------------------------
let rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;

18
---------------------bad------------------------
let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
--------------------fix-------------------------
let rec assoc (d,k,l) =
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;
-------------------anno bad--------------------------
let assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
---------------------annofix------------------------
let rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;

19
---------------------bad------------------------
let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
--------------------fix-------------------------
let rec assoc (d,k,l) =
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;
-------------------anno bad--------------------------
let assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
---------------------annofix------------------------
let rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;

20
---------------------bad------------------------
let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
--------------------fix-------------------------
let rec assoc (d,k,l) =
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;
-------------------anno bad--------------------------
let assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
---------------------annofix------------------------
let rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;

21
---------------------bad------------------------
let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
--------------------fix-------------------------
let rec assoc (d,k,l) =
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;
-------------------anno bad--------------------------
let assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
---------------------annofix------------------------
let rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;

22
---------------------bad------------------------
let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
--------------------fix-------------------------
let rec assoc (d,k,l) =
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;
-------------------anno bad--------------------------
let assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
---------------------annofix------------------------
let rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> 
  match l with
  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
  | _ -> d;;

23
---------------------bad------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = List.append (List.append a sep) h in
      let base = "" in let l = sl in List.fold_left f base l;;
--------------------fix-------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = failwith "to be implemented" in
      let base = failwith "to be implemented" in
      let l = failwith "to be implemented" in List.fold_left f base l;;
-------------------anno bad--------------------------
let rec sepConcat  : string -> string list -> string = fun sep sl  -> 
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = List.append (List.append a sep) h in
      let base = "" in let l = sl in List.fold_left f base l;;
---------------------annofix------------------------
let rec sepConcat  : string -> string list -> string = fun sep sl  -> 
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = failwith "to be implemented" in
      let base = failwith "to be implemented" in
      let l = failwith "to be implemented" in List.fold_left f base l;;

24
---------------------bad------------------------
let rec wwhile (f,b) =
  match f with
  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;
--------------------fix-------------------------
let rec wwhile (f,b) =
  let (x,y) = f b in if y = true then wwhile (f, x) else x;;
-------------------anno bad--------------------------
let rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> 
  match f with
  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;
---------------------annofix------------------------
let rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> 
  let (x,y) = f b in if y = true then wwhile (f, x) else x;;

25
---------------------bad------------------------
let rec wwhile (f,b) =
  let (x,y) = b f in if y = true then wwhile (f, x) else x;;
--------------------fix-------------------------
let rec wwhile (f,b) =
  let (x,y) = f b in if y = true then wwhile (f, x) else x;;
-------------------anno bad--------------------------
let rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> 
  let (x,y) = b f in if y = true then wwhile (f, x) else x;;
---------------------annofix------------------------
let rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> 
  let (x,y) = f b in if y = true then wwhile (f, x) else x;;

26
---------------------bad------------------------
let rec listReverse l =
  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;
--------------------fix-------------------------
let rec listReverse l =
  match l with | [] -> [] | h::t -> h :: (listReverse t);;
-------------------anno bad--------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;
---------------------annofix------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | [] -> [] | h::t -> h :: (listReverse t);;

27
---------------------bad------------------------
let rec listReverse l =
  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;
--------------------fix-------------------------
let rec listReverse l =
  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;
-------------------anno bad--------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;
---------------------annofix------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;

28
---------------------bad------------------------
let rec listReverse l =
  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;
--------------------fix-------------------------
let rec listReverse l =
  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;
-------------------anno bad--------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;
---------------------annofix------------------------
let rec listReverse  : 'a list -> 'a list = fun l  -> 
  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;

29
---------------------bad------------------------
let rec wwhile (f,b) =
  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;

let fixpoint (f,b) = let (b',c') = f b in if b = b' then b else wwhile (f, b);;

let _ =
  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;
--------------------fix-------------------------
let rec wwhile (f,b) =
  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;

let fixpoint (f,b) = wwhile ((failwith "to be written"), b);;

let _ =
  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;
-------------------anno bad--------------------------
let rec wwhile (f,b) =
  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;

let fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let (b',c') = f b in if b = b' then b else wwhile (f, b);;

let _ =
  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;
---------------------annofix------------------------
let rec wwhile (f,b) =
  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;

let fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((failwith "to be written"), b);;

let _ =
  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;

30
---------------------bad------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList f l = let x = List.map (f l) in sepConcat ";" x;;
--------------------fix-------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList f l = let x = List.map f l in sepConcat ";" x;;
-------------------anno bad--------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map (f l) in sepConcat ";" x;;
---------------------annofix------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map f l in sepConcat ";" x;;

31
---------------------bad------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList f l = let x = List.map (f l) in sepConcat ";" x;;
--------------------fix-------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList f l = let x = List.map f l in sepConcat ";" x;;
-------------------anno bad--------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map (f l) in sepConcat ";" x;;
---------------------annofix------------------------
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map f l in sepConcat ";" x;;

32
---------------------bad------------------------
let rec wwhile (f,b) =
  match f b with | () -> if b00l then num else wwhile (f, num);;
--------------------fix-------------------------
let rec wwhile (f,b) =
  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;
-------------------anno bad--------------------------
let rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> 
  match f b with | () -> if b00l then num else wwhile (f, num);;
---------------------annofix------------------------
let rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> 
  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;

33
---------------------bad------------------------
let rec mulByDigit i l =
  let lr = List.rev l in
  match lr with
  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])
  | (c,h::t) ->
      let sum = c + ((fst x) * (snd x)) in
      ((sum / 10), ((sum mod 10) :: (snd a)));;
--------------------fix-------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero l1 l2 =
  let s1 = List.length l1 in
  let s2 = List.length l2 in
  if s1 < s2
  then (((clone 0 (s2 - s1)) @ l1), l2)
  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;

let rec removeZero l =
  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      match a with
      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])
      | (c,h::t) ->
          let sum = (c + (fst x)) + (snd x) in
          ((sum / 10), ((sum mod 10) :: (snd a))) in
    let base = (0, []) in
    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;

let rec mulByDigit i l =
  match i with
  | 0 -> []
  | 1 -> l
  | 2 -> bigAdd l l
  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;
-------------------anno bad--------------------------
let rec mulByDigit  : int -> int list -> int list  = fun i l  -> 
  let lr = List.rev l in
  match lr with
  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])
  | (c,h::t) ->
      let sum = c + ((fst x) * (snd x)) in
      ((sum / 10), ((sum mod 10) :: (snd a)));;
---------------------annofix------------------------
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let padZero l1 l2 =
  let s1 = List.length l1 in
  let s2 = List.length l2 in
  if s1 < s2
  then (((clone 0 (s2 - s1)) @ l1), l2)
  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;

let rec removeZero l =
  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      match a with
      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])
      | (c,h::t) ->
          let sum = (c + (fst x)) + (snd x) in
          ((sum / 10), ((sum mod 10) :: (snd a))) in
    let base = (0, []) in
    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;

let rec mulByDigit  : int -> int list -> int list  = fun i l  -> 
  match i with
  | 0 -> []
  | 1 -> l
  | 2 -> bigAdd l l
  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;

34
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> e
  | VarY  -> e
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0
  | _ -> "";;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> e
  | VarY  -> e
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0
  | _ -> "";;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;

35
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> Printf.sprintf "%s"
  | VarY  -> Printf.sprintf "%s"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0;;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> Printf.sprintf "%s"
  | VarY  -> Printf.sprintf "%s"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0;;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;

36
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> e
  | VarY  -> e
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0
  | _ -> "";;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> e
  | VarY  -> e
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0
  | _ -> "";;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;

37
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> e
  | VarY  -> e
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> e
  | VarY  -> e
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;

38
---------------------bad------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> Printf.sprintf "%s"
  | VarY  -> Printf.sprintf "%s"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0;;
--------------------fix-------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;
-------------------anno bad--------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> Printf.sprintf "%s"
  | VarY  -> Printf.sprintf "%s"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" e2
  | Average (e3,e4) -> Printf.sprintf "%s %s" e3 e4
  | Times (e5,e6) -> Printf.sprintf "%s %s" e5 e6
  | Thresh (e7,e8,e9,e0) -> Printf.sprintf "%s %s %s %s" e7 e8 e9 e0;;
---------------------annofix------------------------
type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString  : expr -> string = fun e  -> 
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine e1 -> Printf.sprintf "%s" (exprToString e1)
  | Cosine e2 -> Printf.sprintf "%s" (exprToString e2)
  | Average (e3,e4) ->
      Printf.sprintf "%s %s" (exprToString e3) (exprToString e4)
  | Times (e5,e6) ->
      Printf.sprintf "%s %s" (exprToString e5) (exprToString e6)
  | Thresh (e7,e8,e9,e0) ->
      Printf.sprintf "%s %s %s %s" (exprToString e7) (exprToString e8)
        (exprToString e9) (exprToString e0)
  | _ -> "";;

