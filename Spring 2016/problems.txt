only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  -> \n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Sine e  ->  Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"}

only_pre_corr
{"fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "annotated": "\nlet bigMul : int list -> int list -> int list = fun  l1 l2  -> \n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "annotated_fix": "\nlet bigMul : int list -> int list -> int list = fun  l1 l2  -> \n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}

only_pre_corr
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit : int -> int list -> int list  = fun  i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "annotated_fix": "\nlet rec mulByDigit : int -> int list -> int list  = fun  i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Custom1 of expr* expr* expr;;\n\nlet buildCustom1 (e1,e2,e3) = Custom1 (e1, e2, e3);;\n", "annotated": "\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  -> \n  if depth = 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Custom1 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Custom1 (e1,e2,e3)  ->  Custom1 (e1, e2, e3);;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n"}

only_pre_corr
{"fix": "\nlet rec fixpoint (f,b) =\n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "annotated": "\nlet fixpoint: ('a -> 'a) * 'a -> 'a = fun _helper f b  ->  let b' = f b in (b', (b = b'));;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n", "annotated_fix": "\nlet rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \n  let b' = f b in if b' = b then b else fixpoint (f, b');;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Op1 e  ->  Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (build (rand, (depth - 1))))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (build (rand, (depth - 1))))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Cosine e  ->  Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX rand))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX rand))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Cosine e  ->  Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 -> buildX ()\n                                   | _ -> build (rand, depth))))))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "annotated": "\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated": "\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  ->  float_of_string (exprToString e);;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated": "\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  ->  float_of_string (exprToString e);;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n"}

only_pre_corr
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n", "annotated": "\nlet rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> \n  match l with\n  | [] -> d\n  | h::t -> if h = k then return h else assoc (d, k, t);;\n", "annotated_fix": "\nlet rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> \n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if h = k then return h else assoc (d, k, t);;\n"}

only_pre_corr
{"fix": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "annotated": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot : int -> int = fun  n  -> \n  if n < 10 then n else digitalRoot (sumList (digitsofInt n));;\n", "annotated_fix": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot : int -> int = fun  n  -> \n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "bad": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsofInt n));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"fix": "\nlet rec exprToString e = failwith \"to be written\";;\n", "annotated": "\nlet rec exprToString : expr -> string = fun  e  ->  ets (e, \"\");;\n", "annotated_fix": "\nlet rec exprToString : expr -> string = fun  e  ->  failwith \"to be written\";;\n", "bad": "\nlet rec exprToString e = ets (e, \"\");;\n"}

only_pre_corr
{"fix": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n", "annotated": "\nlet rec clone : 'a -> int -> 'a list = fun  x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n", "annotated_fix": "\nlet rec clone : 'a -> int -> 'a list = fun  x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then match rand (0, 6) with | 0 -> buildX () | 1 -> buildY ()\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun X ()  ->  VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then match rand (0, 6) with | 0 -> buildX () | 1 -> buildY ()\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 1 -> buildTan (build (rand, (depth - 1)))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Cosine e  ->  Cosine e;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 1 -> buildTan (build (rand, (depth - 1)))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 1 -> buildTan (mod_float (build (rand, (depth - 1))) 1.0)\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Cosine e  ->  Cosine e;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 1 -> buildTan (mod_float (build (rand, (depth - 1))) 1.0)\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | SineSq of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSineSq e = SineSq e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 1 -> buildSineSq (build (rand, (depth - 1)))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | SineSq of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | SineSq of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet build: ((int * int -> int) * int) -> expr = fun Average (e1,e2)  ->  Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSineSq e = SineSq e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 1 -> buildSineSq (build (rand, (depth - 1)))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | SineSq of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n"}

only_pre_corr
{"fix": "\nlet rec wwhile (f,b) = failwith \"to be written\";;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((if (f b) = b then b else f b), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) = failwith \"to be written\";;\n\nlet fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b else f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "annotated": "\nlet rec additivePersistence : int -> int = fun  (a,n)  -> \n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence : int -> int = fun  (a,n)  -> \n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "bad": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "annotated": "\nlet rec additivePersistence : int -> int = fun  (a,n)  -> \n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence : int -> int = fun  (a,n)  -> \n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "bad": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper (buildSine p1) x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper (buildSine p1) x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper Sine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper Sine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 8 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum : int list -> int  = fun  xs  -> \n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum : int list -> int  = fun  xs  -> \n  let f a x = a * a in let base = f 8 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n"}

only_pre_corr
{"fix": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "annotated": "\nlet rec digitsOfInt : int -> int list = fun  n  -> \n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n", "annotated_fix": "\nlet rec digitsOfInt : int -> int list = fun  n  -> \n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "bad": "\nlet rec digitsOfInt n =\n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n"}

only_pre_corr
{"fix": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "annotated": "\nlet rec digitsOfInt : int -> int list = fun  n  -> \n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n", "annotated_fix": "\nlet rec digitsOfInt : int -> int list = fun  n  -> \n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "bad": "\nlet rec digitsOfInt n =\n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n"}

only_pre_corr
{"fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "annotated": "\nlet removeDuplicates : 'a list -> 'a list = fun  l  -> \n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "annotated_fix": "\nlet removeDuplicates : 'a list -> 'a list = fun  l  -> \n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "annotated": "\nlet rec sumList : int list -> int = fun  xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "annotated_fix": "\nlet rec sumList : int list -> int = fun  xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n"}

only_pre_corr
{"fix": "\nlet padZero l1 l2 = let (a,b) = ((List.length l1), (List.length l2)) in a;;\n", "annotated": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n", "annotated_fix": "\nlet padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  let (a,b) = ((List.length l1), (List.length l2)) in a;;\n", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n"}

only_anno_corr 
{"fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "annotated": "\nlet rec sepConcat : string -> string list -> string = fun  sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "annotated_fix": "\nlet rec sepConcat : string -> string list -> string = fun  sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n"}

only_pre_corr
{"fix": "\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in if len1 > len2 then len1 else len2;;\n", "annotated": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ l2), l1);;\n", "annotated_fix": "\nlet padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \n  let len1 = List.length l1 in\n  let len2 = List.length l2 in if len1 > len2 then len1 else len2;;\n", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ l2), l1);;\n"}

only_pre_corr
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
