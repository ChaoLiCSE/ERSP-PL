only_pre_corr{"annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n = let i  ->  0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []", "bad": "let rec clone x n = let i = 0 in\nif i < n\nthen (clone x n-1) :: x :: []\nelse []", "fix": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let i  ->  0 in\nif i < n\nthen (clone x n-1) :: x :: []\nelse []"}

only_anno_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h", "bad": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h", "fix": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f' -> (f b, b ! ->  (f b))),b)", "bad": "let fixpoint (f,b) = wwhile ((let f' = (f b, b != (f b))),b)", "fix": "let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f' = (f b, b ! ->  (f b))),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f' -> (f b, b ! ->  (f b))),b)", "bad": "let fixpoint (f,b) = wwhile ((let fun f' = (f b, b != (f b))),b)", "fix": "let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let fun f' = (f b, b ! ->  (f b))),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x = f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "fix": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x  ->  f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx = x)),b)", "fix": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx  ->  x)),b)"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "fix": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "fix": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_anno_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "bad": "let rec mulByDigit i l = \nlet mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "fix": "let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet mulByDigit : int -> int list -> int list  = fun  i l  -> \nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []"}

only_anno_corr{"annotated_fix": "let palindrome : string -> bool = fun  w  ->  \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome : string -> bool = fun  w  ->  match ex with\n| [] -> true\n| h1::t1 -> false", "bad": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> false", "fix": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nmatch w with \n| [] -> true\n| _  -> false"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f' -> if f b  ->  b then (b,false) else (f b, true)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)", "fix": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f' -> if f b ! ->  b then (b,true) else (f b, false)),b)"}

only_pre_corr{"annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "bad": "let sumList : int list -> int", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr{"annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "bad": "let sumList : int list -> int", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr{"annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "bad": "let sumList : int list -> int", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in k b), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  x in k b), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in k b), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  b in k b), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in f), b)", "bad": "let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((fun k x -> f x  ->  x), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x = x;), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x;), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in k b), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  x in k b), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)", "fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (x, x -> b)), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (b, (k b)! -> b)), b)", "bad": "let fixpoint (f,b) = wwhile({let k x = f x in (b, k b!=b)), b", "fix": "let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile({let k x = f x in (b, k b! -> b)), b"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (b, (k b)! -> b)), b)", "bad": "let fixpoint (f,b) = wwhile({let k x = f x in (b, (k b)!=b)), b", "fix": "let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile({let k x = f x in (b, (k b)! -> b)), b"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (b, b! -> b)), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x in (b, b! -> b), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x = y in (x, y! -> x), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x = x in (x, x! -> x), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = let y = f x in (x, y!=x), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = let y = f x in (x, y! -> x), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = let y = f x in f x in (x, y! -> x), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let f x = let xx  ->  x*x*x in (xx, xx < 100), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = (f x)  ->  x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x<100), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = (f x)  ->  x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (g x, x<100), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = (f x)  ->  x in g b, b)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100)", "fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in g b in (x, x<100)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in g b ! ->  x, b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in g b ! ->  b, b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g b = let xx = f x in (xx, xx! -> b) in g), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)", "fix": "let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (b, xx! -> b) in g), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f xx in (xx, xx! -> b) in g), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)", "fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f b in (xx, xx! -> b) in g), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g b), b)", "bad": "let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)", "fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g xx = let xx = f x in (xx, xx! -> b) in g), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx! -> b) in inwwhile), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_pre_corr{"annotated_fix": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}

only_pre_corr{"annotated_fix": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}

only_pre_corr{"annotated_fix": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}

only_pre_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_anno_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun a -> f a, f a ! ->  a), b)", "bad": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\nin \ng, b", "fix": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\nfun a ->\nf a, f a != a\nin \ng, b"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> if (x -> b) then (b,false) else (f x,true)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b)", "fix": "let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> if(f x) -> x then (b,false) else (f x,true),b)"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)", "fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append l2 l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nList.append l2 l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1", "fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "bad": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a", "fix": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a"}

only_pre_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "bad": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1", "fix": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1"}

only_anno_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "bad": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "fix": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)"}

only_anno_corr{"annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q)", "fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q)"}

only_anno_corr{"annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))", "bad": ")", "fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))", "annotated": ")"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx)  ->  xx)),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)", "fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = f xx in (xx, (f xx)  ->  xx),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx)  ->  xx)),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = in (xx, (f xx) = xx),b)", "fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = in (xx, (f xx)  ->  xx),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx)  ->  xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b)", "fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx ((xx, (f xx)  ->  xx)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx)  ->  xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx ((xx, f xx = xx)),b)", "fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx ((xx, f xx  ->  xx)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx)  ->  xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b)", "fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx -> ((xx, f xx  ->  xx)),b)"}

only_pre_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l = if i  ->  0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "bad": "let rec mulByDigit i l = if i = 1 then l \nelse mulByDigit (i - 1) (bigAdd l l)", "fix": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = if i  ->  1 then l \nelse mulByDigit (i - 1) (bigAdd l l)"}

only_anno_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( (f b)  ->  b , b )", "bad": "let fixpoint (f,b) = wwhile ( (f b), b )", "fix": "let fixpoint (f,b) = wwhile ( (f b) = b , b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( (f b), b )"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "bad": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "annotated": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()"}

only_pre_corr{"annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_pre_corr{"annotated_fix": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 -> []\nelse n mod 10 :: digitofInt n/10", "fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 -> []\nelse n mod 10 :: digitofInt n/10"}

only_pre_corr{"annotated_fix": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then -> []\nelse n mod 10 :: digitofInt n/10", "fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then -> []\nelse n mod 10 :: digitofInt n/10"}

only_pre_corr{"annotated_fix": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s", "fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsofInt n/10s"}

only_pre_corr{"annotated_fix": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s", "fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt n/10s"}

only_pre_corr{"annotated_fix": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10 @ digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10", "fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else digitsOfInt (n/10):: n mod 10"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let fx b' = (f b', f b'  ->  b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)", "fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if f b  ->  b then (true,b) else (false,b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let fx b' = (f b', f b'  ->  b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)", "fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((f b)  ->  b, (f b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let fx b' = (f b', f b'  ->  b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = wwhile (f b, f b = b,b)", "fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f b, f b  ->  b,b)"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  \nif (depth < 1) then rand (0,2) else rand(2,7)"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  \nif (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)"}

only_anno_corr{"annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)"}

only_anno_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)", "bad": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)", "fix": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x = let bb = f x in (bb, bb  ->  x) in g, b)", "bad": "let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b)", "fix": "let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g = let bb = f b in (bb, bb  ->  b) in g, b)"}

only_pre_corr{"annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 (fun1 base)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 base)"}

only_pre_corr{"annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 x -> (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x -> (fun1 x)"}

only_pre_corr{"annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 x (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x (fun1 x)"}

only_anno_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1"}

only_anno_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1"}

only_pre_corr{"annotated_fix": "let palindrome : string -> bool = fun  w = let x = listReverse (explode w) in if(x -> (explode (w))) then true else false", "bad": "let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false", "fix": "let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false", "annotated": "let palindrome : string -> bool = fun  w = let x = listReverse (explode w) in if(x -> (explode (w))) then true esle false"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth -> 0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = let case = rand(0,6)", "fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)"}

only_anno_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth -> 0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth -> 0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth -> 0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_pre_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lrev = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum::xs", "fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lrev  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum::xs"}

only_pre_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"}

only_pre_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"}

only_pre_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then b else f(b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then b else f b,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  (f b) then b else (f b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  (f b) then (b,false) else ((f b),true),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if x  ->  f x then (b, false) else (b, true),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if x  ->  f x then (x, false) else (x, true),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then (b, false) else (b, true),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if b  ->  f b then (b, false) else (b, true)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)", "fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)"}

only_anno_corr{"annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b  ->  fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)", "fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b  ->  fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)", "fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b')  ->  b') in whilesFun (f)), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "fix": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b')  ->  b') in whilesFun (f)), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "fix": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)"}

only_anno_corr{"annotated_fix": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "in\nhelper d k l", "fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "annotated": "in\nhelper d k l"}

only_pre_corr{"annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "bad": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value", "fix": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value"}

only_pre_corr{"annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "bad": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value", "fix": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = f b in (xx, xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let xx = f b, xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = f b, xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = (f b), xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (((let xx = f b), xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((let xx = f b), xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (((let xx = (f b), xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((let xx = (f b), xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = (f b), xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  b*b*b in (xx, xx < 100),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let f b = let xx = x*x*x in (xx, xx < 100),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b = let xx  ->  x*x*x in (xx, xx < 100),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = f b in (xx, xx = b)),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = f b in (xx, xx  ->  b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx  ->  b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx  ->  b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx -> b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx = b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx  ->  b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = f x in (xx, xx  ->  b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)", "fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = f x in (xx, xx  ->  b) in d b),b)"}

only_anno_corr{"annotated_fix": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) ! ->  f(f(b)))) , b)", "bad": "*", "fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "annotated": "*"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f),b)", "bad": " fixpoint (f,b) = wwhile ((f b),b)", "fix": "let fixpoint (f,b) = wwhile ((f),b)", "annotated": " fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> (f x,f x! -> x)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=b)),b)", "fix": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> (f x,f x! -> b)),b)"}

only_anno_corr{"annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverseHelper l ans = \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans"}

only_anno_corr{"annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverse l =\nlistReverseHelper l []", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlistReverseHelper l []"}

only_anno_corr{"annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}

only_anno_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((failwith \"to be written\"), b)", "bad": "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b)", "fix": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x = (f x) in (x, x  ->  b), b)"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))\n| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))\n| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}

only_anno_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, f b))", "bad": "let fixpoint (f,b) = wwhile (f, b)", "fix": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f, b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( (let f x  ->   in f), b)", "bad": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))", "fix": "let fixpoint (f,b) = wwhile ( (let f x =  in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, (f b)))"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( (let f x  ->   in f), b)", "bad": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))", "fix": "let fixpoint (f,b) = wwhile ( (let f x =  in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, wwhile (f,b)))"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "],(List.hd b)+2", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "],(List.hd b)+2"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let b = (f x) in (b, b ! ->  x)),b)", "bad": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b)", "fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true) else (f b, false) in helper,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let b = (f x) in (b, b ! ->  x)),b)", "bad": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)", "fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true) else (f b, false) in helper, b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let b = (f x) in (b, b ! ->  x)),b)", "bad": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)\nelse (f b, false)\nin helper,b)", "fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true)\nelse (f b, false)\nin helper,b)"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "bad": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,7) with\n|0 -> build(rand, (depth-1))\n|1 -> buildSine(build(rand, (depth-1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))\n|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))\n|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))\n|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))", "fix": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,7) with\n|0 -> build(rand, (depth-1))\n|1 -> buildSine(build(rand, (depth-1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))\n|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))\n|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))\n|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))"}

only_pre_corr{"annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "bad": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "fix": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}

only_anno_corr{"annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t", "fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( let b' = f b in if b'  ->  b then f b else f b')", "bad": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)", "fix": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( let b' = f b in if b'  ->  b then f b else f b', b)"}

only_anno_corr{"annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "bad": "et rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated": "et rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let y = (f x) in (y, y ! ->  x)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)", "fix": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y ! ->  b)),b)"}

only_anno_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "bad": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)", "fix": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)"}

only_anno_corr{"annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "bad": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)", "fix": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x)\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x)\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x) )\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x) )\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x)\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x)\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x))\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x))\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\n(let sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) )\nin\nsec (y x) x\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \n(let sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) )\nin\nsec (y x) x\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=y b in\ng y b\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> y b in\ng y b\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=y b in\ng f b\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> y b in\ng f b\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x= y x\n\nin\ng f b\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x ->  y x\n\nin\ng f b\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\n((y x),false)\nin\ng f b\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \n((y x),false)\nin\ng f b\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng f b\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n(x,false)\nin\ng f b\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng (f b)\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n(x,false)\nin\ng (f b)\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\nx,false\nin\ng (f b)\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \nx,false\nin\ng (f b)\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\nx\nin\ng (f b)\n\n,b)", "fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \nx\nin\ng (f b)\n\n,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f a\nin h b,b)", "bad": "let fixpoint (f,b) = wwhile (let h = f\nin (h,false),b)", "fix": "let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h  ->  f\nin (h,false),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f a\nin h b,b)", "bad": "let fixpoint (f,b) = wwhile (let h a= f\nin h a,b)", "fix": "let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f\nin h a,b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x= (f x,(f x) -> x) in\nh,b)", "bad": "let fixpoint (f,b) = wwhile (let h x= (f x,false),b)", "fix": "let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x ->  (f x,false),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x= (f x,(f x) -> x) in\nh,b)", "bad": "let fixpoint (f,b) = wwhile (let h x= (f x,false) in\nh,b)", "fix": "let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x ->  (f x,false) in\nh,b)"}

only_pre_corr{"annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n = let rec  helper xs sub depth -> match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "bad": "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->help (sub::xs) sub (depth -1)", "fix": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with\n0->xs\n|_->help (sub::xs) sub (depth -1)"}

only_pre_corr{"annotated_fix": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let sizeDif ->  (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)", "bad": "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse then (l1,appendS@l2)", "fix": "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let sizeDif ->  (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse then (l1,appendS@l2)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(if f b  ->  b then f, b)", "bad": "let fixpoint (f,b) = wwhile((f::(f b = b)), b)", "fix": "let fixpoint (f,b) = wwhile(if f b = b then f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((f::(f b  ->  b)), b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false)),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f b-1 then (b,false)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f b-1 then (b,false) in f),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in ),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f (b-1) then (b,false) in ),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f (b-1) then (b,false) in f),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<>b && (x,y)<>f (b-1))),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<>b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y)= f b in (x, x! -> b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x>b||x<b)),b)"}

only_pre_corr{"annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let a x = let xx -> (f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)", "fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<100)),b)"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = xin", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = xin"}

only_anno_corr{"annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}

