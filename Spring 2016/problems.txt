only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n", "bad": "\nlet rec last l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (last tl) | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (last tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n", "annotated": "\nlet rec last l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (last tl) | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (last tl) | [] -> [];;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  (last l) :: (listReverse (removeLast l));;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then 0 else (n mod 10) + (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0 then 0 else (n mod 10) + (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then 0 else (n mod 10) + (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0 then 0 else (n mod 10) + (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "annotated_fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let (a',b') = wwhile (f, b) in a';;\n", "annotated": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let (a',b') = wwhile (f, b) in a';;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "annotated_fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n", "bad": "\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in b';;\n", "annotated": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let b' = (b, ((f b) = b)) in b';;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> (c, (bigAdd d (mulByDigit k v)))) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul  : int list -> int list -> int list = fun l1 l2  -> \n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> (c, (bigAdd d (mulByDigit k v)))) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (s,res) = List.fold_left f base args in (s, res);;\n", "annotated": "\nlet bigMul  : int list -> int list -> int list = fun l1 l2  -> \n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (s,res) = List.fold_left f base args in (s, res);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> [] | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::m::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::m::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::m::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::m::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> [] | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> [] | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> [] | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::m::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::m::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i t) @ [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i t) @ [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> [] | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h * i;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h * i;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> m;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match l with | [] -> [] | h::m::t -> m;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l = match List.rev l with | [] -> 0 | h::t -> h;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  match List.rev l with | [] -> 0 | h::t -> h;;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_anno_corr 
{"fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then [] else t;;\n", "annotated_fix": "\nlet rec removeZero  : int list -> int list = fun l  -> \n  match l with | [] -> [] | h::t -> if h = 0 then [] else t;;\n", "bad": "\nlet rec removeZero l =\n  match l with | [] -> false | h::t -> if h = 0 then h = 0 else false;;\n", "annotated": "\nlet rec removeZero  : int list -> int list = fun l  -> \n  match l with | [] -> false | h::t -> if h = 0 then h = 0 else false;;\n"}

only_anno_corr 
{"fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then [] else t;;\n", "annotated_fix": "\nlet rec removeZero  : int list -> int list = fun l  -> \n  match l with | [] -> [] | h::t -> if h = 0 then [] else t;;\n", "bad": "\nlet rec removeZero l =\n  match l with | [] -> false | h::t -> if h = 0 then h = 0 else false;;\n", "annotated": "\nlet rec removeZero  : int list -> int list = fun l  -> \n  match l with | [] -> false | h::t -> if h = 0 then h = 0 else false;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2) then true else false;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2) then true else false;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) :: l1\n  else (clone 0 ((List.length l1) - (List.length l2))) :: l2;;\n", "annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) :: l1\n  else (clone 0 ((List.length l1) - (List.length l2))) :: l2;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | h::t -> [h] in\n  let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = match a with | [] -> [] | h::t -> [h] in\n  let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n"}

only_anno_corr 
{"fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n"}

only_anno_corr 
{"fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n"}

only_anno_corr 
{"fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n"}

only_anno_corr 
{"fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let helper = f b in\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\n", "bad": "\nlet rec wwhile (f,b) =\n  let c' = f b in let b' = false in if c' = b then b' else wwhile (f, c');;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let c' = f b in let b' = false in if c' = b then b' else wwhile (f, c');;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let helper = f b in\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\n", "bad": "\nlet rec wwhile (f,b) = let c' = f b in if c' = b then c' else wwhile (f, c');;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let c' = f b in if c' = b then c' else wwhile (f, c');;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (3, 4) in\n     match (randNum, randNum2) with\n     | (1,3) -> buildSine (buildX ())\n     | _ -> buildCosine (buildX ()));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (3, 4) in\n     match (randNum, randNum2) with\n     | (1,3) -> buildSine (buildX ())\n     | _ -> buildCosine (buildX ()));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (deth - 1))))));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (deth - 1))))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  float_of_string (exprToString e);;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= eval) && (eval <= 1.0)); eval;;\n", "annotated": "\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  assert (((-1.0) <= eval) && (eval <= 1.0)); eval;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n"}

only_anno_corr 
{"fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = f x in List.fold_left g base xs;;\n", "annotated_fix": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  -> \n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = f x in List.fold_left g base xs;;\n", "bad": "\nlet stringOfList f l = List.map f l;;\n", "annotated": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map f l;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base n = n in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base n = n in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x _ = x in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x _ = x in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x _ = x in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x _ = x in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x _ = x in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x _ = x in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base n = n in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base n = n in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base n = n in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base n = n in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x y = x a y in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x y = x a y in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base _ = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base _ = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x _ = x in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x _ = x in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x (x a) in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x (x a) in let base y = y in List.fold_left f base fs;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 5) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 5) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 5) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 5) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n"}

only_pre_corr
{"fix": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0;;\n", "bad": "\nlet rec sumList xs = List.fold_left (+) xs;;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  List.fold_left (+) xs;;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0;;\n", "bad": "\nlet rec sumList xs = List.fold_left (+);;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  List.fold_left (+);;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0;;\n", "bad": "\nlet rec sumList xs = List.fold_left (+);;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  List.fold_left (+);;\n"}

only_anno_corr 
{"fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (1, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (1, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n", "bad": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (1, []) in List.fold_left f base (List.rev l);;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (1, []) in List.fold_left f base (List.rev l);;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc (d, k, ls);;\n", "annotated": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc (d, k, ls);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "bad": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "bad": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n > 0 then [n / 10; n mod 10] else [];;\n", "bad": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n > 0 then [n / 10; n mod 10] else [];;\n", "bad": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 45 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 65 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 75 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 -> buildNegate (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Negate e' -> \"negate(\" ^ ((exprToString e') ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 45 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 65 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 75 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 100 -> buildNegate (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Negate e' -> \"negate(\" ^ ((exprToString e') ^ \")\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n        ((eval (e3, x, y)) ** 2.0);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLog e = Log e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 15 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 30 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 40 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 50 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 -> buildLog (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Log e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n        ((eval (e3, x, y)) ** 2.0);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildLog e = Log e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 15 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 30 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 40 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 50 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 80 -> buildLog (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Log e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 50 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 70 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 85 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModF e = ModF e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumOfSquares (e1,e2,e3) = SumOfSquares (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 100) with\n     | i when i < 20 -> buildSine (build (rand, (depth - 1)))\n     | i when i < 40 -> buildCosine (build (rand, (depth - 1)))\n     | i when i < 50 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 60 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 70 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | i when i < 85 -> buildModF (build (rand, (depth - 1)))\n     | i when i < 100 ->\n         buildSumOfSquares\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ModF e' -> \"log(\" ^ ((exprToString e') ^ \")\")\n  | SumOfSquares (e1,e2,e3) ->\n      \"sumsqr(\" ^\n        ((exprToString e1) ^\n           (\",\" ^ ((exprToString e2) ^ (\",\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base b = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base b = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = f in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then [] else [];;\n", "bad": "\nlet rec digitsOfInt n = if n > 0 then n + (digitsOfInt (n - 1)) else 0;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n > 0 then n + (digitsOfInt (n - 1)) else 0;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then [] else [];;\n", "bad": "\nlet rec digitsOfInt n = if n > 0 then (n + (digitsOfInt n)) - 1 else 0;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n > 0 then (n + (digitsOfInt n)) - 1 else 0;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "bad": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"to be implemented\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "bad": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"to be implemented\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n", "bad": "\nlet rec build (rand,depth) = rand (0, 1);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (0, 1);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> 1\n  | VarY  -> 1\n  | Sine x -> 1\n  | Cosine x -> 1\n  | Average (x,y) -> 1\n  | Times (x,y) -> 1\n  | Thresh (x,y,z,w) -> 1;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> 1\n  | VarY  -> 1\n  | Sine x -> 1\n  | Cosine x -> 1\n  | Average (x,y) -> 1\n  | Times (x,y) -> 1\n  | Thresh (x,y,z,w) -> 1;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> 1\n  | VarY  -> 2\n  | Sine x -> 3\n  | Cosine x -> 4\n  | Average (x,y) -> 5\n  | Times (x,y) -> 6\n  | Thresh (x,y,z,w) -> 7;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> 1\n  | VarY  -> 2\n  | Sine x -> 3\n  | Cosine x -> 4\n  | Average (x,y) -> 5\n  | Times (x,y) -> 6\n  | Thresh (x,y,z,w) -> 7;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> 1\n  | VarY  -> 1\n  | Sine x -> 1\n  | Cosine x -> 1\n  | Average (x,y) -> 2\n  | Times (x,y) -> 1\n  | Thresh (x,y,z,w) -> 1;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> 1\n  | VarY  -> 1\n  | Sine x -> 1\n  | Cosine x -> 1\n  | Average (x,y) -> 2\n  | Times (x,y) -> 1\n  | Thresh (x,y,z,w) -> 1;;\n"}

only_pre_corr
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((mulByDigit x q), []) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul  : int list -> int list -> int list = fun l1 l2  -> \n  let f a x = let (q,w) = a in ((mulByDigit x q), []) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "annotated": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul  : int list -> int list -> int list = fun l1 l2  -> \n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}

only_pre_corr
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "annotated": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n"}

only_pre_corr
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "annotated": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "bad": "\nlet padZero l1 l2 = List.length l1;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  ->  List.length l1;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "bad": "\nlet padZero l1 l2 = let (a,b) = ((List.length l1), (List.length l2)) in a;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  ->  let (a,b) = ((List.length l1), (List.length l2)) in a;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "bad": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1 else 2;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1 else 2;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "bad": "\nlet padZero l1 l2 = let (a,b) = ((List.length l1), (List.length l2)) in a;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  ->  let (a,b) = ((List.length l1), (List.length l2)) in a;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n", "bad": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1 else 2;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1 else 2;;\n"}

only_anno_corr 
{"fix": "\nlet stringOfList f l = failwith \"to be implemented\";;\n", "annotated_fix": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  failwith \"to be implemented\";;\n", "bad": "\nlet stringOfList f l = List.map (fun x  -> Printf.sprintf \"%s\" x) l;;\n", "annotated": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (fun x  -> Printf.sprintf \"%s\" x) l;;\n"}

only_anno_corr 
{"fix": "\nlet stringOfList f l = failwith \"to be implemented\";;\n", "annotated_fix": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  failwith \"to be implemented\";;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "annotated": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (sepConcat f) l;;\n"}

only_anno_corr 
{"fix": "\nlet stringOfList f l = failwith \"to be implemented\";;\n", "annotated_fix": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  failwith \"to be implemented\";;\n", "bad": "\nlet stringOfList f l = List.map f l;;\n", "annotated": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map f l;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = a in let base a = a in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = a in let base a = a in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = a in let base a = a in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = a in let base a = a in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac mul in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "annotated_fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac mul in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "bad": "\nlet rec mulByDigit i l =\n  let rec helper i l2 acc s =\n    match l2 with\n    | [] -> (s, []) :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n, t) :: acc) (n / 10)\n        else helper i t ((n, t) :: acc) 0 in\n  helper i (List.rev l) [] 0;;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let rec helper i l2 acc s =\n    match l2 with\n    | [] -> (s, []) :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n, t) :: acc) (n / 10)\n        else helper i t ((n, t) :: acc) 0 in\n  helper i (List.rev l) [] 0;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = f in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = f in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = f in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = match depth with | 0 -> 0;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  match depth with | 0 -> 0;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = match depth with | 0 -> 0;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  match depth with | 0 -> 0;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with | 0 -> VarX | _ -> build (rand, (depth - 1));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n"}

only_anno_corr 
{"fix": "\nlet bigAdd l1 l2 = failwith \"moo\";;\n", "annotated_fix": "\nlet bigAdd  : int list -> int list -> int list = fun l1 l2  ->  failwith \"moo\";;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in car in\n  add (padZero l1 l2);;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet bigAdd  : int list -> int list -> int list = fun l1 l2  -> \n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in car in\n  add (padZero l1 l2);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "bad": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"TBD\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"TBD\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "bad": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"TBD\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"TBD\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n"}

only_anno_corr 
{"fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n", "annotated_fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (h, b);;\n", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, (b = b')) in ((f b), b));;\n", "annotated": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (let f' b' = (f, (b = b')) in ((f b), b));;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd bigAdd (l l) (mulByDigit (i - 1) l);;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  bigAdd bigAdd (l l) (mulByDigit (i - 1) l);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 1 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 1 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs y  ->  let f a x = x a in let base = y in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs num =\n  let f a x = x a in let base = num in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs num  -> \n  let f a x = x a in let base = num in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs num =\n  let f a x = x a in let base = num in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs num  -> \n  let f a x = x a in let base = num in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | _::tl -> listReverse tl;;\n", "bad": "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | _::tl -> listReverse tl;;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> 0 | _::tl -> 1 + (listReverse tl);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> 0 | _::tl -> 1 + (listReverse tl);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n < 0 then [] else n :: (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then [] else n :: (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n = if n < 0 then n else digitsOfInt (n / 10);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then n else digitsOfInt (n / 10);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n < 0 then [] else n :: (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then [] else n :: (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n / 10);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then 1 else digitsOfInt (n / 10);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n < 0 then [] else n :: (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then [] else n :: (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n = if n < 0 then n else digitsOfInt (n / 10);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then n else digitsOfInt (n / 10);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n < 0 then [] else n :: (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then [] else n :: (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n / 10);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n < 0 then 1 else digitsOfInt (n / 10);;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n", "bad": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2 then true else false;;\n", "annotated": "\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2 then true else false;;\n"}

only_anno_corr 
{"fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n", "annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base q = q in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base a = a in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then buildSine (build (rand, (depth - 1)))\n      else buildSine (build ((rand + 1), (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then buildSine (build (rand, (depth - 1)))\n      else buildSine (build ((rand + 1), (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then buildSine (build (rand, (depth - 1)))\n      else buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then buildSine (build (rand, (depth - 1)))\n      else buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (buildSine (build (rand, (depth - 1))))\n     | 2 -> buildCosine (buildCosine (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (buildSine (build (rand, (depth - 1))))\n     | 2 -> buildCosine (buildCosine (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else build ((rand + 1), (depth - 1));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let z = rand in if z > 1 then buildX () else buildY ();;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (buildSine (build (rand, (depth - 1))))\n     | 2 -> buildCosine (buildCosine (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 6) in\n     match num with\n     | 1 -> buildSine (buildSine (build (rand, (depth - 1))))\n     | 2 -> buildCosine (buildCosine (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((buildSine (build (rand, (depth - 1)))),\n             (buildCosine (build (rand, (depth - 1)))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSine (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then build ((rand + 1), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n"}

only_anno_corr 
{"fix": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let nl = List.map f l in sepConcat \"\" nl;;\n", "annotated_fix": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let nl = List.map f l in sepConcat \"\" nl;;\n", "bad": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (f sepConcat) l;;\n", "annotated": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (f sepConcat) l;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot  : int -> int = fun n  ->  sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = digitsOfInt n;;\n\nlet _ = digitalRoot 20;;\n", "annotated": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot  : int -> int = fun n  ->  digitsOfInt n;;\n\nlet _ = digitalRoot 20;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot  : int -> int = fun n  ->  sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = digitsOfInt n;;\n\nlet _ = digitalRoot 20;;\n", "annotated": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot  : int -> int = fun n  ->  digitsOfInt n;;\n\nlet _ = digitalRoot 20;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot  : int -> int = fun n  ->  sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digitalRoot n = digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digitalRoot  : int -> int = fun n  ->  digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot  : int -> int = fun n  ->  sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digitalRoot n = digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digitalRoot  : int -> int = fun n  ->  digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n = match n with | n::ns -> n;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n::ns -> n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n = match n with | n::ns -> n :: ns;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n::ns -> n :: ns;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n = match n with | n::ns -> n :: ns;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n::ns -> n :: ns;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n mod (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> n - (List.hd ((n mod 10) :: ns));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n = match n with | n::ns -> n :: ns;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n::ns -> n :: ns;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n = match n with | n::ns -> n;;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n::ns -> n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n with | n -> [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in match n with | n -> List.hd ((n mod 10) :: ns);;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x;;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs -> x;;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> List.hd xs;;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | _ -> List.hd xs;;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x;;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs -> x;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  ->  match e with | VarX  -> \"x\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n\nlet _ = exprToString VarX;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  ->  match e with | VarX  -> e;;\n\nlet _ = exprToString VarX;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  ->  match e with | VarX  -> \"x\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  ->  match e with | VarX  -> e;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  ->  match e with | VarX  -> \"x\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  ->  match e with | VarX  -> e;;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((failwith \"to be written\"), b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "annotated_fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "annotated": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero  : int list -> int list -> int list  * int list = fun l1 l2  ->  (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "annotated_fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "annotated": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero  : int list -> int list -> int list  * int list = fun l1 l2  ->  (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = () in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = [(fun x  -> x)] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base = [(fun x  -> x)] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = function | e -> e in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base = function | e -> e in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = f in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = x a in let base = pipe in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = x a in let base = pipe in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = function | e -> e in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base = function | e -> e in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base c = c in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base c = c in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = [] in List.fold_left f base fs;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = 2;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  2;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = 2;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  2;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n", "bad": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n", "annotated": "\nlet wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let (func,boo) = f in func;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "bad": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n"}

only_anno_corr 
{"fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "annotated_fix": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "annotated": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs in let base = fs in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a b = a x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a b = a x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p s a = a x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p s a = a x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x p a = x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x p a = x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a b = a x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a b = a x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a d = a x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a d = a x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x p a = x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x p a = x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x d a = x a in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x d a = x a in\n  let base p = p in List.fold_left f base (List.rev fs);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a d = a x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a d = a x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a d = a x in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a d = a x in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x d a = x a in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x d a = x a in\n  let base p = p in List.fold_left f base (List.rev fs);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = a x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = x a in let base = pipe [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = a x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = x a in let base = pipe [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x p = a x in let base p = p in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x p = a x in let base p = p in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> listReverse t;;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> listReverse t;;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h @ (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> h @ (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> listReverse t;;\n", "bad": "\nlet rec listReverse l =\n  match l with | h::t -> [h] :: (listReverse t) | [] -> [l];;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | h::t -> [h] :: (listReverse t) | [] -> [l];;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> listReverse t;;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h @ (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> h @ (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> listReverse t;;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> h @ (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> h @ (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> listReverse t;;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n", "annotated_fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then additivePersistence ((sumList (digitsOfInt n)) + 1);;\n", "annotated": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  if n > 9 then additivePersistence ((sumList (digitsOfInt n)) + 1);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = match n < 0 with | true  -> [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "bad": "\nlet rec build (rand,depth) = failwith \"hi\";;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"hi\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "bad": "\nlet rec wwhile (f,b) = match f with | (x,y) -> if y = true then wwhile (f, x);;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  match f with | (x,y) -> if y = true then wwhile (f, x);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = b f in if y = true then wwhile (f, x) else x;;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let (x,y) = b f in if y = true then wwhile (f, x) else x;;\n"}

only_anno_corr 
{"fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n", "annotated_fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  sepConcat \";\" (List.map f l);;\n", "bad": "\nlet stringOfList f l = List.map (fun a  -> a l);;\n", "annotated": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (fun a  -> a l);;\n"}

only_anno_corr 
{"fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n", "annotated_fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  sepConcat \";\" (List.map f l);;\n", "bad": "\nlet stringOfList f l = List.map (fun a  -> a l);;\n", "annotated": "\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (fun a  -> a l);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> t :: (listReverse t);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | h::t -> t :: (listReverse t);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs b  ->  let f a x = x a in let base = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs b  ->  let f a x = x a in let base = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs b  ->  let f a x = x a in let base = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs b  ->  let f a x = x a in let base = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = 0;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  0;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) b), b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (((f b) b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = 0;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  0;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x y = x in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x y = x in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base b c = c in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a x = match x with | (x',y) -> x' a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a x = match x with | (x',y) -> x' a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x c = x in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x c = x in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x a x = match x with | (x',y) -> x' a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x a x = match x with | (x',y) -> x' a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs n  ->  let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base b = b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> l | (_::tail::[])::[] -> l;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> l | (_::tail::[])::[] -> l;;\n", "bad": "\nlet rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  function | [] -> l | h::t -> listReverse (h :: l) t;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> l | (_::tail::[])::[] -> l;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> l | (_::tail::[])::[] -> l;;\n", "bad": "\nlet rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t;;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  function | [] -> l | h::t -> listReverse (h :: l) t;;\n"}

only_anno_corr 
{"fix": "\nlet rec listReverse l = match l with | [] -> [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [];;\n", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [1];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"];;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | h::t -> [1];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"];;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n));;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec listReverse l = List.rev l;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n a =\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n)) (a + 1)\n  else a;;\n", "annotated": "\nlet rec listReverse l = List.rev l;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n a  -> \n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n)) (a + 1)\n  else a;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0\n  then []\n  else ((n mod 10) :: myList) :: (digitsOfInt (n - (n mod 10)));;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  ->  if n <= 0 then [] else [n];;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 4);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (10, 39)), 4);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 4);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (10, 39)), 4);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 4);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 4);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 4);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 4);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 7);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 7);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 7);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 7);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> 11\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand (1, 7) with\n  | 1 -> 11\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> 1\n  | 2 -> 2\n  | 3 -> 3\n  | 4 -> 4\n  | 5 -> 5\n  | 6 -> 6\n  | 7 -> 7;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (10, 39)), 4);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand (1, 7) with\n  | 1 -> 1\n  | 2 -> 2\n  | 3 -> 3\n  | 4 -> 4\n  | 5 -> 5\n  | 6 -> 6\n  | 7 -> 7;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (10, 39)), 4);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 7);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 7);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 7);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 7);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> 11\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand (1, 7) with\n  | 1 -> 11\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (VarX, VarY);;\n", "bad": "\nlet rec build (rand,depth) = rand (1, 4);;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  rand (1, 4);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = \"\" in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = \"\" in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = () in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base x b = 0 + b in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base x b = 0 + b in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base x = (+) x in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base x = (+) x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rdm = rand in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 -> let halff = rand in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand with\n  | 0 -> let halff = rand in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rdm = rand in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (v,b) -> if b = true then f v else f (v - 1);;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match b with | (v,b) -> if b = true then f v else f (v - 1);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (v,b) -> if b = true then f v else f (v - 1);;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match b with | (v,b) -> if b = true then f v else f (v - 1);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n", "bad": "\nlet rec wwhile (f,b) = match b with | (e,boo) -> if boo = true then e;;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  match b with | (e,boo) -> if boo = true then e;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else [];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else [];;\n", "bad": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if (n / 10) <> 0 then digitsOfInt (n / 10);;\n", "annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let int list digInt = n mod 10 in\n  if (n / 10) <> 0 then digitsOfInt (n / 10);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let (b',c') = f b in if b = b' then b else wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let (b',c') = f b in if b = b' then b else wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"}

only_anno_corr 
{"fix": "\nlet bigAdd l1 l2 = failwith \"TBD\";;\n", "annotated_fix": "\nlet bigAdd  : int list -> int list -> int list = fun l1 l2  ->  failwith \"TBD\";;\n", "bad": "\nlet bigAdd = 0;;\n", "annotated": "\nlet bigAdd  : int list -> int list -> int list = fun  ->  0;;\n"}

only_anno_corr 
{"fix": "\nlet bigAdd l1 l2 = failwith \"TBD\";;\n", "annotated_fix": "\nlet bigAdd  : int list -> int list -> int list = fun l1 l2  ->  failwith \"TBD\";;\n", "bad": "\nlet bigAdd = failwith \"TBD\";;\n", "annotated": "\nlet bigAdd  : int list -> int list -> int list = fun  ->  failwith \"TBD\";;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then ((l1 @ (clone 0 (x2 - x1))), l2)\n  else (l1, (l2 @ (clone 0 (x1 - x2))));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then ((l1 @ (clone 0 (x2 - x1))), l2)\n  else (l1, (l2 @ (clone 0 (x1 - x2))));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then l1 @ (clone 0 (x2 - x1)) else l2 @ (clone 0 (x1 - x2));;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then l1 @ (clone 0 (x2 - x1)) else l2 @ (clone 0 (x1 - x2));;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then ((l1 @ (clone 0 (x2 - x1))), l2)\n  else (l1, (l2 @ (clone 0 (x1 - x2))));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then ((l1 @ (clone 0 (x2 - x1))), l2)\n  else (l1, (l2 @ (clone 0 (x1 - x2))));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then l1 @ (clone 0 (x2 - x1)) else l2 @ (clone 0 (x1 - x2));;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then l1 @ (clone 0 (x2 - x1)) else l2 @ (clone 0 (x1 - x2));;\n"}

only_anno_corr 
{"fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n", "annotated_fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map f l in sepConcat \";\" x;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map (f l) in sepConcat \";\" x;;\n", "annotated": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map (f l) in sepConcat \";\" x;;\n"}

only_anno_corr 
{"fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n", "annotated_fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map f l in sepConcat \";\" x;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map (f l) in sepConcat \";\" x;;\n", "annotated": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  let x = List.map (f l) in sepConcat \";\" x;;\n"}

only_anno_corr 
{"fix": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "annotated_fix": "\nlet listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_anno_corr 
{"fix": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "annotated_fix": "\nlet listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_anno_corr 
{"fix": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "annotated_fix": "\nlet listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_anno_corr 
{"fix": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "annotated_fix": "\nlet listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n", "annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base _ y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base _ y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x b a = a x in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x b a = a x in let base y = y in List.fold_left f base fs;;\n"}

only_pre_corr
{"fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n", "annotated_fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n", "annotated": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n"}

only_pre_corr
{"fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n", "annotated_fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::l' -> [listReverse l'; x];;\n", "annotated": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> 0 | x::l' -> [listReverse l'; x];;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rand = makeRand (1, 7) in let x = rand (1, 7) in rand;;\n", "annotated": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rand = makeRand (1, 7) in let x = rand (1, 7) in rand;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rand = makeRand (1, 7) in let x = rand (1, 7) in rand;;\n", "annotated": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rand = makeRand (1, 7) in let x = rand (1, 7) in rand;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  if depth > 0 then Format.sprintf \"%d\" depth;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  if depth > 0 then Format.sprintf \"%d\" depth;;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"}

only_pre_corr
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_pre_corr
{"fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"}

only_anno_corr 
{"fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | () -> if b00l then num else wwhile (f, num);;\n", "annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f b with | () -> if b00l then num else wwhile (f, num);;\n"}

only_anno_corr 
{"fix": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if k = h then 10 else assoc (d, k, t);;\n", "annotated": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with | [] -> d | h::t -> if k = h then 10 else assoc (d, k, t);;\n"}

only_anno_corr 
{"fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;\n", "bad": "\nlet rec mulByDigit i l =\n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n", "annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n"}

only_anno_corr 
{"fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n", "annotated_fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (h, b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n", "annotated_fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (h, b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = x in ((g (f b)), b));;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (let g x = x in ((g (f b)), b));;\n"}

only_anno_corr 
{"fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n", "annotated_fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (h, b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in (h, b));;\n", "annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (let h = f in (h, b));;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base z = z in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base z = z in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\nlet pipe fs = let f a x = x in let base z = z in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x in let base z = z in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base y = y in List.fold_left f base fs;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"ugh\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"ugh\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"ugh\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"ugh\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"sin(pi*%s)\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"cos(pi*%s)\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"((%s + %s)/2)\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s*%s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head (sumList tail);;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | head::tail -> head (sumList tail);;\n"}

only_anno_corr 
{"fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head (sumList tail);;\n", "annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | head::tail -> head (sumList tail);;\n"}

only_anno_corr 
{"fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n", "annotated_fix": "\nlet rec padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then List.append (clone 0 (lenl1 - lenl2)) l1\n  else List.append (clone 0 (lenl1 - lenl2)) l2;;\n", "annotated": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then List.append (clone 0 (lenl1 - lenl2)) l1\n  else List.append (clone 0 (lenl1 - lenl2)) l2;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX ();;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> buildX ();;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> buildSine e;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with | VarX  -> x | VarY  -> y | Sine e -> buildSine e;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> buildSine e;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with | VarX  -> x | VarY  -> y | Sine e -> buildSine e;;\n"}

only_anno_corr 
{"fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX | VarY  -> buildY;;\n", "annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> buildX | VarY  -> buildY;;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((wwhile (f b)), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((wwhile (f b)), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet fixpoint (f,b) = f b;;\n", "annotated_fix": "\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  f b;;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_anno_corr 
{"fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

only_anno_corr 
{"fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

only_anno_corr 
{"fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

only_anno_corr 
{"fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

