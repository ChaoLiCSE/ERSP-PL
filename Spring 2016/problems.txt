only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}

only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd"}

only_pre_corr
{"bad": "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> 0\n| hd::tl -> listReverse tl"}

only_anno_corr 
{"bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m", "annotated_fix": "let b = exprToString Sine(VarX)", "fix": "let b = exprToString Sine(VarX)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m"}

only_anno_corr 
{"bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\"", "annotated_fix": "let b = exprToString (Cosine(VarX))", "fix": "let b = exprToString (Cosine(VarX))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\""}

only_anno_corr 
{"bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"", "annotated_fix": "let b = exprToString (Cosine(VarX))", "fix": "let b = exprToString (Cosine(VarX))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\""}

only_anno_corr 
{"bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p", "annotated_fix": "let b = exprToString (Average(Cosine(VarX),VarY))", "fix": "let b = exprToString (Average(Cosine(VarX),VarY))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated_fix": "let _ = eval (Square(VarX),1.0,0.5)", "fix": "let _ = eval (Square(VarX),1.0,0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated_fix": "let _ = eval (Square(VarX),1.0,0.5)", "fix": "let _ = eval (Square(VarX),1.0,0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated_fix": "let _ = eval (MyExpr(VarX,VarY,VarX),1.0, 2.0)", "fix": "let _ = eval (MyExpr(VarX,VarY,VarX),1.0, 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}

only_anno_corr 
{"bad": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\"", "annotated_fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Cube     of expr\n| Addition of expr * expr", "fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Cube     of expr\n| Addition of expr * expr", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\""}

only_anno_corr 
{"bad": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\"", "annotated_fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Tan      of expr\n| Sin_Avg  of expr * expr * expr", "fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Tan      of expr\n| Sin_Avg  of expr * expr * expr", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\""}

only_anno_corr 
{"bad": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)", "annotated_fix": "let rec sqsum : int list -> int  = fun  xs  ->  \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)", "fix": "let rec sqsum xs = \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)", "annotated": "let rec sqsum : int list -> int  = fun  xs  ->  \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}

only_pre_corr
{"bad": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nlength_diff = (List.length l1 - List.length l2)\nelse \nlength_diff", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  if List.length l1 < List.length l2\nthen true\nelse false", "fix": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen true\nelse false", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nlength_diff = (List.length l1 - List.length l2)\nelse \nlength_diff"}

only_pre_corr
{"bad": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []", "fix": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []"}

only_pre_corr
{"bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> h\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> h\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')", "fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2", "annotated_fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2", "annotated_fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2", "annotated_fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2", "annotated_fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2"}

only_anno_corr 
{"bad": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))", "annotated_fix": "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "fix": "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))"}

only_pre_corr
{"bad": "let buildOp2()                     = Op2(e1,e2,e3)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less)", "fix": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Op2()                      ->  Op2(e1,e2,e3)"}

only_pre_corr
{"bad": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less)", "fix": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less,b_less)"}

only_pre_corr
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)", "annotated_fix": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "fix": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)"}

only_anno_corr 
{"bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}

only_anno_corr 
{"bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}

only_pre_corr
{"bad": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n", "annotated_fix": "let _ = additivePersistence 0", "fix": "let _ = additivePersistence 0", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n"}

only_pre_corr
{"bad": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)", "annotated_fix": "let _ = additivePersistence 0", "fix": "let _ = additivePersistence 0", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)"}

only_pre_corr
{"bad": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "annotated_fix": "let _ = additivePersistence 0", "fix": "let _ = additivePersistence 0", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}

only_pre_corr
{"bad": "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "annotated_fix": "let f x = \nlet xx = x*x*x in (xx,xx<100)", "fix": "let f x = \nlet xx = x*x*x in (xx,xx<100)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex) -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex) -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}

only_pre_corr
{"bad": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x::[]) (n-1)", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse\nclone (x) (n-1)", "fix": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse\nclone (x::[]) (n-1)"}

only_pre_corr
{"bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)"}

only_pre_corr
{"bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h"}

only_pre_corr
{"bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h ::[]", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h ::[]"}

only_pre_corr
{"bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)", "annotated_fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}

only_anno_corr 
{"bad": "let sqsum xs = \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs"}

only_anno_corr 
{"bad": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs"}

only_anno_corr 
{"bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_pre_corr
{"bad": "let buildSqrt(e)                   = Sqrt(e)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Abs(e)\t\t\t    ->  Abs(e)", "fix": "let buildAbs(e)\t\t\t   = Abs(e)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Sqrt(e)                    ->  Sqrt(e)"}

only_pre_corr
{"bad": "let rec eval (e,x,y) = match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"}

only_pre_corr
{"bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fs x in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fs x in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nlet f a x = fs a x in\nlet base = fs a in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a x in\nlet base = fs a in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nlet f a x = fs a x in\nlet base = 0 in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a x in\nlet base = 0 in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nlet f a x = fs a in\nlet base = 0 in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = 0 in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec sumList xs = \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "fix": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe = fun x -> fun (fun y)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun (fun y)"}

only_pre_corr
{"bad": "let pipe = fun x -> fun2 fun1", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 fun1"}

only_pre_corr
{"bad": "let pipe = fun x -> fun2 fun1 x", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 fun1 x"}

only_pre_corr
{"bad": "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'"}

only_pre_corr
{"bad": "let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl", "annotated_fix": "let _ = listReverse [1; 2; 3; 4; 9]", "fix": "let _ = listReverse [1; 2; 3; 4; 9]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "fix": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "fix": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = let ass y -> y in\nass y in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = let ass y -> y in\nass y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []", "annotated_fix": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l", "fix": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []"}

only_pre_corr
{"bad": "let rec build (rand, depth) = if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "annotated_fix": "let rand = makeRand(10,12)", "fix": "let rand = makeRand(10,12)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()"}

only_pre_corr
{"bad": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "fix": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()", "annotated_fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi * eval (a,x,y))\n| Cosine a -> cos (pi * eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi * eval (a,x,y))\n| Cosine a -> cos (pi * eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"}

only_anno_corr 
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y"}

only_pre_corr
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a"}

only_pre_corr
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint f x'", "annotated_fix": "let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,x)  ->  \nlet x' = f x in\nif x' = x then x else fixpoint (f, x')", "fix": "let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint (f, x')", "annotated": "let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,x)  ->  \nlet x' = f x in\nif x' = x then x else fixpoint f x'"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX\nelse\nbuildY\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "annotated_fix": "let _ = buildY()", "fix": "let _ = buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX\nelse\nbuildY\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "annotated_fix": "let _ = buildY()", "fix": "let _ = buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"}

only_pre_corr
{"bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)"}

only_pre_corr
{"bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)", "fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)", "fix": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "fix": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f x in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f x in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "annotated_fix": "let int list digInt = []", "fix": "let int list digInt = []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \ndigInt = n mod 10 :: digitsOfInt( n / 10)"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "fix": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "fix": "let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []"}

only_pre_corr
{"bad": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "annotated_fix": "let listReverse : 'a list -> 'a list = fun  l  ->  listReverse2 l []", "fix": "let listReverse l = listReverse2 l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)"}

only_pre_corr
{"bad": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l", "fix": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l"}

only_pre_corr
{"bad": "let rec exprToString e = \nstring x = e", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nstring x = e"}

only_pre_corr
{"bad": "let rec exprToString e = \nString x = e", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nString x = e"}

only_pre_corr
{"bad": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "fix": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )"}

only_anno_corr 
{"bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX\n| None -> 0", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun X()                        ->  VarX", "fix": "let buildX()                       = VarX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX\n| None -> 0"}

only_anno_corr 
{"bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun X()                        ->  VarX", "fix": "let buildX()                       = VarX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> float_of_int x\n| VarX -> float_of_int y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> float_of_int x\n| VarX -> float_of_int y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi * pi)\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi * pi)\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi * (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi * (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'", "annotated_fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 2 | 3 -> buildY()\n| 1 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 2 | 3 -> buildY()\n| 1 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}

only_anno_corr 
{"bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]"}

only_anno_corr 
{"bad": "let rec mulByDigit i l = \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "fix": "let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l"}

only_pre_corr
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}

only_pre_corr
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}

only_pre_corr
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail::tail", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail", "fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail::tail"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x", "annotated_fix": "let rand = makeRand(1,7)", "fix": "let rand = makeRand(1,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nThresh (a,b,c,d) -> exprToString a b c d"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "fix": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "fix": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "fix": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile f a", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "fix": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with\n|(a,c)->if not c then\na\nelse\nwwhile f a"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nfailwith \"ugh\"", "fix": "let rec build (rand, depth) =\nfailwith \"ugh\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nfailwith \"ugh\"", "fix": "let rec build (rand, depth) =\nfailwith \"ugh\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs"}

only_pre_corr
{"bad": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false"}

only_pre_corr
{"bad": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)"}

only_anno_corr 
{"bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "fix": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)"}

only_anno_corr 
{"bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "annotated_fix": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l"}

only_pre_corr
{"bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "annotated_fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)"}

only_pre_corr
{"bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "annotated_fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)"}

only_anno_corr 
{"bad": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile (f, if b = (f b) then b else b)", "fix": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = (f x) in (xx, xx != b) in f"}

only_anno_corr 
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval e)\n| Cosine e-> cos(pi*. eval e)\n| Average (e1,e2) -> (eval e1 +. eval e2) /. 2\n| Times (e1,e2) -> eval e1 *. eval e2\n| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval e)\n| Cosine e-> cos(pi*. eval e)\n| Average (e1,e2) -> (eval e1 +. eval e2) /. 2\n| Times (e1,e2) -> eval e1 *. eval e2\n| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4"}

