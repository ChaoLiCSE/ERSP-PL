only_anno_corr 
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}

only_pre_corr
{"annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (List.rev i t);;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (List.rev i t);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (mulByDigit i t);;\n"}

only_pre_corr
{"annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> 0\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"}

only_pre_corr
{"annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_pre_corr
{"annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> h in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> h in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "annotated_fix": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> [h] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (match [adder\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [helper [] (h * i)])]\n       with\n       | h::t -> h);;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (match [adder\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [helper [] (h * i)])]\n       with\n       | h::t -> h);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      [adder\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n            [helper [] (h * i)])];;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [helper [] (h * i)];;\n"}

only_pre_corr
{"annotated": "\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y -> x);;\n", "bad": "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y -> x);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           [adder (x :: y)]);;\n"}

only_anno_corr 
{"annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n"}

only_anno_corr 
{"annotated": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "bad": "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "fix": "\nlet rec sqsum xs = match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n", "annotated_fix": "\nlet rec sqsum  : int list -> int  = fun xs  ->  match xs with | [] -> 0 | h::t -> (h * h) + (sqsum t);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let c' = f b in if c' = b then c' else wwhile (f, c');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "bad": "\nlet rec wwhile (f,b) = let c' = f b in if c' = b then c' else wwhile (f, c');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "fix": "\nlet rec wwhile (f,b) = let c' = f b in if c' = b then c' else wwhile (f, c');;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let c' = f b in if c' = b then c' else wwhile (f, c');;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  let c' = f b in let b' = b in if c' = b then c' else wwhile (c', b');;\n", "bad": "\nlet rec wwhile (f,b) =\n  let c' = f b in let b' = b in if c' = b then c' else wwhile (c', b');;\n", "fix": "\nlet rec wwhile (f,b) = let c' = f b in if c' = b then c' else wwhile (f, c');;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let c' = f b in if c' = b then c' else wwhile (f, c');;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (3, 4) in\n     match (randNum, randNum2) with\n     | (1,3) -> buildSine (buildX ())\n     | _ -> buildCosine (buildX ()));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (3, 4) in\n     match (randNum, randNum2) with\n     | (1,3) -> buildSine (buildX ())\n     | _ -> buildCosine (buildX ()));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (buildX ())\n     | (2,2) -> buildCosine (buildX ())\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (buildX ())\n     | (2,2) -> buildCosine (buildX ())\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (deth - 1))))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (deth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (depth - 1))))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let randNumber = rand (1, 2) in\n    match randNumber with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     let randNum4 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildOp1 (build (rand, (depth - 1)))\n          | 2 -> buildOp1 (build (rand, (depth - 1)))\n          | _ ->\n              (match randNum4 with\n               | 1 ->\n                   buildTimes\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 2 ->\n                   buildAverage\n                     ((build (rand, (depth - 1))),\n                       (build (rand, (depth - 1))))\n               | 3 ->\n                   buildTimes\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | 4 ->\n                   buildAverage\n                     ((build (rand, (depth - 2))),\n                       (build (rand, (depth - 2))))\n               | _ -> failwith \"AHH\")));;\n"}

only_pre_corr
{"annotated": "\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  float_of_string (exprToString e);;\n"}

only_pre_corr
{"annotated": "\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  float_of_string (exprToString e);;\n"}

only_pre_corr
{"annotated": "\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  float_of_string (exprToString e);;\n"}

only_pre_corr
{"annotated": "\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  float_of_string (exprToString e);;\n"}

only_pre_corr
{"annotated": "\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  float_of_string (exprToString e);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n"}

only_pre_corr
{"annotated": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | [] -> d\n  | h::t -> if h = k then return h else assoc (d, k, t);;\n", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if h = k then return h else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  if n < 10 then [] else (let myList = digits n in myList);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  if n < 10 then [] else (let myList = digits n in myList);;\n"}

only_anno_corr 
{"annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"}

only_anno_corr 
{"annotated": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"}

only_pre_corr
{"annotated": "\nlet rec clone  : 'a -> int -> 'a list = fun x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone h) :: (x (n - 1)));;\n", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone h) :: (x (n - 1)));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n", "annotated_fix": "\nlet rec clone  : 'a -> int -> 'a list = fun x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n"}

only_pre_corr
{"annotated": "\nlet rec clone  : 'a -> int -> 'a list = fun x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone t (n - 1)) :: h);;\n", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone t (n - 1)) :: h);;\n", "fix": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n", "annotated_fix": "\nlet rec clone  : 'a -> int -> 'a list = fun x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n"}

only_pre_corr
{"annotated": "\nlet rec clone  : 'a -> int -> 'a list = fun x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n", "fix": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n", "annotated_fix": "\nlet rec clone  : 'a -> int -> 'a list = fun x n  -> \n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_pre_corr
{"annotated": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun d k l  -> \n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "bad": "\nlet rec assoc d k l =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc (d, k, ls);;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc (d, k, ls);;\n"}

only_anno_corr 
{"annotated": "\nlet rec additivePersistence  : int -> int = fun (a,n)  -> \n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "bad": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence  : int -> int = fun (a,n)  -> \n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n"}

only_anno_corr 
{"annotated": "\nlet rec additivePersistence  : int -> int = fun (a,n)  -> \n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "bad": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence  : int -> int = fun (a,n)  -> \n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n"}

only_anno_corr 
{"annotated": "\nlet rec additivePersistence  : int -> int = fun (a,n)  -> \n  if n < 10\n  then (a, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "bad": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence  : int -> int = fun (a,n)  -> \n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun (hd::tl)  ->  match hd with | [] -> 0 | hd -> hd + (sumList tl);;\n", "bad": "\nlet rec sumList (hd::tl) = match hd with | [] -> 0 | hd -> hd + (sumList tl);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "fix": "\nlet rec build (rand,depth) =\n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n"}

only_pre_corr
{"annotated": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "fix": "\nlet rec build (rand,depth) =\n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "fix": "\nlet rec build (rand,depth) =\n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (let g x = f x in ((g b), b));;\n"}

only_anno_corr 
{"annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = x * x in let base = f 2 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = x * x in let base = f 2 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  ->  let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n"}

only_anno_corr 
{"annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f 0 xs) xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a * a in let base = f (f 0 xs) xs in List.fold_left f base xs;;\n"}

only_anno_corr 
{"annotated": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f 0 xs) xs in List.fold_left f base xs;;\n", "annotated_fix": "\nlet sqsum  : int list -> int  = fun xs  -> \n  let f a x = a * a in let base = f (f 0 xs) xs in List.fold_left f base xs;;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n", "bad": "\nlet rec digitsOfInt n =\n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n", "bad": "\nlet rec digitsOfInt n =\n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n with | [] -> [] | h::t -> [h] :: (digitsOfInt t);;\n"}

only_anno_corr 
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n"}

only_anno_corr 
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n"}

only_pre_corr
{"annotated": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "bad": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "fix": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in\n  if x < 10 then countlist n else additivePersistence [x];;\n", "annotated_fix": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = sumList n in\n  if x < 10 then countlist n else additivePersistence [x];;\n"}

only_anno_corr 
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "fix": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"to be implemented\";;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "fix": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"to be implemented\";;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul  : int list -> int list -> int list = fun l1 l2  -> \n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul  : int list -> int list -> int list = fun l1 l2  -> \n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}

only_anno_corr 
{"annotated": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd  : int list -> int list -> int list = fun l1 l2  -> \n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n", "annotated_fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd  : int list -> int list -> int list = fun l1 l2  -> \n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n"}

only_anno_corr 
{"annotated": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "annotated_fix": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  failwith \"TBD\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "bad": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"TBD\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = x (a + 1) in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x (a + 1) in let base = 0 in List.fold_left f base fs;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Printf.printf buildSine s;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Printf.printf buildSine s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Format.printf buildSine s;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Format.printf buildSine s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base = fs in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs a in let base x = x in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x = x in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.size lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.size (palHelper wEx)) = 0 then true else false;;\n", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.size lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.size (palHelper wEx)) = 0 then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = lst\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "annotated_fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = lst\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}

only_anno_corr 
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  if (List.hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "bad": "\nlet rec sumList xs =\n  if (List.hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "fix": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  -> \n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  function | [] -> 0 | h::t -> h + (sumList t);;\n", "bad": "\nlet rec sumList xs = function | [] -> 0 | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1 else l2;;\n", "annotated_fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1 else l2;;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1 else l2;;\n", "annotated_fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1 else l2;;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 1 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 1 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 1 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 1 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 1 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 1 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 1 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 1 :: (digitsOfInt ((n - 9) / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 1 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 1 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 1 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 1 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 1 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 1 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 1 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 1 :: (digitsOfInt ((n - 9) / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "bad": "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | _::tl -> listReverse tl;;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))));;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\"\n  | VarY  -> \"\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"\"\n  | VarY  -> \"\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}

only_pre_corr
{"annotated": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  if i > 0 then mulByDigit (i - 1) bigAdd l l else 0;;\n", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) bigAdd l l else 0;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else 0;;\n", "annotated_fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  if i > 0 then mulByDigit (i - 1) (bigAdd l l) else 0;;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"annotated": "\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ =\n  let rec additivePersistence n =\n    let count = 0\n    and n' = n in count = (count + 1) in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n", "bad": "\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ =\n  let rec additivePersistence n =\n    let count = 0\n    and n' = n in count = (count + 1) in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec additivePersistence n =\n  let count = 0\n  and n' = n in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else\n    (let count = count + 1 in additivePersistence (sumList (digitsOfInt n)));;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> List.hd xs;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | _ -> List.hd xs;;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> List.hd xs;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | _ -> List.hd xs;;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x;;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x;;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs' -> x;;\n"}

only_pre_corr
{"annotated": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs -> x + x;;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x + x;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x;;\n", "annotated_fix": "\nlet rec sumList  : int list -> int = fun xs  ->  match xs with | [] -> [] | x::xs -> x;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n"}

only_pre_corr
{"annotated": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "fix": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarX), 0.2, 0.3);;\n", "annotated_fix": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarX), 0.2, 0.3);;\n"}

only_pre_corr
{"annotated": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "fix": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarX), 0.2, 0.3);;\n", "annotated_fix": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarX), 0.2, 0.3);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build ((makeRand (5, 16)), depth))\n     | 2 ->\n         buildTimes\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | 3 ->\n         buildAverage\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | _ -> buildY ());;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build ((makeRand (5, 16)), depth))\n     | 2 ->\n         buildTimes\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | 3 ->\n         buildAverage\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | _ -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n"}

only_pre_corr
{"annotated": "\nlet wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let (func,boo) = f in func;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "bad": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "fix": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n", "annotated_fix": "\nlet wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  let (func,boo) = f in func;;\n"}

only_anno_corr 
{"annotated": "\nlet assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "bad": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "annotated_fix": "\nlet rec assoc  : 'a * 'b * ('b * 'a) list -> 'a  = fun (d,k,l)  -> \n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n"}

only_anno_corr 
{"annotated": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "annotated_fix": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n"}

only_pre_corr
{"annotated": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "annotated_fix": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n"}

only_pre_corr
{"annotated": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "annotated_fix": "\nlet rec sepConcat  : string -> string list -> string = fun sep sl  -> \n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [l] | h::t -> h :: (listReverse t);;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> h :: (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [l] | h::t -> [h] :: (listReverse t);;\n"}

only_pre_corr
{"annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "fix": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "annotated_fix": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n"}

only_anno_corr 
{"annotated": "\nlet digitsOfInt  : int -> int list = fun n  ->  match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "bad": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in if r = 0 then buildX else if r = 1 then buildY;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in if r = 0 then buildX else if r = 1 then buildY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX else buildY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX else buildY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (e1, e2);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (e1, e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = function | g -> a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n"}

only_anno_corr 
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base x y = y in List.fold_left f base fs;;\n"}

only_pre_corr
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((let f x = f x in f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = f x in f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> f b), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((fun x  -> f b), b);;\n"}

only_anno_corr 
{"annotated": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((let f x = wwhile (f, x) in f b), b);;\n", "bad": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = wwhile (f, x) in f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> f b), b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((fun x  -> f b), b);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX else buildY)\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX else buildY)\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n"}

only_anno_corr 
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | h1 -> [h1] | h::t -> h :: (listReverse t);;\n", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1 -> [h1] | h::t -> h :: (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> h :: (listReverse t);;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> h :: (listReverse t);;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9 then 1 :: count else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9 then 1 :: count else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) & (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) & (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) &&& (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) &&& (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  1 @ x;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  1 @ x;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  [1; 2];\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence  : int -> int = fun n  -> \n  [1; 2];\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n"}

only_pre_corr
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: (digitsOfInt n);;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) && (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) && (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (x additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (x additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n", "annotated_fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList  : int list -> int = fun xs  -> \n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand (1, 7) with\n  | _ -> rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "fix": "\nlet rec build (rand,depth) = match rand (1, 7) with | _ -> rand (1, 7);;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  match rand (1, 7) with | _ -> rand (1, 7);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  -> \n  if (wwhile (f, b)) = b then b else wwhile (f, (wwhile (f, b)));;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> 0;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> 0;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else param\n  | _ -> b;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with\n  | (func,param) -> if param = true then func param else param\n  | _ -> b;;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else param\n  | _ -> b;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with\n  | (func,param) -> if param = true then func param else param\n  | _ -> b;;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with\n  | (func,param) -> if param = true then f param else 0\n  | _ -> b;;\n", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then f param else 0\n  | _ -> b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (func,param) -> if param = true then f param else 0;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match (f, b) with | (func,param) -> if param = true then f param else 0;;\n"}

only_pre_corr
{"annotated": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (sepConcat f) (f l);;\n", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "annotated_fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList  : ('a -> string) -> 'a list -> string = fun f l  ->  List.map (sepConcat f) l;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_pre_corr
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = a in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = 0 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  ->  let f a x = x a in let base = 3 in List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}

only_anno_corr 
{"annotated": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "bad": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "annotated_fix": "\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}

only_pre_corr
{"annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  ->  if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "bad": "\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <> 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  if i <> 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n"}

only_pre_corr
{"annotated": "\nlet rec exprToString  : expr -> string = fun e  ->  (string x) = e;;\n", "bad": "\nlet rec exprToString e = (string x) = e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin\" ^ (exprToString a)\n  | Cosine a -> \"cos\" ^ (exprToString a)\n  | Average (a,b) -> (exprToString a) ^ (\"/\" ^ (exprToString b))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      (exprToString a) ^\n        (\"<\" ^\n           ((exprToString b) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin\" ^ (exprToString a)\n  | Cosine a -> \"cos\" ^ (exprToString a)\n  | Average (a,b) -> (exprToString a) ^ (\"/\" ^ (exprToString b))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      (exprToString a) ^\n        (\"<\" ^\n           ((exprToString b) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  failwith \"TBD\";;\n\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "bad": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "bad": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_pre_corr
{"annotated": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper l [];;\n", "bad": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper l [];;\n", "fix": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n"}

only_anno_corr 
{"annotated": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence  : int -> int = fun n  ->  let digits n = x in sumList x;;\n", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = let digits n = x in sumList x;;\n", "fix": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = digits n;;\n", "annotated_fix": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence  : int -> int = fun n  ->  digits n;;\n"}

only_pre_corr
{"annotated": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence  : int -> int = fun n  ->  digits n sumList n;;\n", "bad": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n", "fix": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = digits n;;\n", "annotated_fix": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence  : int -> int = fun n  ->  digits n;;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 3) in\n    match x with\n    | 0 -> buildY ()\n    | 1 -> buildX ()\n    | 2 -> buildY ()\n    | 3 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 3) in\n    match x with\n    | 0 -> buildY ()\n    | 1 -> buildX ()\n    | 2 -> buildY ()\n    | 3 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|2|3 -> buildY () | 1 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "bad": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|2|3 -> buildY () | 1 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos pi\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos pi\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) ( *. ) (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) ( *. ) (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (((a * b) * c) * d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (((a * b) * c) * d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}

only_pre_corr
{"annotated": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> 0 | x::l' -> listReverse l';;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  ->  match l with | [] -> 0 | x::l' -> listReverse l';;\n"}

only_pre_corr
{"annotated": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> 0 | x::l' -> (listReverse l') :: x;;\n", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') :: x;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ head;;\n", "annotated_fix": "\nlet rec listReverse  : 'a list -> 'a list = fun l  -> \n  match l with | [] -> [] | head::tail -> (listReverse tail) @ head;;\n"}

only_pre_corr
{"annotated": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z = (z + 1));;\n", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z = (z + 1));;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "annotated_fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}

only_pre_corr
{"annotated": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z + 1);;\n", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z + 1);;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "annotated_fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt  : int -> int list = fun n  -> \n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}

only_pre_corr
{"annotated": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  if depth > 0 then Format.sprintf \"%d\" depth;;\n", "bad": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "fix": "\nlet rec build (rand,depth) = if depth > 0 then Format.printf \"%d\" depth;;\n", "annotated_fix": "\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  ->  if depth > 0 then Format.printf \"%d\" depth;;\n"}

only_anno_corr 
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f b with | () -> if b00l then num else wwhile (f, num);;\n", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | () -> if b00l then num else wwhile (f, num);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  -> \n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n"}

only_anno_corr 
{"annotated": "\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n", "bad": "\nlet rec mulByDigit i l =\n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;\n", "annotated_fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit  : int -> int list -> int list  = fun i l  -> \n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval expr x y))\n  | Cosine expr -> cos (pi *. (eval expr x y))\n  | Average (expr,expr1) -> ((eval expr x y) +. (eval expr1 x y)) /. 2\n  | Times (expr,expr1) -> (eval expr x y) *. (eval expr1 x y)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval expr x y) < (eval expr1 x y)\n      then eval expr2 x y\n      else eval expr3 x y;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval expr x y))\n  | Cosine expr -> cos (pi *. (eval expr x y))\n  | Average (expr,expr1) -> ((eval expr x y) +. (eval expr1 x y)) /. 2\n  | Times (expr,expr1) -> (eval expr x y) *. (eval expr1 x y)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval expr x y) < (eval expr1 x y)\n      then eval expr2 x y\n      else eval expr3 x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> (eval (expr, x, y)) +. (eval (expr1, x, y))\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> (eval (expr, x, y)) +. (eval (expr1, x, y))\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString  : expr -> string = fun e  -> \n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, (f b));;\n", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, (f b));;\n", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"annotated": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "annotated_fix": "\nlet pipe  : ('a -> 'a) list -> ('a -> 'a) = fun fs  -> \n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}

only_anno_corr 
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n    match (rand, depth) with\n    | (_,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (_,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build : ((int * int -> int) * int) -> expr = fun (rand,depth)  -> \n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine e;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX | VarY  -> buildY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> buildX | VarY  -> buildY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX | VarY  -> buildY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> buildX | VarY  -> buildY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> 0.34 * e;;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> 0.34 * e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX | VarY  -> buildY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> buildX | VarY  -> buildY;;\n"}

only_pre_corr
{"annotated": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> build (pi * e);;\n", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> build (pi * e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX | VarY  -> buildY;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  ->  match e with | VarX  -> buildX | VarY  -> buildY;;\n"}

only_anno_corr 
{"annotated": "\nlet eval_fn e (x,y) =\n  let rv = eval  : expr * float * float -> float = fun (e, x, y) in assert (((-1.0) < ->  rv) && (rv <= 1.0)); rv;;\n", "bad": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "annotated_fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval  : expr * float * float -> float = fun (e,x,y)  -> \n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n"}

only_pre_corr
{"annotated": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  match f with | (x,true ) -> f x | (x,false ) -> x;;\n", "bad": "\nlet rec wwhile (f,b) = match f with | (x,true ) -> f x | (x,false ) -> x;;\n", "fix": "\nlet rec wwhile (f,b) = match f with | (x,true ) -> x;;\n", "annotated_fix": "\nlet rec wwhile  : ('a -> 'a * bool) * 'a -> 'a = fun (f,b)  ->  match f with | (x,true ) -> x;;\n"}

only_pre_corr
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile ((f b), b);;\n"}

only_pre_corr
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, (f b));;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_pre_corr
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, (f b));;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_pre_corr
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, (if b = (f b) then b else b));;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (if b = (f b) then b else b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  wwhile (f, b);;\n"}

only_anno_corr 
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}

only_anno_corr 
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}

only_anno_corr 
{"annotated": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n", "annotated_fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint : ('a -> 'a) * 'a -> 'a = fun (f,b)  ->  let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}

only_pre_corr
{"annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

only_pre_corr
{"annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

only_pre_corr
{"annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

only_pre_corr
{"annotated": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n", "annotated_fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero  : int list -> int list -> int list  * int list = fun l1 l2  -> \n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    List.append [l1] [(clone 0 ((List.length l1) - (List.length l2))) @ l2];;\n"}

