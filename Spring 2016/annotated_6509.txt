fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| h1::h2::t -> h1+h2 sumList t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| h1::h2::t -> h1+h2 sumList t


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x+1 sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') -> x+1 sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') -> x sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x + sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') -> x + sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') ->  1 sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') ->  1 sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') -> x sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x + sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') -> x + sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| (x::xs') -> x sumList xs'


fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| x::xs' -> x sumList xs'

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| x::xs' -> x sumList xs'


fix:
let rec digitsOfInt n = match n with
| _ -> (n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match n with
| n < 0 -> []
| _     -> n%10 digitsOfInt  n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| n < 0 -> []
| _     -> n%10 digitsOfInt  n/10


fix:
let rec digitsOfInt n = match n with
| _ -> (n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match n with
| _     -> n%10 digitsOfInt  n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| _     -> n%10 digitsOfInt  n/10


fix:
let rec digitsOfInt n = match n with
| _ -> (n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match n with
| _     -> n mod 10 digitsOfInt  n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| _     -> n mod 10 digitsOfInt  n/10


fix:
let rec digitsOfInt n = match n with
| _ -> (n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match n with
| (n mod 10) + digitsOfInt  (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| (n mod 10) + digitsOfInt  (n/10)


fix:
let rec digitsOfInt n = 
if (n<0) 
then 0
else
(n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match true with
| n<0 -> 0
| _ -> (n mod 10) + digitsOfInt  (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match true with
| n<0 -> 0
| _ -> (n mod 10) + digitsOfInt  (n/10)


fix:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
(n mod 10) :: digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
digitsOfInt  (n/10) :: (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n<=0) 
then []
else
digitsOfInt  (n/10) :: (n mod 10)


fix:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
(n mod 10) :: digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
digitsOfInt (n/10) :: (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n<=0) 
then []
else
digitsOfInt (n/10) :: (n mod 10)


fix:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
(n mod 10) :: digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
(digitsOfInt (n/10) ):: (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n<=0) 
then []
else
(digitsOfInt (n/10) ):: (n mod 10)


fix:
let rec sum n = 
if n < 0 
then failwith"TBD"
else (n mod 10) + digitalRoot n/10

bad:
let rec digitalRoot n = 
let temp = (sum n) in 
if temp > 10
then digitalRoot temp

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
let temp = (sum n) in 
if temp > 10
then digitalRoot temp


fix:
let rec sum n = 
if n < 0 
then failwith"TBD"
else (n mod 10) + digitalRoot n/10

bad:
let rec sum n = 
if n < 0 
then failwith"TBD"
else n%10 + digitalRoot n/10

annotated:
let rec sum n = 
if n < 0 
then failwith"TBD"
else n%10 + digitalRoot n/10


fix:
let rec additivePersistence n = additivePersistence_helper (n, 0)

bad:
let rec additivePersistence n = additivePersistence (n, 0)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  additivePersistence (n, 0)


fix:
let rec sum (n, i) = 
if n < 10
then (sumList (digitsOfInt n), i)
else (sumList (digitsOfInt n), 1+1)

bad:
let rec sum (n, i) = 
if n < 10
then sumList (digitsOfInt n) i
else sumList (digitsOfInt n) 1+1

annotated:
let rec sum (n, i) = 
if n < 10
then sumList (digitsOfInt n) i
else sumList (digitsOfInt n) 1+1


fix:
let rec sum (n, i) = 
if n < 10
then (sumList (digitsOfInt n), i)
else (sumList (digitsOfInt n), 1+1)

bad:
let rec sum [n;i] = 
if n < 10 || []
then [sumList (digitsOfInt n); i]
else [sumList (digitsOfInt n); 1+1]

annotated:
let rec sum [n;i] = 
if n < 10 || []
then [sumList (digitsOfInt n); i]
else [sumList (digitsOfInt n); 1+1]


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  hd :: listReverse tl

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> tl :: listReverse hd

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> tl :: listReverse hd


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  hd :: listReverse tl

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  listReverse tl :: hd

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl ->  listReverse tl :: hd


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  (listReverse tl) @ hd

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  (listReverse tl) :: hd

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl ->  (listReverse tl) :: hd


fix:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  
if hd != [] 
then (listReverse tl) :: hd
else hd

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl ->  
if hd != [] 
then (listReverse tl) :: hd
else hd


fix:
let rec last l = match l with 
| x::[] -> x
| hd::tl -> last tl 
| [] -> failwith "NO ELEMENT"

bad:
let rec listReverse l = match l with
| [] -> []
| _ -> let x = last tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| _ -> let x = last tl


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse (hd::l)

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> let x = last l


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse (hd::l)

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last l in
if x > 0
then x
else x

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> let x = last l in
if x > 0
then x
else x


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse (hd::l)

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last l in
if x > 0
then x::x
else x::x

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> let x = last l in
if x > 0
then x::x
else x::x


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse (hd::l)

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse(hd::l) tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> listReverse(hd::l) tl


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ hd

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ hd

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> listReverse tl @ hd


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ [hd]

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl :: [hd]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> listReverse tl :: [hd]


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ [hd]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ [hd]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::tl -> listReverse tl @ [hd]


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
if explode w = listReverse (explode w)
then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if explode w = listReverse (explode w)
then true
else false


fix:
let rec sumList xs = match xs with
| []     -> 0
| x::xs' -> x + sumList xs'

bad:
let rec listReverse l = 
failwith "err"

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
failwith "err"


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with 
| [] -> 0
| hd::tl -> listReverse tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> 0
| hd::tl -> listReverse tl


fix:
let rec sumList xs = match xs with
| []     -> 0
| x::xs' -> x + sumList xs'

bad:
let rec digitsOfInt n = 
listReverse reversed n

annotated:
let rec digitsOfInt n = 
listReverse reversed n


fix:
let rec sumList xs = match xs with
| []     -> 0
| x::xs' -> x + sumList xs'

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let fixpoint (f,b) = 
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b'=b then
b
else 
fixpoint (f,b')

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = f b in
if b'=b then
b
else 
fixpoint (f,b')


fix:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let b' = (b, (f b = b)) in 
wwhile (f,b')

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = (b, (f b = b)) in 
wwhile (f,b')


fix:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let b' = (b, (f b < b)) in 
wwhile (f,b')

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = (b, (f b < b)) in 
wwhile (f,b')


fix:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let f' = (f b, f'=b ) in
wwhile (f',b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' = (f b, f'=b ) in
wwhile (f',b)


fix:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let f' = (f b, f b=b ) in
wwhile (f',b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' = (f b, f b=b ) in
wwhile (f',b)


fix:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f b = (f b, b=f b) in
wwhile (f,b)


fix:
let fixpoint (f,b) =
let f b = (f b, f b = b) in
wwhile (f, b)

bad:
let fixpoint (f,b) = 
let f' = f b -> (f b, b=f b) in
wwhile(f',b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' = f b -> (f b, b=f b) in
wwhile(f',b)


fix:
let fixpoint (f,b) =
let f b = (f b, f b = b) in
wwhile (f, b)

bad:
let fixpoint (f,b) = 
let f' = fun f -> fun b -> (f b, b=f b) in
wwhile(f',b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' = fun f -> fun b -> (f b, b=f b) in
wwhile(f',b)


fix:
let fixpoint (f,b) =
let f b = (f b, f b = b) in
wwhile (f, b)

bad:
let fixpoint (f,b) =
failwith "to be d"

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
failwith "to be d"


fix:
let fixpoint (f,b) =
let f b = let b' = f b in b=b' in b'

bad:
let fixpoint (f,b) =
let f b = let b' = f b in b=b'

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f b = let b' = f b in b=b'


fix:
let fixpoint (f,b) =
let f b = let b' = f b in b=b' in b'

bad:
let fixpoint (f,b) =
let f b = let b' = f b in b=b' in

let g x = (x-1) in fixpoint (g,8)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f b = let b' = f b in b=b' in

let g x = (x-1) in fixpoint (g,8)


fix:
let b = exprToString Sine(VarX)

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin"^ exprToString m

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin"^ exprToString m


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"

bad:
let b = exprToString (Sine(VarX))

annotated:
let b = exprToString (Sine(VarX))


fix:
let b = exprToString (Cosine(VarX))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToStirng m ^ "+" ^ exprToString n ^ ")/2)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToStirng m ^ "+" ^ exprToString n ^ ")/2)"


fix:
let b = exprToString (Cosine(VarX))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n
| Tresh (m,n,o,p) -> 
"(" ^ exprToString m^ "<" ^exprToString n^"?"^exprToString o^":"^exprToString p

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n


fix:
let b = exprToString (Average(Cosine(VarX),VarY))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n
| Thresh (m,n,o,p) -> 
"(" ^ exprToString m^ "<" ^exprToString n^"?"^exprToString o^":"^exprToString p

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n
| Thresh (m,n,o,p) -> 
"(" ^ exprToString m^ "<" ^exprToString n^"?"^exprToString o^":"^exprToString p


fix:
let _ = eval(Sine,0.5,0.)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| Sine m -> sin(pi*. (eval m))
| _ -> x

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| Sine m -> sin(pi*. (eval m))
| _ -> x


fix:
let _ = eval(Sine,0.5,0.)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| Sine m -> sin(pi*. (eval (m,x,y)))
| _ -> x

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| Sine m -> sin(pi*. (eval (m,x,y)))
| _ -> x


fix:
let _ = eval((Sine(VarX)),0.3,0.)

bad:
let _ = eval((Sine(VarX)),0.5,0.)

annotated:
let _ = eval((Sine(VarX)),0.5,0.)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
eval (m,x,y) < eval (n,x,y) ? eval (o,x,y) : eval (p,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
eval (m,x,y) < eval (n,x,y) ? eval (o,x,y) : eval (p,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)


fix:
let rec build (rand, depth) = rand

bad:
let rec build (rand, depth) = rand 1 2

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand 1 2


fix:
let rec build (rand, depth) = let num = rand 4 53 in
match num with
| _ -> VarX

bad:
let rec build (rand, depth) = rand 3 4

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand 3 4


fix:
let rec build (rand, depth) =
if depth = 0
then
let num = rand in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num = rand in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then
let num = rand in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with 
| []         -> d
| (ki,vi)::t -> 
if ki=k
then vi
else assoc (d,k,t)

bad:
let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

annotated:
let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)


fix:
let rec build (rand, depth) =
if depth = 0
then
let nums (a,b) = rand in
let num = rand in 
match num with
| 0 -> VarX
| _ -> VarY
else
let nums (a,b) = rand in
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let nums (a,b) = rand in
let num = rand in 
match num with
| 0 -> VarX
| _ -> VarY
else
let nums (a,b) = rand in
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then
let nums (a,b) = rand in
let num = rand in 
match num with
| 0 -> VarX
| _ -> VarY
else
let nums (a,b) = rand in
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))


fix:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))


fix:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))


fix:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))


fix:
let _ = exprToString(Divide(Divide(VarX,VarY),VarX))

bad:
let _ = exprToString(Divide(VarX,VarY))

annotated:
let _ = exprToString(Divide(VarX,VarY))


fix:
let _ = eval (Square(VarX),1.0,0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)


fix:
let _ = eval (Square(VarX),1.0,0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2.0
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2.0
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)


fix:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString n ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

bad:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ expToString  ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ expToString  ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"


fix:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString n ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

bad:
let _ = expToString(MyExpr(VarX,VarY,VarX))

annotated:
let _ = expToString(MyExpr(VarX,VarY,VarX))


fix:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString n ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

bad:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString  ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString  ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"


fix:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString n ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

bad:
let _ = exprToString(MyExpr(VarX,VarY,VarX))

annotated:
let _ = exprToString(MyExpr(VarX,VarY,VarX))


fix:
let _ = eval (MyExpr(VarX,VarY,VarX),1.0, 2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2.0
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| MyExpr(m,n,o) -> 
if eval(m,x,y) < eval (n,x,y)
then sqrt(abs_float(eval(o,x,y)))
else eval(o,x,y) /. 2.
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2.0
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| MyExpr(m,n,o) -> 
if eval(m,x,y) < eval (n,x,y)
then sqrt(abs_float(eval(o,x,y)))
else eval(o,x,y) /. 2.
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let rec sumList xs = match xs with
h :: t -> h + sumList t
| [] -> 0

bad:
let rec sumList [xs] =

annotated:
let rec sumList : int list -> int = fun  [xs]  -> 


fix:
let rec sumList xs = match xs with
h :: t -> h + sumList t
| [] -> 0

bad:
let rec sumList xs[] =

annotated:
let rec sumList : int list -> int = fun  xs[]  -> 


fix:
let rec sumList xs = match xs with
h :: t -> h + sumList t
| [] -> 0

bad:
let rec sumList xs = (* failwith "TBD:sumList" *) 

let _ = sumList [1; 2; 3; 4]

annotated:
let rec sumList : int list -> int = fun  xs  ->  (* failwith "TBD:sumList" *) 

let _ = sumList [1; 2; 3; 4]


fix:
let _ = digitsOfInt (-352663)

bad:
let _ = digitsOfInt -352663

annotated:
let _ = digitsOfInt -352663


fix:
let rec digits n = digitsOfInt (abs n)

bad:
let rec digits n = digitsOfInt (abs n)

digits (-124074)

annotated:
let rec digits n = digitsOfInt (abs n)

digits (-124074)


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let rec assoc (d,k,l) = 
let temp = l in
let rec helper acc (d,k,l) = 
match temp with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper (d,k,l) t
in helper (d,k,l) acc

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let temp = l in
let rec helper acc (d,k,l) = 
match temp with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper (d,k,l) t
in helper (d,k,l) acc


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
uncomment after implementing assoc

annotated:
uncomment after implementing assoc


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper (d,k,l) acc

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper (d,k,l) acc


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
uncomment after implementing assoc

annotated:
uncomment after implementing assoc


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen)
then 
seen
else 
h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen)
then 
seen
else 
h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Cube     of expr
| Addition of expr * expr

bad:
let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Cube a -> "(" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Cube a -> "(" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ ")"


fix:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )
| Addition (a,b) -> eval(a,x,y) +. eval

bad:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval a) * (eval  a) *(eval a)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval a) * (eval  a) *(eval a)


fix:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )
| Addition (a,b) -> eval(a,x,y) +. eval

bad:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )


fix:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )
| Addition (a,b) -> eval(a,x,y) +. eval

bad:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )


fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

bad:
let rec build (rand,depth) =
if depth = 0 
then
match rand(1,3) with
| 1 -> buildX()
| 2 -> buildY()
else 
match rand(1,10) with
| 3 -> buildSine( build(rand,depth-1) ) 
| 4 -> buildCosine( build(rand,depth-1) )
| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )
| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )
| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )
| 8 -> buildCube( build(rand,depth-1) )
| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )
| _ -> build(rand,depth)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  -> 
if depth = 0 
then
match rand(1,3) with
| 1 -> buildX()
| 2 -> buildY()
else 
match rand(1,10) with
| 3 -> buildSine( build(rand,depth-1) ) 
| 4 -> buildCosine( build(rand,depth-1) )
| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )
| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )
| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )
| 8 -> buildCube( build(rand,depth-1) )
| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )
| _ -> build(rand,depth)


fix:
type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Tan      of expr
| Sin_Avg  of expr * expr * expr

bad:
let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Arc (a,b,c) -> "sin(pi*" ^ (exprToString (a (b,c)) ) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Arc (a,b,c) -> "sin(pi*" ^ (exprToString (a (b,c)) ) ^ ")"


fix:
exprToString Sin_Avg(1,2,3)

bad:
let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Sin_Avg (a,b,c) -> "sin(pi*(" ^ (exprToString  a) ^ "+" ^ (exprToString  b) ^ (exprToString c) ^ ")/3)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Sin_Avg (a,b,c) -> "sin(pi*(" ^ (exprToString  a) ^ "+" ^ (exprToString  b) ^ (exprToString c) ^ ")/3)"


fix:
exprToString (Tan VarX)

bad:
exprToString (Sin_Avg (VarX, VarY, VarX))

annotated:
exprToString (Sin_Avg (VarX, VarY, VarX))


fix:
let rec sqsum xs = 
match xs with
[] -> 0
| h::t -> (h*h) + (sqsum t)

bad:
let rec sqsum xs = 
match xs with
[] -> []
| h::t -> (h*h) + (sqsum t)

annotated:
let rec sqsum : int list -> int  = fun  xs  ->  
match xs with
[] -> []
| h::t -> (h*h) + (sqsum t)


fix:
let sqsum xs = 
let f a x = (a*a) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (a*a) in
let base = [] in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (a*a) in
let base = [] in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + (x*x) in
let base = a + 1 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + (x*x) in
let base = a + 1 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match a with
[] -> x
| h::t -> h x in 
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = match a with
[] -> x
| h::t -> h x in 
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match a with
[] -> x
| h::t -> h x in 
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = match a with
[] -> x
| h::t -> h x in 
let base = 0 in
List.fold_left f base fs


fix:
let _ = pipe []

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = match a with
[] -> []
| h::t -> h::[] in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match a with
[] -> []
| h::t -> (h x) 
in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = match a with
[] -> []
| h::t -> (h x) 
in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = match a with
[] -> []
| h::t -> h::[] in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match a with
[] -> x
| h::t -> (h x) in
let base = failwith "to be implemented" in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = match a with
[] -> x
| h::t -> (h x) in
let base = failwith "to be implemented" in
List.fold_left f base fs


fix:
let _ = pipe [fun x -> x*x] 3

bad:
let _ = pipe [fun x -> x; fun x -> x*x] 3

annotated:
let _ = pipe [fun x -> x; fun x -> x*x] 3


fix:
let pipe fs = 
let f a x = (fun x -> x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let _ = pipe [(fun x -> x + 1); (fun x -> x*x)] 3

bad:
let _ = pipe [fun x -> x + 1; fun x -> x*x] 3

annotated:
let _ = pipe [fun x -> x + 1; fun x -> x*x] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3

annotated:
let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " x in
let base = [] in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " x in
let base = [] in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " ^ x in
let base = [] in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " ^ x in
let base = [] in
let l = t in
List.fold_left f base l


fix:
let stringOfList f l = sepConcat (f l)

bad:
let stringOfList f l = ssepConcat (f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  ssepConcat (f l)


fix:
let stringOfList f l = List.map f l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map f l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = List.map f l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let stringOfList f l = "[" ^ ( sepConcat ";" (List.map f l) ) ^ "]"

bad:
let stringOfList f l = List.map f (sepConcat l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l)


fix:
let stringOfList f l = "[" ^ ( sepConcat ";" (List.map f l) ) ^ "]"

bad:
let stringOfList f l = "[" ^ sepConcat ^ ";" ^ List.map f l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ sepConcat ^ ";" ^ List.map f l ^ "]"


fix:
let stringOfList f l = "[" ^ ( sepConcat ";" (List.map f l) ) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat ";" List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sepConcat ";" List.map f l) ^ "]"


fix:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList float_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList float_of_int [1;2;3;4;5;6]


fix:
let rec clone x n = let i = 0 in
if i < n
then x :: ( clone x (n-1) )
else []

bad:
let rec clone x n = let i = 0 in
if i < n
then x :: (clone x n-1)
else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n = let i  ->  0 in
if i < n
then x :: (clone x n-1)
else []


fix:
let rec clone x n = let i = 0 in
if i < n
then x :: ( clone x (n-1) )
else []

bad:
let rec clone x n = let i = 0 in
if i < n
then (clone x n-1) :: x :: []
else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n = let i  ->  0 in
if i < n
then (clone x n-1) :: x :: []
else []


fix:
let padZero l1 l2 = if List.length l1 < List.length l2
then true
else false

bad:
let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in 
if length_diff < 0
then 
length_diff = (List.length l1 - List.length l2)
else 
length_diff

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let length_diff  ->  (List.length l1 - List.length l2) in 
if length_diff < 0
then 
length_diff = (List.length l1 - List.length l2)
else 
length_diff


fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = (fun x a -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [fun x -> x + 3] 3

annotated:
let _ = pipe [fun x -> x + 3] 3


fix:
let pipe fs = 
let f a x = (fun x a -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun x a) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun x a) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun x a -> x a) x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = (fun y -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun x a -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun a x -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun a x -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  (fun x -> x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function x a  in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function x a  in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  (fun x -> x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function x  in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function x  in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  (x (a) ) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let rec mulByDigit i l = 
match l with
| []   -> 0
| h::t -> h*i

bad:
let rec mulByDigit i l = 
match l with
| []   -> []
| h::t -> h*i

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
| []   -> []
| h::t -> h*i


fix:
let rec mulByDigit i l = 
match l with
| []   -> 0
| h::t -> h*i

bad:
let _ = mulByDigit 9 [9;9;9;9]

annotated:
let _ = mulByDigit 9 [9;9;9;9]


fix:
let rec mulByDigit i l = 
match (List.rev l) with
| []   -> []
| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []

bad:
let rec mulByDigit i l = 
match (List.rev l) with
| []   -> []
| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match (List.rev l) with
| []   -> []
| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> (h1 + h2, a)
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> (h1 + h2, a)
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> (a, h1 + h2)
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> (a, h1 + h2)
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> a
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> a
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> (list1, list2)
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> list1
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> list1
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> ([],[])
| (list1, list2) -> (list1, list2)
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> match (list1, list2) with
[] -> ([], [])
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> match (list1, list2) with
[] -> ([], [])
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> match x with
| ([],[]) -> a
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> match x with
| [] -> ([], [])
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
| (list1, list2) -> ([1], [1])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> match x with
| [] -> ([], [])
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
| (list1, list2) -> ([1], [1])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2:;lt2) -> (lh1::lt1, lh2:;lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2:;lt2) -> (lh1::lt1, lh2:;lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2:;lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2:;lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(v1,v2) -> match a with
(h1::t1, h2::t2) -> (v1 :: h1::t1, v2::h2::t2)
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(v1,v2) -> ( ( v1::a), (v2::a) )
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(v1,v2) -> ( ( v1::a), (v2::a) )
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x = match x with
(v1,v2) -> match a with
(list1, list2) -> match list1 with
| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )
| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in
let base = ([], []) in
let args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
(v1,v2) -> match a with
(list1, list2) -> match list1 with
| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )
| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in
let base = ([]. []) in
let args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match x with
(v1,v2) -> match a with
(list1, list2) -> match list1 with
| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )
| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in
let base = ([]. []) in
let args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigAdd [8;1] [8;1;0]

bad:
let _ = bigAdd [8;1] [8;1;0]

List.map (fun x -> x*10 ) [1;2;3]

annotated:
let _ = bigAdd [8;1] [8;1;0]

List.map (fun x -> x*10 ) [1;2;3]


fix:
let _ = bigAdd [0] [81000; 8100; 810; 81]

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> false
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with 
| [] -> []
| h1::t1 -> let rec helper acc v = [v] = [0]
(* if v = 0 
then 
acc 
else 
helper ( (v mod 10) :: acc) (v/10) *)
in helper [] h1

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| []   -> false
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with 
| [] -> []
| h1::t1 -> let rec helper acc v = [v] = [0]
(* if v = 0 
then 
acc 
else 
helper ( (v mod 10) :: acc) (v/10) *)
in helper [] h1


fix:
let rec mulByDigit i l = match (List.rev l) with
| []   -> 0
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []


fix:
let rec mulByDigit i l = match (List.rev l) with
| []   -> 0
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )


fix:
List.map (fun x -> x + 1) [1;2;3]

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )


fix:
let rec mulByDigit i l = match l with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10)
in helper [] h

bad:
let rec mulByDigit i l = match l with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper (v mod 10)::acc (v/10)
in helper [] h

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match l with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper (v mod 10)::acc (v/10)
in helper [] h


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> [h]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

bad:
let rec mulByDigit i l = match (List.rev l) with
[] -> int list []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> int list []
| h::t -> bigAdd h (adder t)
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
[] -> int list []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> int list []
| h::t -> bigAdd h (adder t)
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> [h]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

bad:
let rec mulByDigit i l = match (List.rev l) with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> bigAdd h (adder t)
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> bigAdd h (adder t)
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> [h]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> h
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> h
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
| [] -> []
| h::t -> ( bigAdd h (adder t) )
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
| [] -> []
| h::t -> [( bigAdd h (adder t) )]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
| [] -> []
| h::t -> [( bigAdd h (adder t) )]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )


fix:
let pipe fs = 
let f a x = (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f(x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f(x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun -> (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun -> (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
[] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (h::t)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
[] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (h::t)


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
[adder (x::y)]

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (h::t)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (h::t)


fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
[adder (x::y)]

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (x::y)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (x::y)


fix:
let rec mulByDigit i l = 
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10 :: []
in helper [] h

bad:
let rec mulByDigit i l = 
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10
in helper [] h

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10
in helper [] h


fix:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] h

bad:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with
| [] -> []
| h::t -> if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] h

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  -> 
match (List.rev l) with
| [] -> []
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with
| [] -> []
| h::t -> if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] h


fix:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> 
let f a x = a + x in
let base = 0 in
let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])

bad:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> 
let f a x = a + x in
let base = 0 in
let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10) :: acc (v/10)
in helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  -> 
match (List.rev l) with
| [] -> []
| h::t -> 
let f a x = a + x in
let base = 0 in
let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10) :: acc (v/10)
in helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])


fix:
let bigMul l1 l2 = 
let f a x = match x with
(k,v) -> ([k],v) in 
let base = ([], [0]) in
let args = let rec helper acc l1 l2 = 
match l1 with 
| [] -> acc
| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2
in helper [] (List.rev l1) l2
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
{k,v} -> ([k],v) in 
let base = ([], [0]) in
let args = let rec helper acc l1 l2 = 
match l1 with 
| [] -> acc
| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2
in helper [] (List.rev l1) l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match x with
{k,v} -> ([k],v) in 
let base = ([], [0]) in
let args = let rec helper acc l1 l2 = 
match l1 with 
| [] -> acc
| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2
in helper [] (List.rev l1) l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let somef i l = match (List.rev l) with
| [] -> []
| h::t ->
let rec helper acc v =  
if v = 0
then 
acc
else
helper (v mod 10 :: acc) (v/10)
in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))

bad:
let somef i l = match (List.rev l) with
| [] -> []
| h::t ->
let rec helper acc v =  
if v = 0
then 
acc
else
helper (v mod 10 :: acc) (v/10)
in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i)) *

annotated:
let somef i l = match (List.rev l) with
| [] -> []
| h::t ->
let rec helper acc v =  
if v = 0
then 
acc
else
helper (v mod 10 :: acc) (v/10)
in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i)) *


fix:
let somef i l = match (List.rev l) with
| [] -> []
| h::t ->
let rec helper acc v =  
if v = 0
then 
acc
else
helper (v mod 10 :: acc) (v/10)
in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))

bad:
)

somef 90000 [9;9]

annotated:
)

somef 90000 [9;9]


fix:
[1;0] @ (clone 0 1)

bad:
[1,0] @ clone 0 1

annotated:
[1,0] @ clone 0 1


fix:
[1;0] @ (clone 0 1)

bad:
[1,0] @ (clone 0 1)

annotated:
[1,0] @ (clone 0 1)


fix:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes))

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes))


fix:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = (1, []) in
let args = l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = (1, []) in
let args = l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold_left f base (List.rev l) in
res

bad:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res


fix:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold_left f base (List.rev l) in
res

bad:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res


fix:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold_left f base (List.rev l) in
res

bad:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res


fix:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold_left f base (List.rev l) in
res

bad:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res


fix:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x =
sumList (digitsOfInt (abs n))

bad:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x = function
sumList digitsOfInt (abs x)

annotated:
let digitalRoot : int -> int = fun  n  ->  (*failwith "TBD"*)

let rec loop x = function
sumList digitsOfInt (abs x)


fix:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x =
sumList (digitsOfInt (abs n))

bad:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x = function
sumList (digitsOfInt (abs x))

annotated:
let digitalRoot : int -> int = fun  n  ->  (*failwith "TBD"*)

let rec loop x = function
sumList (digitsOfInt (abs x))


fix:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x =
sumList (digitsOfInt (abs n))

bad:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x = match n with
sumList (digitsOfInt (abs x))

annotated:
let digitalRoot : int -> int = fun  n  ->  (*failwith "TBD"*)

let rec loop x = match n with
sumList (digitsOfInt (abs x))


fix:
let listReverse l = (*failwith "TBD"*)
let rec rev x l = match x with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

bad:
let listReverse l = (*failwith "TBD"*)
let rec rev x = match l with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  (*failwith "TBD"*)
let rec rev x = match l with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l


fix:
let listReverse l = (*failwith "TBD"*)
let rec rev x l = match x with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

bad:
let listReverse l = (*failwith "TBD"*)
let rec rev x = match x with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  (*failwith "TBD"*)
let rec rev x = match x with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l


fix:
let listReverse l = (*failwith "TBD"*)
let rec rev x = function
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

bad:
let listReverse l = (*failwith "TBD"*)
let rec rev x l = function
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  (*failwith "TBD"*)
let rec rev x l = function
| [] -> x
| h::t -> rev (h::x) t in
rev[] l


fix:
let digitalRoot n = (*failwith "TBD"*)
let x = n in
let rec loop x =
if x < 10 then x
else loop( sumList (digitsOfInt ( abs x ) ) )

bad:
let digitalRoot n = (*failwith "TBD"*)
let x = n in
let rec loop x =
if x < 10 then x
else loop( sumList (digitsOfInt ( abs x ) ) )

annotated:
let digitalRoot : int -> int = fun  n  ->  (*failwith "TBD"*)
let x = n in
let rec loop x =
if x < 10 then x
else loop( sumList (digitsOfInt ( abs x ) ) )


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)
if List.mem h seen then
seen
else 
h::seen
in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
helper (seen',rest')

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)

in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
if List.mem h seen then
helper (seen',rest')
else 
h::seen'
helper (seen', rest')

in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)

in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
if List.mem h seen then
helper (seen',rest')
else 
h::seen'
helper (seen', rest')

in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)
if List.mem h seen then
seen
else 
h::seen
in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
helper (seen',rest')

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(*let seen' = failwith "to be written" in*)

(*in list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
if List.mem h seen then
helper (seen',rest')
else 
h::seen'
helper (seen', rest')

in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(*let seen' = failwith "to be written" in*)

(*in list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
if List.mem h seen then
helper (seen',rest')
else 
h::seen'
helper (seen', rest')

in
List.rev (helper ([],l))


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
|[] -> d
|(ki,vi)::l -> if k = ki then vi
else assoc (d,k,l)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let c' = f b in
(*let b' = in*)
if c' = b 
then c'
else wwhile (f, c')

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let c' = f b in
let b' = b in
if c' = b 
then c'
else wwhile (c', b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let c' = f b in
let b' = b in
if c' = b 
then c'
else wwhile (c', b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper f b = 
(b', bool c') in
match c' with
| false -> b'
| true -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let helper f b = 
(b', bool c') in
match c' with
| false -> b'
| true -> wwhile (f, b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper f b = 
(b', bool c') in
match helper with
| (int, bool) -> if c' = false then b'
else wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let helper f b = 
(b', bool c') in
match helper with
| (int, bool) -> if c' = false then b'
else wwhile (f, b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper f b = 
(int b', bool c') in
match helper with
| false -> if c' = false then b'
| true -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let helper f b = 
(int b', bool c') in
match helper with
| false -> if c' = false then b'
| true -> wwhile (f, b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let b' f b = 
(b', bool c') in
match helper with
| false -> if c' = false then b'
| true -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let b' f b = 
(b', bool c') in
match helper with
| false -> if c' = false then b'
| true -> wwhile (f, b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let b' = f b in
let p = (b', bool c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let b' = f b in
let p = (b', bool c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let f b = (b', c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let f b = (b', c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let b' = int in
let c' = bool in
let f b = (b', c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith "to be written" *)
let b' = int in
let c' = bool in
let f b = (b', c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')


fix:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b =
let self = f b in
match self with
| b -> (self, true)
| _ -> (self, false)
in g
,b)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b =
let self = f b in
match  with
| b -> (self, true)
| _ -> (self, false)
in g
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith "to be written")*)
let g b =
let self = f b in
match  with
| b -> (self, true)
| _ -> (self, false)
in g
,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g =
let self = f b in
match self with
| b -> (self, true)
| _ -> (self, false)
in g
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith "to be written")*)
let g =
let self = f b in
match self with
| b -> (self, true)
| _ -> (self, false)
in g
,b)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

bad:
let _ = fixpoint (collatz, 1)

annotated:
let _ = fixpoint (collatz, 1)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

bad:
let _ = fixpoint (collatz, 48)

annotated:
let _ = fixpoint (collatz, 48)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| b -> if f = b
then (f, false)
else (f, true)
in g
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| b -> if f = b
then (f, false)
else (f, true)
in g
,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| f-> if f = b
then (f, false)
else (f, true)
in g
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| f-> if f = b
then (f, false)
else (f, true)
in g
,b)


fix:
let rec eval (e,x,y) = (*failwith "to be written"*)
match e with
VarX           -> x
| VarY           -> y
| Sine e         -> sin(pi*. eval (e,x,y))
| Cosine e       -> cos(pi*. eval (e,x,y))
| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)
(*Thresh = e1<e2?e3:e4*)
| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)
then eval (e3,x,y)
else eval (e4,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec eval (e,x,y) = (*failwith "to be written"*)
match e with
VarX           -> x
| VarY           -> y
| Sine e         -> sin(pi*. eval (e,x,y))
| Cosine e       -> cos(pi*. eval (e,x,y))
| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)
(*Thresh = e1<e2?e3:e4*)
| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)
then eval (e3,x,y)
else eval (e4,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
|[] -> d
|(ki,vi)::l -> if k = ki then vi
else assoc (d,k,l)

bad:
let rec build (rand, depth) = (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand 0 2 with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand 0 2 with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
|[] -> d
|(ki,vi)::l -> if k = ki then vi
else assoc (d,k,l)

bad:
let rec build (rand, depth) = (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand (0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand (0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt(n/10)::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| digitsOfInt(n/10)::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> [0]
| digitsOfInt(n/10)::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| 0 -> [0]
| digitsOfInt(n/10)::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt (n/10)::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| digitsOfInt (n/10)::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt n/10::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| digitsOfInt n/10::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt (n/10)::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| digitsOfInt (n/10)::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| _ -> digitsOfInt (n/10)::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| _ -> digitsOfInt (n/10)::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)::(n mod 10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@(n mod 10)


fix:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits n = match n with
| 0 -> []
| _ -> myAppend (getDigits (n/10)) (n mod 10)

bad:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits n = match n with
| 0 -> []
| _ -> myAppend (getDigits (n/10) (n mod 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n = 0 then [0]
else let rec getDigits n = match n with
| 0 -> []
| _ -> myAppend (getDigits (n/10) (n mod 10))


fix:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits n = 
if n > 0 then myAppend (getDigits (n/10)) (n mod 10)
else []

bad:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits m = match m with
| 0 -> []
| _ -> myAppend (getDigits (m/10)) (m mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n = 0 then [0]
else let rec getDigits m = match m with
| 0 -> []
| _ -> myAppend (getDigits (m/10)) (m mod 10)


fix:
let rec additivePersistence n = match n with
| 0 -> 1
| _ -> 1 + additivePersistence (sumList digits n)

bad:
let rec additivePersistence n = match n with
| 0 -> 1
| _ -> 1 + additivePersistence sumList digits n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  match n with
| 0 -> 1
| _ -> 1 + additivePersistence sumList digits n


fix:
let rec sumList xs = match xs with 
| [] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = listCompare (explode w) (listReverse (explode w))

annotated:
let palindrome : string -> bool = fun  w  ->  listCompare (explode w) (listReverse (explode w))


fix:
let rec wwhile (f,b) = 
let helper (b', c') = 
if c' then wwhile (f, b')
else b'
in f b

bad:
let rec wwhile (f,b) = 
let helper (b', c') = 
if c' then wwhile (f, b')
else b'
in f b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let helper (b', c') = 
if c' then wwhile (f, b')
else b'
in f b'


fix:
let rec wwhile (f,b) = match f b with
| (b', c') -> if c' then wwhile (f, b')
else b'

bad:
let rec wwhile (f,b) = 
let (b', c') = 
if c' then wwhile (f, b')
else b'
in f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let (b', c') = 
if c' then wwhile (f, b')
else b'
in f b


fix:
let rec wwhile (f,b) = match f b with
| (b', c') -> if c' then wwhile (f, b')
else b'

bad:
let rec wwhile (f,b) = 
if c' then wwhile (f, b')
else b'
in f b(b', c')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
if c' then wwhile (f, b')
else b'
in f b(b', c')


fix:
let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)

bad:
let fixpoint (f,b) = wwhile ((let f' = (f b, b != (f b))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f' = (f b, b ! ->  (f b))),b)


fix:
let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)

bad:
let fixpoint (f,b) = wwhile ((let fun f' = (f b, b != (f b))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let fun f' = (f b, b ! ->  (f b))),b)


fix:
et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e'(e', x, y))))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e'(e', x, y))))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))


fix:
et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e', x, y)))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e', x, y)))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))


fix:
et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e', x, y)))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e', x, y)))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (List.map f "; " l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (List.map f "; " l) ^ "]"


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (List.map f ("; " l)) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (List.map f ("; " l)) ^ "]"


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (List.map (f "; ") l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (List.map (f "; ") l) ^ "]"


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let rec mulByDigit i l = 
let (i', l') = (0, (List.rev l)) in
match l' with
| [] -> []
| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))
in
List.rev (mulByDigit i l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let (i', l') = (0, (List.rev l)) in
match l' with
| [] -> []
| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))
in
List.rev (mulByDigit i l)


fix:
let rec mulByDigit i l = bigAdd l (mulByDigit (i-1) l)

bad:
let rec mulByDigit i l = 
if i > 0 then mulByDigit ((i-1), (bigAdd l l))
else l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i > 0 then mulByDigit ((i-1), (bigAdd l l))
else l


fix:
let rec mulByDigit i l = match i with
| 0 -> l
| _ -> bigAdd l (mulByDigit (i-1) l)

bad:
let rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i-1) l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0 then bigAdd l (mulByDigit (i-1) l)


fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> (i, [0])
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> (i, [0])
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> (i, [0])
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let _ = additivePersistence 0

bad:
let _ additivePersistence 0

annotated:
let _ additivePersistence 0


fix:
let _ = additivePersistence 0

bad:
let _ additivePersistence 10

annotated:
let _ additivePersistence 10


fix:
let _ = listReverse [(1,2); (3,4)]

bad:
let _ = listReverse [(a,b); (c,d)];



(* explode : string -> char list 
* (explode s) is the list of characters in the string s in the order in 
*   which they appear
* e.g.  (explode "Hello") is ['H';'e';'l';'l';'o']
*)
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

annotated:
let _ = listReverse [(a,b); (c,d)];



(* explode : string -> char list 
* (explode s) is the list of characters in the string s in the order in 
*   which they appear
* e.g.  (explode "Hello") is ['H';'e';'l';'l';'o']
*)
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0


fix:
let _ = listReverse [(1,2); (3,4)]

bad:
let _ = listReverse [(a,b); (c,d)]

annotated:
let _ = listReverse [(a,b); (c,d)]


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
wwhile (f, 3)

annotated:
wwhile (f, 3)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let b' = f b in
if b' = b
then b
else fixpoint (f, b')

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let b' = f b in
if b' = b
then b
else fixpoint (f, b')


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let rec fixpoint (f,b) =
let b' = f b in
if b' = b
then b
else fixpoint (f, b')

annotated:
let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let b' = f b in
if b' = b
then b
else fixpoint (f, b')


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sin e'    -> "sin (pi*"^expr e'^")"
| Cos e'    -> "cos (pi*"^expr e'^")"
| Average e1, e2  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times e1, e2    -> (exprToString e1)^" * "^exprToString e2
| Thresh e1, e2, e3, e4    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX      -> "x"
| VarY      -> "y"
| Sin e'    -> "sin (pi*"^expr e'^")"
| Cos e'    -> "cos (pi*"^expr e'^")"
| Average e1, e2  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times e1, e2    -> (exprToString e1)^" * "^exprToString e2
| Thresh e1, e2, e3, e4    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^expr e'^")"
| Cosine e'    -> "cos (pi*"^expr e'^")"
| Average e1, e2  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times e1, e2    -> (exprToString e1)^" * "^exprToString e2
| Thresh e1, e2, e3, e4    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^expr e'^")"
| Cosine e'    -> "cos (pi*"^expr e'^")"
| Average e1, e2  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times e1, e2    -> (exprToString e1)^" * "^exprToString e2
| Thresh e1, e2, e3, e4    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^expr e'^")"
| Cosine e'    -> "cos (pi*"^expr e'^")"
| Average (e1, e2)  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^expr e'^")"
| Cosine e'    -> "cos (pi*"^expr e'^")"
| Average (e1, e2)  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^exprToString e'^")"
| Cosine e'    -> "cos (pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^exprToString e'^")"
| Cosine e'    -> "cos (pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^exprToString e'^")"
| Cosine e'    -> "cos (pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^exprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^exprToString e'^")"
| Cosine e'    -> "cos (pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^exprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"


fix:
let _ = buildX()

bad:
let _ = buildSine(0.5)

annotated:
let _ = buildSine(0.5)


fix:
let _ = buildX()

bad:
let _ = buildSine(Sine 0.5)

annotated:
let _ = buildSine(Sine 0.5)


fix:
let _ = buildX()

bad:
let _ = buildSine(Sine VarX)

annotated:
let _ = buildSine(Sine VarX)


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval x'+ eval y')/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval x'+ eval y')/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval x' y + eval x y')/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval x' y + eval x y')/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (x'+y')/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (x'+y')/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (x+y)/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (x+y)/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x+y)/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x+y)/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y)/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x +. y)/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x .+ y)/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x .+ y)/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y)/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x +. y)/2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y) ./ 2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x +. y) ./ 2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y) /. 2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x +. y) /. 2


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y) /. 2.0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Average (x', y') -> (x +. y) /. 2.0


fix:
let _ = eval (Sine(VarX, VarY), 0.5,0.5)

bad:
let rec eval (e,x,y) = match e with
| Sine e'		-> sin (pi *. eval(e'))
| Cosine e'		-> cos (pi *. eval(e'))
| Average (x', y')      -> (x +. y) /. 2.0
| Times (x', y')	-> x *. y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Sine e'		-> sin (pi *. eval(e'))
| Cosine e'		-> cos (pi *. eval(e'))
| Average (x', y')      -> (x +. y) /. 2.0
| Times (x', y')	-> x *. y


fix:
let _ = eval (Sine(VarX, VarY), 0.5,0.5)

bad:
let rec eval (e,x,y) = match e with
| Sine e'		-> sin (pi *. eval(e', x, y))
| Cosine e'		-> cos (pi *. eval(e', x, y))
| Average (x', y')      -> (x +. y) /. 2.0
| Times (x', y')	-> x *. y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Sine e'		-> sin (pi *. eval(e', x, y))
| Cosine e'		-> cos (pi *. eval(e', x, y))
| Average (x', y')      -> (x +. y) /. 2.0
| Times (x', y')	-> x *. y


fix:
let _ = eval (Sine(Average(VarX,VarY)), 1.0, 1.0)

bad:
let _ = eval (Sine(Average(VarX,VarY)), 0.5, 0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)), 0.5, 0.5)


fix:
let rec eval (e,x,y) = match e with
| Sine     e'		-> sin (pi *. eval(e', x, y))
| Cosine   e'		-> cos (pi *. eval(e', x, y))
| Average (x', y')      -> (x +. y) /. 2.0
| Times   (x', y')	-> x *. y

bad:
let _ = eval (Cosine(Average(VarX,VarY)), 0.0, 0.0)

annotated:
let _ = eval (Cosine(Average(VarX,VarY)), 0.0, 0.0)


fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)

bad:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0))

annotated:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0))


fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)

bad:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY)), 1.0, 2.0)

annotated:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY)), 1.0, 2.0)


fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)

bad:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarY)), 1.0, 2.0)

annotated:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarY)), 1.0, 2.0)


fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 0.5, 1.0)

bad:
)

annotated:
)


fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 0.5, 1.0)

bad:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)

annotated:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)


fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let _ = eval (Cosine(Average),0.5,0.2)

bad:
let _ = eval (Sine(VarX),0.5,0.0)

annotated:
let _ = eval (Sine(VarX),0.5,0.0)


fix:
let temp1 = FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))

bad:
let _ = exprToString FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))

annotated:
let _ = exprToString FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX         -> "x"
| VarY         -> "y"
| Sine e'      -> "sin(pi*"^exprToString e'^")"
| Cosine e'    -> "cos(pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^exprToString e1^"+"^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^"*"^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^"?"^
exprToString e3^":"^exprToString e4^")"
| SquareRoot e'		  -> "sqrt("^exprToString e'^")"
| FunckyRoot (e1,e2,e3)   -> 
"sqrt(sqrt("^exprToString e1^")+sqrt("^exprToString e2^")+sqrt("^exprToString e3^"))"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX         -> "x"
| VarY         -> "y"
| Sine e'      -> "sin(pi*"^exprToString e'^")"
| Cosine e'    -> "cos(pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^exprToString e1^"+"^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^"*"^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^"?"^
exprToString e3^":"^exprToString e4^")"
| SquareRoot e'		  -> "sqrt("^exprToString e'^")"
| FunckyRoot (e1,e2,e3)   -> 
"sqrt(sqrt("^exprToString e1^")+sqrt("^exprToString e2^")+sqrt("^exprToString e3^"))"


fix:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,8) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,8) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))


fix:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))
| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))
| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))
| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))


fix:
let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

bad:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareCosine(build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareCosine(build(rand, depth-1))


fix:
let sqsum xs = 
let f a x = a ** x in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match x with 
| []    -> a
| h::t  -> f (a + h**2) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = 
match x with 
| []    -> a
| h::t  -> f (a + h**2) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a ** x in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a ** x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a ** x in
let base = 0 in
List.fold_left f base xs


fix:
let _ = sqsum [(-1);(-2)]

bad:
let _ = sqsum [(-1);(-2)e]

annotated:
let _ = sqsum [(-1);(-2)e]


fix:
let pipe fs = 
let f a x = 
match x with 
| a   -> fun x -> x
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 
match x with 
| a   -> fun x -> x
| h::t -> h
in

let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = 
match x with 
| a   -> fun x -> x
| h::t -> h
in

let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = 
match x with 
| []   -> a
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 
match x with 
| []   -> b
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = 
match x with 
| []   -> b
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 
match x with 
| [] -> a 
| h::t -> t
in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = 
match x with 
| [] -> a 
| h::t -> t
in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input
for fun 'a' and take that output
as input for fun 'x' *)
let base = (fun b -> b) in (* a fun that takes 'b as input, and 
return 'b as output *)
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input
for fun 'a' and take that output
as input for fun 'x' *)
let base = (fun 'b -> b') in (* a fun that takes 'b as input, and 
return 'b as output *)
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input
for fun 'a' and take that output
as input for fun 'x' *)
let base = (fun 'b -> b') in (* a fun that takes 'b as input, and 
return 'b as output *)
List.fold_left f base fs


fix:
let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]

bad:
let _ = stringOfList (fun x -> x+1) [1;2;3;4]

annotated:
let _ = stringOfList (fun x -> x+1) [1;2;3;4]


fix:
let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]

bad:
let _ = stringOfList (fun x -> int_of_string x+1) [1;2;3;4]

annotated:
let _ = stringOfList (fun x -> int_of_string x+1) [1;2;3;4]


fix:
let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]

bad:
let _ = stringOfList (fun x -> string_of_int x+1) [1;2;3;4]

annotated:
let _ = stringOfList (fun x -> string_of_int x+1) [1;2;3;4]


fix:
let rec clone x n = 
let f a x = List.append a x in
let base = [] in
List.fold_right f x base

bad:
let rec clone x n = 
let f a x = List.append a x in
let base = [] in
List.fold_right f x b

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let f a x = List.append a x in
let base = [] in
List.fold_right f x b


fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append x acc) (n-1)
in
aux [] n

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append x acc) (n-1)
in
aux [] n

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append x acc) (n-1)
in
aux [] n

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append acc x) (n-1)
in
aux [] n

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append acc x) (n-1)
in
aux [] n

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append x acc ) (n-1)
in
aux [] n

bad:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append [x] acc ) (n-1)
in
aux [] n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let aux acc n = 
if n  <= 0
then acc
else clone (List.append [x] acc ) (n-1)
in
aux [] n


fix:
let rec clone x n = 
let rec aux acc n = 
if n  <= 0
then acc
else aux (List.append [x] acc ) (n-1)
in
aux [] n

bad:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append [x] acc ) (n-1)
in
aux [] n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let aux acc n = 
if n  <= 0
then acc
else clone (List.append [x] acc ) (n-1)
in
aux [] n


fix:
let rec clone x n = 
let rec aux acc n = 
if n  <= 0
then acc
else aux (List.append [x] acc ) (n-1)
in
aux [] n

bad:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else aux (List.append [x] acc ) (n-1)
in
aux [] n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let aux acc n = 
if n  <= 0
then acc
else aux (List.append [x] acc ) (n-1)
in
aux [] n


fix:
let _ = clone 2 (-1)

bad:
let _ = clone 2 -1

annotated:
let _ = clone 2 -1


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
if l1 < l2
then ((List.append (clone 0 (len2-len1)) l1), l2)
else (l1, (List.append (clone 0 (len1-len2)) l2))

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
if l1 < l2
then ((List.append (clone 0 (len2-len1)) l1), l2)
else (l1, (List.append (clone 0 (len1-len2) l2)))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
if l1 < l2
then ((List.append (clone 0 (len2-len1)) l1), l2)
else (l1, (List.append (clone 0 (len1-len2) l2)))


fix:
let _ = clone 4 (-12)

bad:
let _ = List.append((clone 0 3) [1;2;3])

annotated:
let _ = List.append((clone 0 3) [1;2;3])


fix:
let rec removeZero l = 
match l with
| []   -> []
| h::t ->
if h == 0
then removeZero t
else l

bad:
let bigMul l1 l2 = 
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s ((mulByDigit i l)*m) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s ((mulByDigit i l)*m) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then h else assoc(d,k,t)

bad:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then return h else assoc(d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then return h else assoc(d,k,t)


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then h else assoc(d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then h else assoc(d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)

bad:
let buildOp2()                     = Op2(e1,e2,e3)

annotated:
let build: ((int * int -> int) * int) -> expr = fun Op2()                      ->  Op2(e1,e2,e3)


fix:
let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)

bad:
let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)

annotated:
let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less,b_less)


fix:
let rec build (rand, depth) = (*failwith "to be implemented" *) if depth = -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

bad:
let rec build (rand, depth) = (*failwith "to be implemented" *)
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else
if (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else
buildCosine(buildOp2(buildY(),buildX(),buildY()))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith "to be implemented" *)
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else
if (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else
buildCosine(buildOp2(buildY(),buildX(),buildY()))


fix:
let rec build (rand, depth) = (*failwith "to be implemented" *) if depth > -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildX() else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

bad:
let rec build (rand, depth) = (*failwith "to be implemented" *) if depth = -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildX() else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = (*failwith "to be implemented" *) if depth  ->  -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildX() else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )


fix:
let rec build (rand, depth) = 
if depth = 0
then 
buildSine(buildX())
else
let randNum = rand(1,2) in
let randNum2 = rand(1,2) in
let randNum3 = rand(1,2) in
match (randNum, randNum2) with
| (1,1) -> buildSine(build(rand, depth -1))
| (2,2) -> buildCosine(build(rand, depth - 1))
| _     -> match randNum3 with
| 1 -> buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
| 2 -> buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

bad:
let rec build (rand, depth) = 
if depth = 0
then 
buildSine(buildX())
else
let randNum = rand(1,2) in
let randNum2 = rand(1,2) in
let randNum3 = rand(1,2) in
match (randNum, randNum2) with
| (1,1) -> buildSine(buildX())
| (2,2) -> buildCosine(buildX())
| _     -> match randNum3 with
| 1 -> buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
| 2 -> buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then 
buildSine(buildX())
else
let randNum = rand(1,2) in
let randNum2 = rand(1,2) in
let randNum3 = rand(1,2) in
match (randNum, randNum2) with
| (1,1) -> buildSine(buildX())
| (2,2) -> buildCosine(buildX())
| _     -> match randNum3 with
| 1 -> buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
| 2 -> buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )


fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h in
if (s = k) then x else assoc(d,k,t)

bad:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h
if s = k then x else assoc(d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with 
| [] -> d
| h::t -> let(s, x) = h
if s = k then x else assoc(d,k,t)


fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h in
if (s = k) then x else assoc(d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h in
if (s = k) then x else assoc(d,k,t)

bad:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h
if (s = k) then x else assoc(d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with 
| [] -> d
| h::t -> let(s, x) = h
if (s = k) then x else assoc(d,k,t)


fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h in
if (s = k) then x else assoc(d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let fixpoint (f,b) = 
let f x = let xx = f(x) in (xx, xx = x) in 
wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (((*failwith "to be written"*)fun x -> f(x), x = f(x)),b)

(* uncomment after implementing fixpoint *)
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((*failwith "to be written"*)fun x -> f(x), x  ->  f(x)),b)

(* uncomment after implementing fixpoint *)
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
let f x = let xx = f(x) in (xx, xx = x) in 
wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx = x)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx  ->  x)),b)


fix:
let fixpoint (f,b) = 
let f x = let xx = f(x) in (xx, xx = x) in 
wwhile (f,b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
let g x = let xx = f(x) in (xx, xx = x) in 
wwhile (g,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = f(x) in (xx, xx = x) in 
wwhile (g,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx = x)
wwhile (g,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx = x)
wwhile (g,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx = x) in
wwhile (g,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx = x) in
wwhile (g,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != x) in
wwhile (g,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx != x) in
wwhile (g,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine a -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine (a) -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> (((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)
(*failwith "to be written"*)


(* uncomment after implementing eval*)
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y 
| Sine (a) -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> (((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)
(*failwith "to be written"*)


(* uncomment after implementing eval*)
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine a -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine (a) -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y 
| Sine (a) -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine a -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in
if( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in
if( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in
if( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)
match x with
| 0 -> buildSine(build(rand, (depth - 1)))
| 1 -> buildCosine(build(rand, (depth -1)))
| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))
| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))
| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in
(*if( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)
match x with
| 0 -> buildSine(build(rand, (depth - 1)))
| 1 -> buildCosine(build(rand, (depth -1)))
| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))
| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))
| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))


fix:
let _ = sumList []

bad:
let _ = sumList 1

annotated:
let _ = sumList 1


fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs;
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))

annotated:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs;
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))


fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let _ = additivePersAndRoot [1, 1] 0

annotated:
let _ = additivePersAndRoot [1, 1] 0


fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs

annotated:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs


fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))

annotated:
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))


fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs;
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))

annotated:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs;
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))


fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot((digits theSum) (pers + 1))

annotated:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot((digits theSum) (pers + 1))


fix:
let rec listReverse l = 
match l with
[] -> []
| r::h ->
(listReverse h) @ [r]

bad:
let rec listReverse l = 
match l with
[] -> []
| r:h ->
(listReverse h) @ [r]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
[] -> []
| r:h ->
(listReverse h) @ [r]


fix:
let rec listReverse l = 
match l with
[] -> []
| r::h ->
(listReverse h) @ [r]

bad:
let rec listReverse l = 
match l with
[] -> []
| r:h ->
(listReverse h) @ [r]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
[] -> []
| r:h ->
(listReverse h) @ [r]


fix:
let rec lasts w =
let l::h = w in
match h with
[] -> l
| r::h ->
lasts h

bad:
let palindrome w = 
let ex = explode w in
ex[0] && ex[

annotated:
let palindrome : string -> bool = fun  w  ->  
let ex = explode w in
ex[0] && ex[


fix:
let rec lasts w =
let l::h = w in
match h with
[] -> l
| r::h ->
lasts h

bad:
end

annotated:
end


fix:
let rec lasts w =
let l::h = w in
match h with
[] -> l
| r::h ->
lasts h

bad:
]

annotated:
]


fix:
let rec lasts w =
let l::h = w in
match h with
[] -> l
| r::h ->
lasts h

bad:
let palindrome w = 
let ex = explode w in
ex[0] && ex[_end]

annotated:
let palindrome : string -> bool = fun  w  ->  
let ex = explode w in
ex[0] && ex[_end]


fix:
let palindrome w = 
let ex = explode w in
let revex = listReverse ex in
ex = revex

bad:
let palindrome w = 
let ex = explode w in
let revex = listReverese ex in
ex = revex

annotated:
let palindrome : string -> bool = fun  w  ->  
let ex = explode w in
let revex = listReverese ex in
ex = revex


fix:
let palindrome w = 
let ex = explode w in
let revex = listReverse ex in
ex = revex

bad:
let palindrome w = 
let ex = explode w in
let revex = listReverese ex in
ex = revex

annotated:
let palindrome : string -> bool = fun  w  ->  
let ex = explode w in
let revex = listReverese ex in
ex = revex


fix:
let rec digitsOfInt n =
if n <= 0 then []
else 
digitsOfInt (n / 10) @ (n mod 10)

bad:
let rec digitsOfInt n =
if n <= 0 then []
else 
let next_tail = digitsOfInt (n / 10) in
match next_tail with
x::xs -> 
xs @ [x :: (n mod 10)]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 then []
else 
let next_tail = digitsOfInt (n / 10) in
match next_tail with
x::xs -> 
xs @ [x :: (n mod 10)]


fix:
let rec digitsOfInt n =
if n <= 0 then []
else (digitsOfInt (n / 10)) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n <= 0 then []
else (digitsOfInt (n / 10)) :: (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 then []
else (digitsOfInt (n / 10)) :: (n mod 10)


fix:
let _ = additivePersistence (-9876)

bad:
let _ = additivePersistence -9860

annotated:
let _ = additivePersistence -9860


fix:
let _ = additivePersistence (abs (-9876))

bad:
let _ = additivePersistence abs (-9876)

annotated:
let _ = additivePersistence abs (-9876)


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match l with
| (ki, vi)::tl  -> 
if ki = k then
vi
else
assoc (d,k,tl)
| _		-> d

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| (ki, vi)::tl  -> 
if ki = k then
vi
else
assoc (d,k,tl)
| _		-> d


fix:
let _ = assoc (-1,123, [(123, 1)])

bad:
let _ = assoc (-1,"d", [("d", 1)])

annotated:
let _ = assoc (-1,"d", [("d", 1)])


fix:
let _ = assoc ([], 123, [(123, "sad"); (321, "happy")])

bad:
let _ = assoc ("null",123, [(123, "sad"; (321, "happy")])

annotated:
let _ = assoc ("null",123, [(123, "sad"; (321, "happy")])


fix:
let _ = assoc ([], 123, [(123, "sad"); (321, "happy")])

bad:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])

annotated:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])


fix:
let _ = assoc ('c', 123, [(123, "sad"); (321, "happy")])

bad:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])

annotated:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])


fix:
let long_list = 
let rec assemble n l = 
if n < 10000000 then
assemble (n+1) ((string_of_int(n), n) :: l)
else
l
in
assemble 1 []

bad:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])

annotated:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((f),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f),b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((f (=)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f ( -> )),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g h x = let xx = h x in (xx, x ! ->  xx) in g f),b)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)


fix:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))


fix:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))


fix:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))


fix:
set _ = build(rand, 5)

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()


fix:
set _ = build(rand, 5)

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> buildX()


fix:
let _ = build(makeRand, 5)

bad:
let _ = build(rand, 5)

annotated:
let _ = build(rand, 5)


fix:
let _ = build(makeRand, 5)

bad:
let _ = build(makeRand, 5)

annotated:
let _ = build(makeRand, 5)


fix:
let pi = 4.0 *. atan 1.0

bad:
let buildAcossin(e1,e2)		   = Acossin(e1,e2)

annotated:
let build: ((int * int -> int) * int) -> expr = fun Acossin(e1,e2)		    ->  Acossin(e1,e2)


fix:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> 
if (eval(e1, x, y) < eval(e2, x, y)) then 
eval(e3, x, y) 
else 
eval(e4, x, y)
| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> 
if (eval(e1, x, y) < eval(e2, x, y)) then 
eval(e3, x, y) 
else 
eval(e4, x, y)
| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)


fix:
let pipe fs = 
let f a x = (+) (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (+) (x a) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (+) (x a) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (+) (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (+) (a x) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (+) (a x) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base =  0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (fun a -> a) in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = (fun a -> a) in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun a -> a) in
let base =  0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun a -> a) in
let base =  0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun r s -> a) in
let base =  (fun r s -> 0) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun r s -> a) in
let base =  (fun r s -> 0) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> []) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  (fun) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> []) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun n -> ) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  (fun n -> ) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun n -> n) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> ) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  (fun x -> ) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun n -> n) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  (fun -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun n -> n) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  (fun y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun n -> n) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base =  (fun n -> n) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base =  (fun n -> n) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> x a) in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun y -> x a) in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> x a) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun y -> x a) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun _ -> _) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun _ -> x a) in
let base = (fun _ -> _) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun _ -> x a) in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun _ -> x a) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> x) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun _ -> a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> x y) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let rec = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let rec = x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let myfun _ = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let myfun _ = x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let myfun = (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let myfun = (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let myfun x a = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let myfun x a = x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let myfun x a -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let myfun x a -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (let myfun = x a in myfun) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let rec myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (let rec myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> x) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> (y a)) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun y -> (y a)) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> x) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun y -> a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> x -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun y -> x -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun _ -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ x -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun _ x -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> 0) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> 0) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (fun) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = (fun) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> 0) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> base) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = (fun _ -> base) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y ) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y -> 0) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = (fun y -> y -> 0) in
List.fold_left f base fs


fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x (a a)) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x (a a)) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x (a x)) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x (a x)) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x (a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x (a)) in
let base = (fn y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x (a)) in
let base = (fn y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = (f) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = (fun _ -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (f) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (f a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = (f a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)]

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)]


fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (fun z -> a z) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun z -> z a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun z -> z a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = [fun x -> x ^ sep] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = (^) sep in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = (^) sep in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = [fun x -> x ^ sep] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = fun x -> x ^ sep in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = fun x -> x ^ sep in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = "" in
let l = [fun x -> x ^ sep] in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = "" in
let l = [fun x -> x ^ sep] in
List.fold_left f base l


fix:
let stringOfList f l = 
match l with
| []    -> "[]"
| x::xs ->
let g a x = a ^ "; " ^ (f x) in
let base = f x in
List.fold_left g base xs

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = 
match l with
| []    -> "[]"
| x::xs ->
let g a x = a ^ "; " ^ (f x) in
let base = f x in
List.fold_left g base xs

bad:
let stringOfList f l = 
match l with
| []    -> "[]"
| x::xs ->
let g a x = a ^ "; " ^ (f x) in
let base = f x in
List.fold_left f base xs

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
match l with
| []    -> "[]"
| x::xs ->
let g a x = a ^ "; " ^ (f x) in
let base = f x in
List.fold_left f base xs


fix:
let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then 
acc
else 
clone_RT (x::acc) (n-1)
in
clone_RT [] n

bad:
let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then acc
else clone (x::acc) (n-1)
in
clone_RT [] n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
if n <= 0 then acc
else clone (x::acc) (n-1)
in
clone_RT [] n


fix:
let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then 
acc
else 
clone_RT (x::acc) (n-1)
in
clone_RT [] n

bad:
let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then 
acc
else 
clone (x::acc) (n-1)
in
clone_RT [] n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
if n <= 0 then 
acc
else 
clone (x::acc) (n-1)
in
clone_RT [] n


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(List.append (clone 0 diff) l2, l1)

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
List.append (List.append ((clone 0 (-diff)), len1), len2)
else
List.append (List.append (clone 0 (diff), len2), len1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
List.append (List.append ((clone 0 (-diff)), len1), len2)
else
List.append (List.append (clone 0 (diff), len2), len1)


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(List.append (clone 0 diff) l2, l1)

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
List.append (List.append ((clone 0 (-diff)), len1), len2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
List.append (List.append ((clone 0 (-diff)), len1), len2)


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(List.append (clone 0 diff) l2, l1)

bad:
)
else
List.append (List.append (clone 0 (diff), len2), len1)

annotated:
)
else
List.append (List.append (clone 0 (diff), len2), len1)


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(List.append (clone 0 diff) l2, l1)

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff), len1), len2)
else
(List.append (clone 0 (diff), len2), len1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff), len1), len2)
else
(List.append (clone 0 (diff), len2), len1)


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(List.append (clone 0 diff) l2, l1)

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) len1, len2)
else
(List.append (clone 0 diff) len2, len1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) len1, len2)
else
(List.append (clone 0 diff) len2, len1)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 0 in
let base = 0 in
let args = (l1, l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 0 in
let base = 0 in
let args = (l1, l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (1,2) in
let base = 0 in
let args = (l1, l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (1,2) in
let base = 0 in
let args = (l1, l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = (l1, 2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = (l1, 2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = (0, 0) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = (0, 0) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = (0, []) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = (0, []) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (0, clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (0, clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = h + x in
(t, sum::y)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = h + x in
(t, sum::y)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = h + x in
(t, sum::y)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = h + x in
(t, sum::y)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum =  in
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum =  in
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = 
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = 
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = 
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = 
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev l1, 0), []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev l1, carry), []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev l1, carry), []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((0::(List.rev l1), 0), []) in
let args = 0::(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = (0::(List.rev l1, 0), []) in
let args = 0::(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = (0::(List.rev l1, 0), []) in
let args = 0::(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((0::(List.rev l1), 0), []) in
let args = 0::(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = (0::(List.rev l1), 0), []

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = (0::(List.rev l1), 0), []


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev (0::l1), 0), []) in
let args = List.rev (0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev 0::l1, 0), []) in
let args = List.rev 0::l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev 0::l1, 0), []) in
let args = List.rev 0::l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [-1] [-2; -3]

bad:
let _ = bigAdd [-1] [-2, -3]

annotated:
let _ = bigAdd [-1] [-2, -3]


fix:
let rec mulByDigit i l = 
let rec mulByDigit_RT i acc =
if i = 1 then acc
else mulByDigit_RT (i-1) (bigAdd acc l)
in
mulByDigit_RT i []

bad:
let rec mulByDigit i l = 
let mulByDigit_RT i acc =
if i = 1 then acc
else mulByDigit_RT (i-1) (bigAdd acc l)
in
mulByDigit_RT i []

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let mulByDigit : int -> int list -> int list  = fun  i l  -> 
if i = 1 then acc
else mulByDigit_RT (i-1) (bigAdd acc l)
in
mulByDigit_RT i []


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (i, acc) -> 
let digmul = mulByDigit (i * x) l2 in
(i * 10, bigAdd digmul acc)
| _ -> failwith "wtf" in
let base = (1, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (i, acc) -> ([], acc) 
| _ -> failwith "wtf" in
let base = (0, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (i, acc) -> ([], acc) 
| _ -> failwith "wtf" in
let base = (0, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]


(sepConcat "; ")

annotated:
let _ = sepConcat "X" ["hello"]


(sepConcat "; ")


fix:
let stringOfList f l = 
"[" ^ (stringOfList f (List.map f l)) ^ "]"

bad:
let stringOfList f l = 
"[" ^ List map f (List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ List map f (List.map f l) ^ "]"


fix:
let stringOfList f l = 
"[" ^ (stringOfList f (List.map f l)) ^ "]"

bad:
let stringOfList f l = 
"[" ^ stringOfList (List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ stringOfList (List.map f l) ^ "]"


fix:
let _ = sepConcat ", " ["foo";"bar";"baz"]

bad:
sepConcat "; " [[1;0];[2];[3]]

annotated:
sepConcat "; " [[1;0];[2];[3]]


fix:
let _ = sepConcat ", " ["foo";"bar";"baz"]

bad:
List.map string_of_int [[1;0];[2];[3]]

annotated:
List.map string_of_int [[1;0];[2];[3]]


fix:
let _ = sepConcat ", " ["foo";"bar";"baz"]

bad:
sepConcat "; " [[1;0];[2];[3]]

annotated:
sepConcat "; " [[1;0];[2];[3]]


fix:
let stringOfList f l = (List.map f l);

bad:
let stringOfList f l = "[" ^ (List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (List.map f l) ^ "]"


fix:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []

bad:
let _ = bigMul [1] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]

annotated:
let _ = bigMul [1] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]


fix:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []

bad:
let _ = bigMul [10] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]

annotated:
let _ = bigMul [10] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]


fix:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []

bad:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [10]

annotated:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [10]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = mulByDigit 9 [9;9;9;9]

annotated:
let _ = mulByDigit 9 [9;9;9;9]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = 
let (i, acc) = a in
let digmul = mulByDigit (i * x) l2 in
(i * 10, bigAdd digmul acc) in
let base = (1, []) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (i, acc) = a in
let digmul = mulByDigit (i * x) l2 in
(i * 10, bigAdd digmul acc) in
let base = (1, []) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [1;2] [3;4]

annotated:
let _ = bigMul [1;2] [3;4]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [1;2;3] [9;9]

annotated:
let _ = bigMul [1;2;3] [9;9]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]

annotated:
let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [] [0]

annotated:
let _ = bigMul [] [0]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [0] []

annotated:
let _ = bigMul [0] []


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [] []

annotated:
let _ = bigMul [] []


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [1;2;3] [0]

annotated:
let _ = bigMul [1;2;3] [0]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [0] [2;3;4]

annotated:
let _ = bigMul [0] [2;3;4]


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [1;9;4;5;2;3] []

annotated:
let _ = bigMul [1;9;4;5;2;3] []


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6] []

annotated:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6] []


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else n mod 10 :: digitsOfInt (n / 10)

bad:
let rec digitsOfInt n myList = 
if (n <= 0)
then myList
else digitsOfInt (n/10)  (n mod 10 ::myList)
match n with 
| 0 -> [0]
| _ -> digitsOfInt n []

annotated:
let rec digitsOfInt : int -> int list = fun  n myList  ->  
if (n <= 0)
then myList
else digitsOfInt (n/10)  (n mod 10 ::myList)
match n with 
| 0 -> [0]
| _ -> digitsOfInt n []


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else n mod 10 :: digitsOfInt (n / 10)

bad:
let rec digitsOfInt n myList = match n with
| n <= 0 -> []
| _      -> n mod 10 :: digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n myList  ->  match n with
| n <= 0 -> []
| _      -> n mod 10 :: digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else n mod 10 :: digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = match n with
| n <= 0 -> []
| _      -> n mod 10 :: digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| n <= 0 -> []
| _      -> n mod 10 :: digitsOfInt (n / 10)


fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList n in
num + additivePersistence num

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList n in
num + additivePersistence num


fix:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1 
num + additivePersistence num

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1 
num + additivePersistence num


fix:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1


fix:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1


fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = 0 in
counter = counter + 1
num + additivePersistence num

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = 0 in
counter = counter + 1
num + additivePersistence num


fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then 
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then 
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num


fix:
let rec additivePersistence n = 
if (n < 10) 
then []
else 
let myList = digits n in
(*let num = sumList myList in*)
myList

bad:
let rec additivePersistence n = 
if (n < 10) 
then []
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then []
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num


fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
1 + additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
1 + additivePersistence sumList (digits n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n < 10) 
then 0
else 
1 + additivePersistence sumList (digits n)


fix:
let rec digitalRoot n = 
if (n < 10)
then n
else
additivePersistence ( sumList (digits n))

bad:
let rec digitalRoot n = 
if (n < 10)
then digRoot = n
else
additivePersistence ( sumList (digits n))

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if (n < 10)
then digRoot = n
else
additivePersistence ( sumList (digits n))


fix:
let rec digitalRoot n = 
if (n < 10)
then n
else
additivePersistence ( sumList (digits n))

bad:
let rec digitalRoot n = 
if (n < 10)
then root = n
else
additivePersistence ( sumList (digits n))

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if (n < 10)
then root = n
else
additivePersistence ( sumList (digits n))


fix:
let rec digitalRoot n = 
if (n < 10)
then n
else
additivePersistence ( sumList (digits n))

bad:
let rec digitalRoot n = 
if (n < 10)
then root = n
else
additivePersistence ( sumList (digits n))

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if (n < 10)
then root = n
else
additivePersistence ( sumList (digits n))


fix:
let rec listReverse l = match l with 
| [] -> []
| h::t -> []

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t ->

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::t ->


fix:
let rec listReverse l = match l with 
| [] -> []
| h::t -> []

bad:
let _ = "a" :: "b" :: "c"

annotated:
let _ = "a" :: "b" :: "c"


fix:
let rec listReverse l = match l with 
| [] -> []
| h::t -> []

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::t -> 0


fix:
let rec listReverse l = match l with 
| [] -> []
| h::t -> []

bad:
let _ = "a" :: "b" :: "c"

annotated:
let _ = "a" :: "b" :: "c"


fix:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append t [h] )

bad:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse ( append ( t [h] ) )

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse ( append ( t [h] ) )


fix:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append t [h] )

bad:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse append ( t [h] )

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse append ( t [h] )


fix:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append t [h] )

bad:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append ( t [h] ))

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append ( t [h] ))


fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> listReverse (append t [h])

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t -> append ( t [h])

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::t -> append ( t [h])


fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> listReverse (append t [h])

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t -> append t [h]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::t -> append t [h]


fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> listReverse (append t [h])

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> listReverse (append t [h])

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t -> listReverse (append t [h])

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
| [] -> []
| h::t -> listReverse (append t [h])


fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> listReverse (append t [h])

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> append t [h]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([(n mod 10)] append digitsOfInt (n/10) )

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]

annotated:
let _ = listReverse ["a"; "b"; "c"; "d"]


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([(n mod 10)] append digitsOfInt (n/10) )

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([n mod 10] append digitsOfInt (n/10) )

annotated:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([n mod 10] append digitsOfInt (n/10) )


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([(n mod 10)] append digitsOfInt (n/10) )

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse (append [n mod 10] (digitsOfInt (n/10)) )

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse (append [n mod 10] digitsOfInt (n/10) )

annotated:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse (append [n mod 10] digitsOfInt (n/10) )


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse (append [n mod 10] (digitsOfInt (n/10)) )

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let _ = palindrome "a"

bad:
let palindrome w = match w with 
| "" -> true
| _ -> 
let myString = explode w in
let reverseString = listReverse myString in
if myString = reverseString
then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  match w with 
| "" -> true
| _ -> 
let myString = explode w in
let reverseString = listReverse myString in
if myString = reverseString
then true
else false


fix:
let _ = palindrome "a"

bad:
let _ = palindrome "malayalam"

annotated:
let _ = palindrome "malayalam"


fix:
let _ = palindrome "a"

bad:
let _ = palindrome "myxomatosis"

annotated:
let _ = palindrome "myxomatosis"


fix:
let _ = palindrome "a"

bad:
let _ = palindrome ""

annotated:
let _ = palindrome ""


fix:
let _ = palindrome "a"

bad:
let _ = palindrome "a"

annotated:
let _ = palindrome "a"


fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> let b = (f x) in (b, b ! ->  x),b)


fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(expr s)^"+"^(expr t)^")/2)" )
| Times(s, t) -> ((expr s)^"*"^(expr t))
| Thresh(s, t, u, v) -> ("("^(expr s)^"<"^(expr t)^"?"^(expr u)^":"^(expr v)^")")

bad:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(ex s)^"+"^(ex t)^")/2)" )
| Times(s, t) -> ((ex s)^"*"^(ex t))
| Thresh(s, t, u, v) -> ("("^(ex s)^"<"^(ex t)^"?"^(ex u)^":"^(ex v)^")")

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(ex s)^"+"^(ex t)^")/2)" )
| Times(s, t) -> ((ex s)^"*"^(ex t))
| Thresh(s, t, u, v) -> ("("^(ex s)^"<"^(ex t)^"?"^(ex u)^":"^(ex v)^")")


fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(expr s)^"+"^(expr t)^")/2)" )
| Times(s, t) -> ((expr s)^"*"^(expr t))
| Thresh(s, t, u, v) -> ("("^(expr s)^"<"^(expr t)^"?"^(expr u)^":"^(expr v)^")")

bad:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(expr s)^"+"^(expr t)^")/2)" )
| Times(s, t) -> ((ex s)^"*"^(expr t))
| Thresh(s, t, u, v) -> ("("^(expr s)^"<"^(expr t)^"?"^(expr u)^":"^(expr v)^")")

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(expr s)^"+"^(expr t)^")/2)" )
| Times(s, t) -> ((ex s)^"*"^(expr t))
| Thresh(s, t, u, v) -> ("("^(expr s)^"<"^(expr t)^"?"^(expr u)^":"^(expr v)^")")


fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"
| Sine a	      -> ("sin(pi*"^(expr a)^")")
| Cosine a	      -> ("cos(pi*"^(expr a)^")")
| Average (a, b)      -> ("(("^(expr a)^"+"^(expr b)^")/2)" )
| Times (a, b)	      -> ((expr a)^"*"^(expr b))
| Thresh (a, b, c, d) -> ("("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")")

bad:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"
| Sine a	      -> ("sin(pi*"^(expr a)^")")
| Cosine a	      -> ("cos(pi*"^(expr a)^")")
| Average a, b        -> ("(("^(expr a)^"+"^(expr b)^")/2)" )
| Times a, b	      -> ((expr a)^"*"^(expr b))
| Thresh a, b, c, d   -> ("("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")")

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"
| Sine a	      -> ("sin(pi*"^(expr a)^")")
| Cosine a	      -> ("cos(pi*"^(expr a)^")")
| Average a, b        -> ("(("^(expr a)^"+"^(expr b)^")/2)" )
| Times a, b	      -> ((expr a)^"*"^(expr b))
| Thresh a, b, c, d   -> ("("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")")


fix:
let rec wwhile (f,b) = 
match (f, b) with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

bad:
let rec wwhile (f,b) = 
let check = (f, b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let check = (f, b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')


fix:
let rec wwhile (f,b) = 
match (f, b) with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

bad:
let rec wwhile (f,b) = 
let check = (f b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let check = (f b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')


fix:
let rec wwhile (f,b) = 
match (f, b) with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

bad:
let rec wwhile (f,b) = 
let check = (f b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let check = (f b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')


fix:
let rec wwhile (f,b) = 
match (f, b) with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec wwhile (f,b) = 
let check = (f b) in
match check with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)

bad:
let rec wwhile (f,b) = 
let check = (f b) in
match (f, b) with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let check = (f b) in
match (f, b) with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)


fix:
let fixpoint (f,b) = wwhile ((fun x ->
let b = (f x) in
(b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (fun x 
let b = (f x) in
(b, b != x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun x 
let b = (f x) in
(b, b != x),b)


fix:
let fixpoint (f,b) = wwhile ((fun x ->
let b = (f x) in
(b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (fun x ->
let b = (f x) in
(b, b != x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun x ->
let b = (f x) in
(b, b != x),b)


fix:
let fixpoint (f,b) = wwhile ((fun x ->
let b = (f x) in
(b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (fun x ->
let b = (f x) in
(b, b != x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun x ->
let b = (f x) in
(b, b != x),b)


fix:
let _ = fixpoint (collatz, 48)

bad:
 _ = fixpoint (collatz, 3)

annotated:
 _ = fixpoint (collatz, 3)


fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"  
| Sine a	      -> "sin(pi*"^(expr a)^")"
| Cosine a	      -> "cos(pi*"^(expr a)^")"
| Average (a, b)      -> "(("^(expr a)^"+"^(expr b)^")/2)"
| Times (a, b)	      -> (expr a)^"*"^(expr b)
| Thresh (a, b, c, d) -> 
"("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")"

bad:
let rec exprToString e = 
(*let expr = exprToString in*)
match e with
| VarX		      -> "x"
| VarY		      -> "y"  
| Sine a	      -> "sin(pi*"^(expr a)^")"
| Cosine a	      -> "cos(pi*"^(expr a)^")"
| Average (a, b)      -> "(("^(expr a)^"+"^(expr b)^")/2)"
| Times (a, b)	      -> (expr a)^"*"^(expr b)
| Thresh (a, b, c, d) -> 
"("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
(*let expr = exprToString in*)
match e with
| VarX		      -> "x"
| VarY		      -> "y"  
| Sine a	      -> "sin(pi*"^(expr a)^")"
| Cosine a	      -> "cos(pi*"^(expr a)^")"
| Average (a, b)      -> "(("^(expr a)^"+"^(expr b)^")/2)"
| Times (a, b)	      -> (expr a)^"*"^(expr b)
| Thresh (a, b, c, d) -> 
"("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")"


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
 _ = fixpoint (collatz, 9001)

annotated:
 _ = fixpoint (collatz, 9001)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
 _ = fixpoint (collatz, 9001)

annotated:
 _ = fixpoint (collatz, 9001)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
 g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
 g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec assoc (d,k,l) = 
if l = [] then d else
match l with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = 
match dkl with (d, k, l) ->
if l = [] then d else
matchl

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match dkl with (d, k, l) ->
if l = [] then d else
matchl


fix:
let rec assoc (d,k,l) = 
if l = [] then d else
match l with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

bad:
with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

annotated:
with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)


fix:
let rec assoc (d,k,l) = 
if l = [] then d else
match l with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = 
if l = [] then d else
matchl

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
if l = [] then d else
matchl


fix:
let rec assoc (d,k,l) = 
if l = [] then d else
match l with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

bad:
with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

annotated:
with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)


fix:
let rec assoc (d,k,l) =
match (d, k, l) with
| (d, k, l) ->
if l = [] 
then d
else
match l with h::t ->
match h with (a, b) ->
if a = k 
then b
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) =
match (d, k, l) with
| [] -> 0
| (d, k, l) ->
if l = [] 
then d
else
match l with h::t ->
match h with (a, b) ->
if a = k 
then b
else assoc (d, k, t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> 
match (d, k, l) with
| [] -> 0
| (d, k, l) ->
if l = [] 
then d
else
match l with h::t ->
match h with (a, b) ->
if a = k 
then b
else assoc (d, k, t)


fix:
let rec wwhile (f,b) = 
let check = (f b) in
match check with
| (x', y) -> 
if y = false
then x'
else wwhile (f, x')

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec build (rand, depth) = if depth > 0 then 

let r = (rand (0, 5)) in 
let d = (depth - 1) in 

match r with
| 0 -> buildSine((build (rand, d)))
| 1 -> buildCosine((build (rand, d)))
| 2 -> buildAverage((build (rand, d)), (build (rand, d)))
| 3 -> buildTimes((build (rand, d)), (build (rand, d)))
| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))

else 

let r = (rand (0, 2)) in 

match r with
| 0 -> buildX()
| 1 -> buildY()

bad:
let g1 () = build (2, 2)

annotated:
let g1 () = build (2, 2)


fix:
let rec build (rand, depth) = if depth > 0 then 

let r = (rand (0, 5)) in 
let d = (depth - 1) in 

match r with
| 0 -> buildSine((build (rand, d)))
| 1 -> buildCosine((build (rand, d)))
| 2 -> buildAverage((build (rand, d)), (build (rand, d)))
| 3 -> buildTimes((build (rand, d)), (build (rand, d)))
| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))

else 

let r = (rand (0, 2)) in 

match r with
| 0 -> buildX()
| 1 -> buildY()

bad:
let g2 () = build (2, 5)

annotated:
let g2 () = build (2, 5)


fix:
let rec build (rand, depth) = if depth > 0 then 

let r = (rand (0, 5)) in 
let d = (depth - 1) in 

match r with
| 0 -> buildSine((build (rand, d)))
| 1 -> buildCosine((build (rand, d)))
| 2 -> buildAverage((build (rand, d)), (build (rand, d)))
| 3 -> buildTimes((build (rand, d)), (build (rand, d)))
| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))

else 

let r = (rand (0, 2)) in 

match r with
| 0 -> buildX()
| 1 -> buildY()

bad:
let g1 () = build (rand(0, 5), 2)

annotated:
let g1 () = build (rand(0, 5), 2)


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))
| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))
| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))
| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))


fix:
let rec build (rand, depth) = 
if depth < 0 
then 
let r = (rand (0, 2)) in 
match r with
| 0 -> buildX()
| 1 -> buildY()
| _ -> failwith "Make the non-exhaustve pattern match warning shut up"
else 
let d = depth - 1 in 
match rand(0, 7) with
| 0 -> buildSine(build (rand, d))
| 1 -> buildCosine(build (rand, d))
| 2 -> buildAverage(build (rand, d), build (rand, d))
| 3 -> buildTimes(build (rand, d), build (rand, d))
| 4 -> buildThresh(build (rand, d),
build (rand, d),
build (rand, d),
build (rand, d))
| 5 -> buildPoly(build (rand, d),
build (rand, d),
build (rand, d))
| 6 -> buildTan( build (rand, d))
| _ -> failwith "Make the non-exhaustve pattern match warning shut up "

bad:
let rec build (rand, depth) = 
if depth < 0 
then 
let r = (rand (0, 2)) in 
match r with
| 0 -> buildX()
| 1 -> buildY()
| _ -> failwith "Make the non-exhaustve pattern match warning shut up"
else 
let d = depth - 1 in 
match rand(0, 7) with
| 0 -> buildSine(build (rand, d))
| 1 -> buildCosine(build (rand, d))
| 2 -> buildAverage(build (rand, d), build (rand, d))
| 3 -> buildTimes(build (rand, d), build (rand, d))
| 4 -> buildThresh(build (rand, d),
build (rand, d),
build (rand, d),
build (rand, d))
| 5 -> buildPoly(build (rand, d),
build (rand, d),
build (rand, d))
| 6 -> buildTan( build (rand, d))
| _ -> failwith "Make the non-exhaustve pattern match warning shut up "

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth < 0 
then 
let r = (rand (0, 2)) in 
match r with
| 0 -> buildX()
| 1 -> buildY()
| _ -> failwith "Make the non-exhaustve pattern match warning shut up"
else 
let d = depth - 1 in 
match rand(0, 7) with
| 0 -> buildSine(build (rand, d))
| 1 -> buildCosine(build (rand, d))
| 2 -> buildAverage(build (rand, d), build (rand, d))
| 3 -> buildTimes(build (rand, d), build (rand, d))
| 4 -> buildThresh(build (rand, d),
build (rand, d),
build (rand, d),
build (rand, d))
| 5 -> buildPoly(build (rand, d),
build (rand, d),
build (rand, d))
| 6 -> buildTan( build (rand, d))
| _ -> failwith "Make the non-exhaustve pattern match warning shut up "


fix:
let pipe fs = 
let f a x = fun b -> x(a b) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun b -> x(a y) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun b -> x(a y) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun b -> x(a b) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun b -> x(a b) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun b -> x(a b) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sep "; " (List.map f l)) & "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sep "; " (List.map f l)) & "]"


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) & "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sepConcat "; " (List.map f l)) & "]"


fix:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (l1, l2)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

bad:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (a - b) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (a - b) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)


fix:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (l1, l2)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

bad:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then ((clone 0 (a - b) @ l1), l2)
else (l1, clone 0 (a - b) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then ((clone 0 (a - b) @ l1), l2)
else (l1, clone 0 (a - b) @ l2)


fix:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (l1, l2)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

bad:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)


fix:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (l1, l2)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

bad:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let c = fst x + snd x in
match a with
| h::t -> (h+c)/10::(h+c mod 10) :: t
| _ -> (c/10)::[c mod 10] in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let c = fst x + snd x in
match a with
| h::t -> (h+c)/10::(h+c mod 10) :: t
| _ -> (c/10)::[c mod 10] in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry : res mod 10 : [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry : res mod 10 : [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 : [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 : [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = [] in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = [] in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, (clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then clone 0 (List.length l2 - List.length l1) @ l1, l2
else l1, clone 0 (List.length l1 - List.length l2 @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then clone 0 (List.length l2 - List.length l1) @ l1, l2
else l1, clone 0 (List.length l1 - List.length l2 @ l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, (clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1) @ l1, l2)
else l1, clone 0 (List.length l1 - List.length l2 @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1) @ l1, l2)
else l1, clone 0 (List.length l1 - List.length l2 @ l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, (clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, clone 0 (List.length l1 - List.length l2 @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, clone 0 (List.length l1 - List.length l2 @ l2)


fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let res = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, res)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let a = (b, c)  in
let x = (_, d) in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let a = (b, c)  in
let x = (_, d) in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let res = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, res)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let a = (b, c)  in
let  (_, d) = x in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let a = (b, c)  in
let  (_, d) = x in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let res = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, res)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let  (_, d) = x in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (b, c) = a in
let  (_, d) = x in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let a = (b, c) in
let x = (_, d) in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let a = (b, c) in
let x = (_, d) in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (b, c) = x in
let res = b + c + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (b, c) = x in
let res = x + x + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (b, c) = x in
let res = x + x + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (addC, resOfAdd) = a in
let (i1, i2) = x in
let result = i1 + i2 + addC in
let nextCarry = result / 10 in
match resOfAdd with 
| [] -> (nextCarry, [nextCarry] @ [result mod 10] @ [])
| h::t -> (nextCarry, [nextCarry] @ [result mod 10] @ t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (addC, resOfAdd) = a in
let (i1, i2) = x in
let result = i1 + i2 + addC in
let nextCarry = result / 10 in
match resOfAdd with 
| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])
| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (addC, resOfAdd) = a in
let (i1, i2) = x in
let result = i1 + i2 + addC in
let nextCarry = result / 10 in
match resOfAdd with 
| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])
| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) List.rev l2  in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) List.rev l2  in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t

bad:
let rec sumList xs = function [] -> int

annotated:
let rec sumList : int list -> int = fun  xs  ->  function [] -> int


fix:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t

bad:
let rec sumList xs = 
[] -> 0
| h::t -> h + t

annotated:
let rec sumList : int list -> int = fun  xs  ->  
[] -> 0
| h::t -> h + t


fix:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t

bad:
let rec sumList xs = [] -> 0
| h::t -> h + t

annotated:
let rec sumList : int list -> int = fun  xs  ->  [] -> 0
| h::t -> h + t


fix:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t

bad:
let rec sumList xs = [] -> 0
| h::t -> h + t

annotated:
let rec sumList : int list -> int = fun  xs  ->  [] -> 0
| h::t -> h + t


fix:
let rec sumList xs = 
List.fold_left (+) xs

bad:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t in xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
[] ->0
| h::t -> h + t in xs


fix:
let rec sumList xs = 
List.fold_left (+) xs

bad:
let rec sumList xs = function (*failwith "TBD:sumList"*)
List.fold_left (+) xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  function (*failwith "TBD:sumList"*)
List.fold_left (+) xs


fix:
let rec sumList xs = match xs with
[] -> 0

bad:
let rec sumList xs = match xs with
| [] -> 0
| x :: xs -> List.fold_left x + xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> 0
| x :: xs -> List.fold_left x + xs


fix:
let rec sumList xs = match xs with
[] -> 0
| h::t -> 1

bad:
let rec sumList xs = match xs with
[] -> 0
| h::t -> h + sum t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
[] -> 0
| h::t -> h + sum t


fix:
let rec sumList xs = match xs with
[] -> 0
| h::t -> 1

bad:
let rec sumList xs = match xs with
[] -> 0
| h::t in xs -> h + sum t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
[] -> 0
| h::t in xs -> h + sum t


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec sumList xs = match xs with
[] -> int
| h::t -> 1

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
[] -> int
| h::t -> 1


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec sumList xs = 
[] -> res + 0
| x :: xs -> x + sumList xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
[] -> res + 0
| x :: xs -> x + sumList xs


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec sumList xs = 
[] -> 0
| x :: xs -> x + sumList xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
[] -> 0
| x :: xs -> x + sumList xs


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec sumList xs = 
[] -> 0
| x :: xs -> x + sumList xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
[] -> 0
| x :: xs -> x + sumList xs


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec sumList xs = 
[] -> 0
| x :: xs -> x + sumList xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
[] -> 0
| x :: xs -> x + sumList xs


fix:
let rec digitsOfInt n = match n with
0 -> []
| n -> n / 10 :: digitsOfInt n

bad:
let rec digitsOfInt n = match n with
0 -> []
| n -> n / 10 ::[] digitsOfInt n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
0 -> []
| n -> n / 10 ::[] digitsOfInt n


fix:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then -> []
else n -> n / 10 ::[] digitsOfInt n

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then -> []
else n -> n / 10 ::[] digitsOfInt n


fix:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else n / 10 ::[] digitsOfInt n

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else n / 10 ::[] digitsOfInt n


fix:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfIn n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfIn n []


fix:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n []


fix:
let _ = digitsOfInt (-1)

bad:
let _ = digitsOfInt 0

annotated:
let _ = digitsOfInt 0


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else match (n mod 10) with
_ -> _::[] digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match (n mod 10) with
_ -> _::[] digitsOfInt (n / 10)


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else match (n mod 10) with
_ -> digitsOfInt (n/10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match (n mod 10) with
_ -> digitsOfInt (n/10)::[]


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else match (n mod 10) with
_ -> digitsOfInt (n/10) ::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match (n mod 10) with
_ -> digitsOfInt (n/10) ::[]


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else digitOfInt (n/10) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else digitOfInt (n/10) :: []


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else digitsOfInt (n/10) :: []


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else digitsOfInt (n/10)


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else let rec loop n x = match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10)


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else
(n mod 10)::x
match n with 
0 -> [0]
| x -> loop n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else
(n mod 10)::x
match n with 
0 -> [0]
| x -> loop n []


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else loop (n/10) (n mod 10::x) in match n with
0 -> [0]
| _ -> loop n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else loop (n/10) (n mod 10::x) in match n with
0 -> [0]
| _ -> loop n []


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]


(* `digitsOfInt n` should return `[]` if `n` is not positive,
and otherwise returns the list of digits of `n` in the 
order in which they appear in `n`. *)

(* digitsOfInt : int -> int list  *)
(1 mod 10 ::4)

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]


(* `digitsOfInt n` should return `[]` if `n` is not positive,
and otherwise returns the list of digits of `n` in the 
order in which they appear in `n`. *)

(* digitsOfInt : int -> int list  *)
(1 mod 10 ::4)


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10::[])

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10::[])


fix:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1

bad:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) x in match n with
0 -> 0
_ -> x + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) x in match n with
0 -> 0
_ -> x + 1


fix:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1

bad:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
_ -> 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
_ -> 1


fix:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1

bad:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1


fix:
let _ = additivePersistence 12

bad:
let _ additivePersistence 0

annotated:
let _ additivePersistence 0


fix:
let _ = additivePersistence 12

bad:
let _ = additivePersistence 0

annotated:
let _ = additivePersistence 0


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> m
| - -> r_digitalRoot n 0

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n = 0 then 0
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> m
| - -> r_digitalRoot n 0


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> m
| _ -> r_digitalRoot n 0

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n = 0 then 0
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> m
| _ -> r_digitalRoot n 0


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> r_digital root m 0
| _ -> r_digitalRoot n 0

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n = 0 then 0
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> r_digital root m 0
| _ -> r_digitalRoot n 0


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> r_digitalRoot m 0
| _ -> r_digitalRoot n 0

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n = 0 then 0
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> r_digitalRoot m 0
| _ -> r_digitalRoot n 0


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n < then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n m

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n = 0 then 0
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n < then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n m


fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n < 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n m

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n = 0 then 0
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n < 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n m


fix:
let _ = digitalRoot 0

bad:
let rec digitalRoot n = 
if n <= 9 then n
else let rec r_digitalRoot n m = 
if n <= 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 123
| _ -> r_digitalRoot n (-1)

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n <= 9 then n
else let rec r_digitalRoot : int -> int = fun  n  ->  
if n <= 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 123
| _ -> r_digitalRoot n (-1)


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec listReverse l =
if l = [] then []
else let rec r_listReverse l x = match l with
[] -> []
| h::t -> r_listReverse t []::h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
if l = [] then []
else let rec r_listReverse : 'a list -> 'a list = fun  l  ->  match l with
[] -> []
| h::t -> r_listReverse t []::h


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec listReverse l =
if l = [] then []
else let rec r_listReverse l x = match l with
[] -> []
| h::t -> r_listReverse t h::[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
if l = [] then []
else let rec r_listReverse : 'a list -> 'a list = fun  l  ->  match l with
[] -> []
| h::t -> r_listReverse t h::[]


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec listReverse l = match l with
[] -> []
| h::t -> listReverse t ::h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
[] -> []
| h::t -> listReverse t ::h


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec listReverse l = 
match l with
[] -> []
| h::t -> listReverse t @ h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
[] -> []
| h::t -> listReverse t @ h


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
match l with
[] -> []
| h::t -> listReverse t @ h::[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
[] -> []
| h::t -> listReverse t @ h::[]


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
match n with 
0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]


fix:
let rec digitsOfInt n = 
if n < 0 then []
else let rec r_digitsOfInt n x = 
if n = 0 then x
else r_digitsOfInt (n / 10) (n mod 10 :: [])

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n = 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n = 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[]


fix:
let rec digitsOfInt n = 
if n < 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[] 
in match n with 
0 -> [0]
| _ -> digitsOfInt n @ []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n = 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n = 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[]


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = 
let orig_Esplode = esplode w and
let reverse_Esplode = explode reverseList w

annotated:
let palindrome : string -> bool = fun  w  ->  
let orig_Esplode = esplode w and
let reverse_Esplode = explode reverseList w


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = 
orig_Esplode = esplode w

annotated:
let palindrome : string -> bool = fun  w  ->  
orig_Esplode = esplode w


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = 
if w = [] then true
else
let orig_Esplode = esplode w and
let reverse_Esplode = explode reverseList w in 
let rec r_palindrome orig_Esplode revserse_Esplode = 
let h1 = h::orig_Esplode 
and h2 = h::reverse_Esplode
if h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if w = [] then true
else
let orig_Esplode = esplode w and
let reverse_Esplode = explode reverseList w in 
let rec r_palindrome : string -> bool = fun  w  ->  
let h1 = h::orig_Esplode 
and h2 = h::reverse_Esplode
if h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode
else false


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = 
if w = [] then true
else
let rec r_palindrome esplode w esplode reverseList w = true

annotated:
let palindrome : string -> bool = fun  w  ->  
if w = [] then true
else
let rec r_palindrome : string -> bool = fun  w  ->  true


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = 
if w = [] then true

annotated:
let palindrome : string -> bool = fun  w  ->  
if w = [] then true


fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

bad:
let palindrome w = match w with
[] -> true
| _ -> false

annotated:
let palindrome : string -> bool = fun  w  ->  match w with
[] -> true
| _ -> false


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
match n with
| [] -> []
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| [] -> []
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) :: (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) :: (n mod 10)


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])


fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])


fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with 
| 0 -> [0]
| _ -> 
if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])
else []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with 
| 0 -> [0]
| _ -> 
if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else match n with 
| 0 -> [0]
| _ -> 
if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])
else []


fix:
let _ = additivePersistence 0

bad:
let rec additivePersistence n = 
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence sumList n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence sumList n


fix:
let _ = additivePersistence 0

bad:
let rec additivePersistence n = 
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence (sumList n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence (sumList n)


fix:
let _ = additivePersistence 0

bad:
let rec additivePersistence n = 
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence (sumList (digitsOfInt n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence (sumList (digitsOfInt n))


fix:
let _ = digitalRoot 0

bad:
let rec digitalRoot n = 
if n <= 9 then n
else if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)
else digitalRoot (sumList (digitsOfInt n))

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n <= 9 then n
else if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)
else digitalRoot (sumList (digitsOfInt n))


fix:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> false

bad:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let rec r_palindrome w = 
match w with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
match w with 
| [] -> true
| _  -> 
let rec r_palindrome : string -> bool = fun  w  ->  
match w with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false


fix:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> false

bad:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let rec r_palindrome w = 
match w with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false
| _ -> false

annotated:
let palindrome : string -> bool = fun  w  ->  
match w with 
| [] -> true
| _  -> 
let rec r_palindrome : string -> bool = fun  w  ->  
match w with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false
| _ -> false


fix:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> false

bad:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| [] -> true
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome : string -> bool = fun  w  ->  match ex with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| [] -> true
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false


fix:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> false

bad:
let palindrome w = 
match w with 
| [] -> true
| _  -> false

annotated:
let palindrome : string -> bool = fun  w  ->  
match w with 
| [] -> true
| _  -> false


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let ex = esplode w in
let rev_ex = reverseList ex in
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false

annotated:
let palindrome : string -> bool = fun  w  ->  
let ex = esplode w in
let rev_ex = reverseList ex in
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
let ex = esplode w in
let rev_ex = reverseList ex

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
let ex = esplode w in
let rev_ex = reverseList ex


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
let rev_ex = reverseList ex in 
let ex = esplode w

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
let rev_ex = reverseList ex in 
let ex = esplode w


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (esplode w) (reverseList (esplode w))

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (esplode w) (reverseList (esplode w))


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (esplode w) (reverseList (explode w))

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (esplode w) (reverseList (explode w))


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (explode w) (reverseList (explode w))

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (explode w) (reverseList (explode w))


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false 
in
r_palindrome (explode w) (reverseList (explode w))

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false 
in
r_palindrome (explode w) (reverseList (explode w))


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false 
in
r_palindrome (explode w) (listReverse (explode w))

annotated:
let palindrome : string -> bool = fun  w  ->  
let rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false 
in
r_palindrome (explode w) (listReverse (explode w))


fix:
let _ = listReverse []

bad:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> append (listReverse t) [h]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| h::t -> append (listReverse t) [h]


fix:
let rec assoc (d,k,l) = match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> if k = k1 then v1
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> if k = k1 then 
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> if k = k1 then 
else assoc (d,k,t)


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then helper (seen, t) 
else helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem (h, seen) then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem (h, seen) then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then helper (seen, t) 
else helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then helper (seen, t) 
else helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
) then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
) then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then helper (seen, t) 
else helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then
seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then
seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then
seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen in 
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen in 
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h::seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h::seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen in 
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen in 
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen in 
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let _ = removeDuplicates [1,1,2]

annotated:
let _ = removeDuplicates [1,1,2]


fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h::seen
else seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h::seen
else seen


fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then h::seen
else seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then h::seen
else seen


fix:
let _ = removeDuplicates [1,1,2]

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen


fix:
let _ = removeDuplicates [1,1,2]

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen


fix:
let _ = removeDuplicates [1,1,2]

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen then seen 
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen then seen 
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let f x = 
let xx = x*x*x in (xx,xx<100)

bad:
let rec wwhile (f,b) =
let (b', c') = f b in 
match c' with
| False -> b'
| True  -> while (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let (b', c') = f b in 
match c' with
| False -> b'
| True  -> while (f, b')


fix:
let f x = 
let xx = x*x*x in (xx,xx<100)

bad:
let rec wwhile (f,b) =
let (b', c') = f b in 
match c' with
| False -> b'
| True  -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let (b', c') = f b in 
match c' with
| False -> b'
| True  -> wwhile (f, b')


fix:
let f x = 
let xx = x*x*x in (xx,xx<100)

bad:
let rec wwhile (f,b) =
let (b', c') = f b in 
match c' with
| false -> b'
| true  -> wwhile (f, b')

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let (b', c') = f b in 
match c' with
| false -> b'
| true  -> wwhile (f, b')


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToSring ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString expr1 ^ " * " ^ exprToString expr2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToSring ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString expr1 ^ " * " ^ exprToString expr2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString expr1 ^ " * " ^ exprToString expr2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString expr1 ^ " * " ^ exprToString expr2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString ex1 ^ " * " ^ exprToString ex2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString ex1 ^ " * " ^ exprToString ex2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString ex1 ^ " * " ^ exprToString ex2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString ex1 ^ "<" ^ exprToString ex2 ^ " ? " ^ exprToString ex3 ^ " : " ^ exprToString ex4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString ex1 ^ " * " ^ exprToString ex2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString ex1 ^ "<" ^ exprToString ex2 ^ " ? " ^ exprToString ex3 ^ " : " ^ exprToString ex4 ^ ")"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex) -> sin(pi * (eval (ex,x,y)))
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2
| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex) -> sin(pi * (eval (ex,x,y)))
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2
| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi * (eval (ex,x,y)))
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi * (eval (ex,x,y)))
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)


fix:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,4) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (1,5) in match r with
| 1 -> buildSine(build (rand, depth-1))
| 2 -> buildCosine( build (rand, depth-1))
| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (1,5) in match r with
| 1 -> buildSine(build (rand, depth-1))
| 2 -> buildCosine( build (rand, depth-1))
| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))


fix:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,4) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (1,5) in match r with
| 1 -> buildSine(build (rand, depth-1))
| 2 -> buildCosine( build (rand, depth-1))
| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (1,5) in match r with
| 1 -> buildSine(build (rand, depth-1))
| 2 -> buildCosine( build (rand, depth-1))
| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))


fix:
assoc
(-1, "bob", [("ranjit",85);("william",23);("moose",44)])

bad:
assoc
(-1, "william", [("ranjit",85);("william",23);("moose",44)])

annotated:
assoc
(-1, "william", [("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> 
if k = k1 then v1
else assoc (d,k,t)

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,4) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,4) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" exprToString e1 ^ ":" exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" exprToString e1 ^ ":" exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString e3 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString e3 ^ ")"


fix:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2 ^ ")"s
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString e3 ^ ")"

bad:
let _ = exprToString (NewExprA(VarX,VarY))

annotated:
let _ = exprToString (NewExprA(VarX,VarY))


fix:
let _ = eval (NewExprA(VarX, VarY), -1., 1.)

bad:
let _ = eval (NewExprA(VarX, VarY), 1., -1.)

annotated:
let _ = eval (NewExprA(VarX, VarY), 1., -1.)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (e)   -> sin(pi *. (eval (e,x,y)))
| Cosine (e) -> cos(pi *. eval (e,x,y))
| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)
| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)
| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)

bad:
let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.,-1.)

annotated:
let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.,-1.)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (e)   -> sin(pi *. (eval (e,x,y)))
| Cosine (e) -> cos(pi *. eval (e,x,y))
| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)
| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)
| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)

bad:
let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.)

annotated:
let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a - x in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a - x in
let base = fun y -> y in
List.fold_left f base fs


fix:
let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = a -> x in
let base =  y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a -> x in
let base =  y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f a -> f x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun f a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> f a in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f x -> f a in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> f a in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f x -> f a in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f a -> fun f x -> f z in
let base = fun y -> fun y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f a -> fun f x -> f z in
let base = fun y -> fun y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f a -> fun f x -> f z in
let base = fun y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f a -> fun f x -> f z in
let base = fun y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f a -> fun f x -> f z in
let base = fun y -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f a -> fun f x -> f z in
let base = fun y -> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f a -> fun f x -> f w in
let base = fun y -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f a -> fun f x -> f w in
let base = fun y -> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f a -> fun f x  in
let base = fun y -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f a -> fun f x  in
let base = fun y -> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f a -> fun f x in
let base = fun y -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f a -> fun f x in
let base = fun y -> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> fun f a in
let base = fun y -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f x -> fun f a in
let base = fun y -> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> fun f a -> fun f a x in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f x -> fun f a -> fun f a x in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y z-> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f x -> fun f a -> f a x in
let base = fun y z-> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> f (x a) in
let base = fun z -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun f x -> f (x a) in
let base = fun z -> z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun z -> f (x a) in
let base = fun z -> z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun z -> f (x a) in
let base = fun z -> z in
List.fold_left f base fs


fix:
let _ = sepConcat ", " ["foo";"bar";"baz"]

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a x in
let base = "" in
let l = h in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a x in
let base = "" in
let l = h in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep in
let base = h ^ sep in
let l = h in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep in
let base = h ^ sep in
let l = h in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]

annotated:
let _ = sepConcat ", " ["foo";"bar";"baz"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = t in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = t in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ a in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = "" in
let l = sl in
List.fold_left f base 

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = "" in
let l = sl in
List.fold_left f base 


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = a in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = a in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ sep ^ a in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ sep ^ a in
let base =  in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ sep ^ a in
let base =  in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = [] in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = [] in
let l = sl in
List.fold_left f base l


fix:
let stringOfList f l = List.map sepConcat l

bad:
let stringOfList f l = List.map "[" ^ sepConcat l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map "[" ^ sepConcat l ^ "]"


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let stringOfList f l = List.map sepConcat "" l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat "" l


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let stringOfList f l = List.map f (sepConcat "" l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat "" l)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let stringOfList f l = List.map f (sepConcat l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let stringOfList f l = List.map f (sepConcat "" l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat "" l)


fix:
let stringOfList f l = (List.map f l)

bad:
let stringOfList f l = sepConcat (List.map f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (List.map f l)


fix:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)

bad:
let rec clone x n = 
if x <= 0 then []
else
clone x::[] (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if x <= 0 then []
else
clone x::[] (n-1)


fix:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)

bad:
let rec clone x n = 
if x <= 0 then []
else
clone (x::[]) (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if x <= 0 then []
else
clone (x::[]) (n-1)


fix:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)

bad:
let rec clone x n = 
if n <= 0 then []
else
clone (x::[]) (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else
clone (x::[]) (n-1)


fix:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)

bad:
let rec clone x n = 
if n <= 0 then x
else
clone (x::[]) (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then x
else
clone (x::[]) (n-1)


fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h::clone t (n-1)

bad:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)
in clone [] n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else
clone (x) (n-1)
in clone [] n


fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h::clone t (n-1)

bad:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone h::x (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone h::x (n-1)


fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h :: clone t (n-1)

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h :: clone t (n-1)

bad:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone t (n-1) :: h

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone t (n-1) :: h


fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h :: clone t (n-1)

bad:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone t (n-1) :: h ::[]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone t (n-1) :: h ::[]


fix:
let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

bad:
let rec clone x n = 

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  


fix:
let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l2), l2)
else (l1, clone 0 l @ l2)

bad:
let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l2), l2)
else (l1, clone 0 l :: l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l2), l2)
else (l1, clone 0 l :: l2)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l1), l2)
else (l1, clone 0 l @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l1), l2)
else (l1, clone 0 l @ l2)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = x mod 10 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = x mod 10 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: t in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: t in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: [] in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: [] in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: (a+h)/10 in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: (a+h)/10 in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: (a+h)/10 in
let base = (0,0) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: (a+h)/10 in
let base = (0,0) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = (0,0) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = (0,0) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [0] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [0] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> c in macth x

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> c in macth x


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
with
| (add1, add2) -> ((c + add1 + add2) mod 10, (c + add1 + add2))

annotated:
with
| (add1, add2) -> ((c + add1 + add2) mod 10, (c + add1 + add2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in macth x

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in macth x


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
with
| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))

annotated:
with
| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in match x with
| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in match x with
| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in match x with
| (add1, add2) -> (x + add1 + add2) mod 10

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in match x with
| (add1, add2) -> (x + add1 + add2) mod 10


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let carry = match a with
| (x,y) -> x in 
match x with
| (add1, add2) -> 
let new_carry = (carry + add1 + add2) / 10 in
let digit = (carry + add1 + add2) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let carry = match a with
| (x,y) -> x in 
match x with
| (add1, add2) -> 
let new_carry = (carry + add1 + add2) / 10 in
let digit = (carry + add1 + add2) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 

| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let _ = removeZero [


let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 

| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 

| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let _ = removeZero [


let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 

| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = bigAdd [9;9] [9;9]

annotated:
let _ = bigAdd [9;9] [9;9]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)
| (_,_) -> ((carry/10), (carry mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)
| (_,_) -> ((carry/10), (carry mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [9;9]

annotated:
let _ = removeZero [9;9]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = [] then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (_,_) -> (carry::rest)
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (_,_) -> (carry::rest)
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = [] then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = () then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
if x = () then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = (Nil,Nil) then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
if x = (Nil,Nil) then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = (,) then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
if x = (,) then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 || List.length rest = List.length l2 then
(0, carry::rest)
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 or List.length rest = List.length l2 then
carry::rest
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 or List.length rest = List.length l2 then
carry::rest
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 || List.length rest = List.length l2 then
(0, carry::rest)
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 or List.length rest = List.length l2 then
(0, carry::rest)
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 or List.length rest = List.length l2 then
(0, carry::rest)
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> 
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, carry::rest)
else match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> 
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, carry::rest)
else match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, ((add1 + add2 + carry)/ 10,)::rest)in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, ((add1 + add2 + carry)/ 10,)::rest)in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, ((add1 + add2 + carry)/ 10)::rest)in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, ((add1 + add2 + carry)/ 10)::rest)in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
let new_carry = (add1 + add2 + carry) / 10 in
let result = (add1 + add2 + carry) mod 10 :: rest in
if(List.length result >= List.length l1 ||
List.length result >= List.length l2) then
(0, carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
let new_carry = (add1 + add2 + carry) / 10 in
let result = (add1 + add2 + carry) mod 10 :: rest in
if(List.length result >= List.length l1 ||
List.length result >= List.length l2) then
(0, carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
let new_carry = (add1 + add2 + carry) / 10 in
let result = (add1 + add2 + carry) mod 10 :: rest in
if(List.length result >= List.length l1 ||
List.length result >= List.length l2) && new_carry > 0 then
(0, carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let _ = bigAdd [5;0] [5;0]

annotated:
let _ = bigAdd [5;0] [5;0]


fix:
let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> 
let new_carry = ((i * x) + carry) / 10 in
let result = (((i * x) + carry) mod 10) :: rest in
if List.length result = List.length l && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)

bad:
let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> match x with 
| (mul1, mul2) ->
let new_carry = ((mul1 * mul2) + carry) / 10 in
let result = (((mul1 * mul2) + carry) mod 10) :: rest in
if(List.length result = List.length l1 ||
List.length result = List.length l2) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = match a with
| (carry, rest) -> match x with 
| (mul1, mul2) ->
let new_carry = ((mul1 * mul2) + carry) / 10 in
let result = (((mul1 * mul2) + carry) mod 10) :: rest in
if(List.length result = List.length l1 ||
List.length result = List.length l2) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)


fix:
let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> 
let new_carry = ((i * x) + carry) / 10 in
let result = (((i * x) + carry) mod 10) :: rest in
if List.length result = List.length l && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)

bad:
let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> match x with 
| (mul1, mul2) ->
let new_carry = ((mul1 * mul2) + carry) / 10 in
let result = (((mul1 * mul2) + carry) mod 10) :: rest in
if(List.length result = List.length l) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = match a with
| (carry, rest) -> match x with 
| (mul1, mul2) ->
let new_carry = ((mul1 * mul2) + carry) / 10 in
let result = (((mul1 * mul2) + carry) mod 10) :: rest in
if(List.length result = List.length l) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (index, rest) -> 
let new_index = index + 1 in
let results = bigAdd rest ((mulByDigit x l1)@clone 0 index)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (index, rest) -> 
let new_index = index + 1 in
let results = bigAdd rest ((mulByDigit x l1)@clone 0 index)


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
) in
(new_index, result) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
) in
(new_index, result) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [1;5] [1;5]

bad:
let _ = bigMul [1;5] [1;5]

annotated:
let _ = bigMul [1;5] [1;5]


fix:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList (List.tl xs))

bad:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
[] -> 0
| xs -> List.hd xs + (sumList List.tl xs)


fix:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList (List.tl xs))

bad:
let _ = sumList [1; 2; 3; 4]

annotated:
let _ = sumList [1; 2; 3; 4]


fix:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList (List.tl xs))

bad:
let _ = sumList [1; -2; 3; 5]

annotated:
let _ = sumList [1; -2; 3; 5]


fix:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList (List.tl xs))

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]


fix:
let rec digitsOfInt n = 
if n < 0 then []
else  digitsOfInt (n/10) @ [n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else  digitsOfInt (n/10) @ n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else  digitsOfInt (n/10) @ n mod 10


fix:
let rec digitsOfInt n = 
if n < 0 then []
else  digitsOfInt (n/10) @ [n mod 10]

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n < 0 then []
else  digitsOfInt (n/10) @ [n mod 10]

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let additivePersistence n =
if n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))
else n

annotated:
let additivePersistence : int -> int = fun  n  -> 
if n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))
else n


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

annotated:
let additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let additivePersistence n = additiveHelper n 0

annotated:
let additivePersistence : int -> int = fun  n  ->  additiveHelper n 0


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

annotated:
let additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let additivePersistence n = additiveHelper n 0

annotated:
let additivePersistence : int -> int = fun  n  ->  additiveHelper n 0


fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc d k ls

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else 



let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else 



let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc d k ls

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)


fix:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc d k ls

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)


fix:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match k with
| [] -> d
| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)

bad:
let f x = let xx = x*x*x in (xx, xx < 100 in
wwhile2 (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100 in
wwhile2 (f, 2)


fix:
let fixpoint (f,b) = wwhile ((f (f b)),b)

bad:
let fixpoint (f,b) = wwhile ((fun (f b) -> if f b = b then b else f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f b) -> if f b  ->  b then b else f b),b)


fix:
let fixpoint (f,b) = wwhile ((f (f b)),b)

bad:
let fixpoint (f,b) = wwhile ((fun -> if f b = b then b else f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun -> if f b  ->  b then b else f b),b)


fix:
let fixpoint (f,b) = wwhile ((f (f b)),b)

bad:
let fixpoint (f,b) = wwhile ((fun (f b)-> if f b = b then b else f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f b)-> if f b  ->  b then b else f b),b)


fix:
let fixpoint (f,b) = wwhile ((f (f b)),b)

bad:
let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f, b)-> if f b  ->  b then b else f b),b)


fix:
let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)

bad:
let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f' -> if f b ! ->  b then (b,true) else (f b, false)),b)


fix:
let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)

bad:
let fixpoint (f,b) = wwhile ((fun f'-> if f b = b then (b,false) else (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f'-> if f b  ->  b then (b,false) else (f b, true)),b)


fix:
let rec wwhile (f,b) = 
let (b',c') = f b in match c' with
| false -> b'
|     _ -> wwhile (f, b')

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)


fix:
let rec wwhile (f,b) = 
let (b',c') = f b in match c' with
| false -> b'
|     _ -> wwhile (f, b')

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)


fix:
let rec wwhile (f,b) = 
let (b',c') = f b in match c' with
| false -> b'
|     _ -> wwhile (f, b')

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec wwhile (f,b) = 
let (b',c') = f b in match c' with
| false -> b'
|     _ -> wwhile (f, b')

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f,b) -> if f b  ->  b then (f b, false) else (f b, true)),b)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b = b -> (f b, false) | _ -> (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f,b) -> match b with | f b  ->  b -> (f b, false) | _ -> (f b, true)),b)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) = b -> (f b, false) | _ -> (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f,b) -> match b with | (f b)  ->  b -> (f b, false) | _ -> (f b, true)),b)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((fun a -> if b = (f b) then (b,false) else ((f b),true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun a -> if b  ->  (f b) then (b,false) else ((f b),true)),b)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)
| Times (t,u) -> eval(t) * eval(u)
| Average (t,u) -> (eval(t) * eval(u)) / 2
| Cosine t -> cos(pi * eval(t))
| Sine t -> sin(pi * eval(t))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)
| Times (t,u) -> eval(t) * eval(u)
| Average (t,u) -> (eval(t) * eval(u)) / 2
| Cosine t -> cos(pi * eval(t))
| Sine t -> sin(pi * eval(t))
| VarX -> x
| VarY -> y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi * eval(t,x,y))
| Sine t -> sin(pi * eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi * eval(t,x,y))
| Sine t -> sin(pi * eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))
| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), 
buildHelper(rand, max_depth, curr_depth + 1))
| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), 
buildHelper(rand, max_depth, curr_depth + 1))
| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1))
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))
| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), 
buildHelper(rand, max_depth, curr_depth + 1))
| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), 
buildHelper(rand, max_depth, curr_depth + 1))
| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1))
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
)
else match rand(0,1) with
| 0 -> buildX
| 1 -> buildY

annotated:
)
else match rand(0,1) with
| 0 -> buildX
| 1 -> buildY


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
)
else match rand(0,1) with
| 0 -> buildX
| 1 -> buildY

annotated:
)
else match rand(0,1) with
| 0 -> buildX
| 1 -> buildY


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
)
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
)
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
)
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
)
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX ()
| 1 -> buildY ()
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX ()
| 1 -> buildY ()
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
)
else match rand(0,1) with
| 0 -> buildX ()
| 1 -> buildY ()

annotated:
)
else match rand(0,1) with
| 0 -> buildX ()
| 1 -> buildY ()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX 
| 1 -> buildY 
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX 
| 1 -> buildY 
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
)
else match rand(0,1) with
| 0 -> buildX 
| 1 -> buildY

annotated:
)
else match rand(0,1) with
| 0 -> buildX 
| 1 -> buildY


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> VarX
| 1 -> VarY 
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  
if curr_depth < max_depth then match rand(0,6) with
| 0 -> VarX
| 1 -> VarY 
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,(depth - 1))
| 3 -> buildCosine(build rand (depth - 1))
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,(depth - 1))
| 3 -> buildCosine(build rand (depth - 1))
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))
| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))
| 6 -> buildThresh(build(rand, (depth - 1)),
build(rand, (depth - 1)),
build(rand, (depth - 1)),
build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| _ -> buildX()

bad:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| _ -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| _ -> buildX()


fix:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| Tan t -> tan(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| Tan t -> tan(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| Tan t -> tan(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)::t

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)::t


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)::a

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)::a


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10) @ a

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10) @ a


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> []

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> []


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> a

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> a


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add l1 l2 = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add l1 l2 = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD"(*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD"(*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD"(*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  (0, List.rev ((List.combine l1 l2))) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD"(*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  (0, List.rev ((List.combine l1 l2))) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev( List.combine l1 l2 ) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [(0,0)] in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [(0,0)] in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base =  in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base =  in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
)::t
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
)::t
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
) @ t
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
) @ t
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
)
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
)
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match x with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match x with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (0, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (0, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> (0,0)
in
let base = (0, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> (0,0)
in
let base = (0, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> (z/10)::(z mod 10)in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> (z/10)::(z mod 10)in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> ((z/10),[z mod 10])in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> ((z/10),[z mod 10])in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> (z/10)::[z mod 10] in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> (z/10)::[z mod 10] in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> (((h+z)/10), ((h+z) mod 10)):: t 
| _ -> ((z/10),(z mod 10)) in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> (((h+z)/10), ((h+z) mod 10)):: t 
| _ -> ((z/10),(z mod 10)) in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> (((h+z)/10), ((h+z) mod 10))::t 
| _ -> ((z/10),(z mod 10)) in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> (((h+z)/10), ((h+z) mod 10))::t 
| _ -> ((z/10),(z mod 10)) in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)
in 
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)
in 
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0, _ ) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0, _ ) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0, l) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0, l) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((z)/10), [z mod 10])
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((w+z)/10), ((w+z) mod 10))
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((w+z)/10), ((w+z) mod 10))
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((z)/10), [z mod 10])
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((z)/10), ((z) mod 10))
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((z)/10), ((z) mod 10))
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) @ (0,0))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) @ (0,0))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2)::(0,0))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2)::(0,0))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2)::([0],[0]))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2)::([0],[0]))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w, [])   -> (w, (z/10)::(z mod 10))
| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = [] in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = [] in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)


fix:
let rec mulByDigit i l = 
let l1 = List.rev l in
let l2 = [i] in
let mul (l1, l2) = 
let f a x = let z = fst x * snd x in 
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero(mul (padZero l1 l2))

bad:
let rec mulByDigit i l = 
let l1 = List.reverse l in
let l2 = [i] in
let mul (l1, l2) = 
let f a x = let z = fst x * snd x in 
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero(mul (padZero l1 l2))

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let l1 = List.reverse l in
let l2 = [i] in
let mul (l1, l2) = 
let f a x = let z = fst x * snd x in 
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero(mul (padZero l1 l2))


fix:
let rec mulByDigit i l = 
let rec helper i l acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (i-1) l (bigAdd acc l)
in 
helper i l [0]

bad:
let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)


fix:
let rec mulByDigit i l = 
let rec helper i l acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (i-1) l (bigAdd acc l)
in 
helper i l [0]

bad:
let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [] i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [] i l


fix:
let rec mulByDigit i l = 
let rec helper i l acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (i-1) l (bigAdd acc l)
in 
helper i l [0]

bad:
let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [0] i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [0] i l


fix:
let rec mulByDigit i l = 
let rec helper i l acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (i-1) l (bigAdd acc l)
in 
helper i l [0]

bad:
let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> bigAdd lis acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [0] i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper acc n lis = match n with
| 1 -> bigAdd lis acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [0] i l


fix:
let rec mulByDigit i l = 
let rec helper w y acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (w-1) y (bigAdd acc y)
in 
helper i l [0]

bad:
let rec mulByDigit i l = 
let rec helper w y acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (w-1) y (bigAdd acc y)
in 
helper i l [10

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper w y acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (w-1) y (bigAdd acc y)
in 
helper i l [10


fix:
let rec mulByDigit i l = 
let rec adder n li acc = match n with
| 0 -> [0]
| 1 -> bigAdd li acc
| _ -> adder (n-1) li (bigAdd acc li) 
in 
adder i l [0]

bad:
let _ = mulByDigit 0 [1;2;3]

annotated:
let _ = mulByDigit 0 [1;2;3]


fix:
let _ = mulByDigit 999999999 [9;9;9;9]

bad:
let _ = mulByDigit 5 [6;9;8;9]

annotated:
let _ = mulByDigit 5 [6;9;8;9]


fix:
let _ = mulByDigit 999999999 [9;9;9;9]

bad:
let _ = mulByDigit 3 [9;9;9;9]

annotated:
let _ = mulByDigit 3 [9;9;9;9]


fix:
let _ = mulByDigit 999999999 [9;9;9;9]

bad:
let _ = mulByDigit 0 [1;2;3]

annotated:
let _ = mulByDigit 0 [1;2;3]


fix:
let _ = mulByDigit 999999999 [9;9;9;9]

bad:
let _ = mulByDigit 9999999 [9;9;9;9;9;9;9;9;9;9;]

annotated:
let _ = mulByDigit 9999999 [9;9;9;9;9;9;9;9;9;9;]


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let z = fst x * snd x in
match a with
| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let z = fst x * snd x in
match a with
| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
)
in 
let base = (0,[]) in
let args = failwith "TBD" in
let (_, res) = List.fold_left f base args in
res

annotated:
)
in 
let base = (0,[]) in
let args = failwith "TBD" in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let z = fst x * snd x in
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args = failwith "TBD" in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let z = fst x * snd x in
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args = failwith "TBD" in
let (_, res) = List.fold_left f base args in
res


fix:
let rec bigCombiner l1 l2 acc = 
match l1 with
| [] -> acc
| h::t -> mulByDigit h l2

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec bigCombiner l1 l2 acc = 
match l1 with
| [] -> acc
| h::t -> mulByDigit h l2

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
;;

bad:
let bigMul l1 l2 = 
let f a x = x in 
let base = (0, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = x in 
let base = (0, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec mulByTen n = match n with
| 0 -> 0
| 1 -> 10
| _ -> 10 * (mulByTen (n-1))

bad:
let bigMul l1 l2 = 
let f a x =  x in 
let base = (0, []) in
let args = ( List.rev l1 , List.rev l2 ) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  x in 
let base = (0, []) in
let args = ( List.rev l1 , List.rev l2 ) in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = additivePersistence 9876

bad:
let rec additivePersistence (a, n) = 
if n < 10
then (n, 0)
else let (a', n') = (additivePersistence (a+1, sumList(digits n)))

annotated:
let rec additivePersistence : int -> int = fun  (a, n)  ->  
if n < 10
then (n, 0)
else let (a', n') = (additivePersistence (a+1, sumList(digits n)))


fix:
let _ = additivePersistence 9876

bad:
let rec additivePersistence (a, n) = 
if n < 10
then (n, 0)
else additivePersistence (a+1, sumList(digits n))

annotated:
let rec additivePersistence : int -> int = fun  (a, n)  ->  
if n < 10
then (n, 0)
else additivePersistence (a+1, sumList(digits n))


fix:
let _ = additivePersistence 9876

bad:
)

annotated:
)


fix:
let _ = additivePersistence 9876

bad:
let rec additivePersistence (a, n) = 
if n < 10
then (n, 0)
else additivePersistence (a+1, sumList(digits n))

annotated:
let rec additivePersistence : int -> int = fun  (a, n)  ->  
if n < 10
then (n, 0)
else additivePersistence (a+1, sumList(digits n))


fix:
let _ = additivePersistence (0,9876)

bad:
let rec additivePersistence (a, n) = 
if n < 10
then (a, n)
else additivePersistence (a+1, sumList(digits n))

annotated:
let rec additivePersistence : int -> int = fun  (a, n)  ->  
if n < 10
then (a, n)
else additivePersistence (a+1, sumList(digits n))


fix:
let rec sumList xs = match xs with
[] -> 0
| x :: xs -> x + sumList xs

bad:
let _ = digitalRoot 9876

annotated:
let _ = digitalRoot 9876


fix:
let rec additivePersistenceDigitalRoot (a, n) = 
if n < 10
then (a, n)
else additivePersistenceDigitalRoot (a+1, sumList(digits n))

bad:
let rec additivePersistence (a, n) = 
let intFun (a, n) = 
if n < 10
then (a, n)
else intFun (a+1, sumList(digits n))
in (4,5)

annotated:
let rec additivePersistence : int -> int = fun  (a, n)  ->  
let intFun (a, n) = 
if n < 10
then (a, n)
else intFun (a+1, sumList(digits n))
in (4,5)


fix:
let _ = digitsOfInt 03124

bad:
let _ = digitsOfInt o3124

annotated:
let _ = digitsOfInt o3124


fix:
let palindrome (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindrome (w, p + 1)

bad:
let palindrome (w, p) = 
if (List.length w) > (2 * p) and ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindrome (w, p + 1)

annotated:
let palindrome : string -> bool = fun  (w, p)  ->  
if (List.length w) > (2 * p) and ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindrome (w, p + 1)


fix:
let rec palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

bad:
let _ = palindrome (['a'], 0);

let palindrome w = failwith "TBD"

annotated:
let _ = palindrome (['a'], 0);

let palindrome : string -> bool = fun  w  ->  failwith "TBD"


fix:
let rec palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

bad:
let palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

annotated:
let palindrome : string -> bool = fun A (w, p)  ->  
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)


fix:
let rec palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

bad:
let _ = palindromeA (['a'], 0)

annotated:
let _ = palindromeA (['a'], 0)


fix:
let rec palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

bad:
let palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

annotated:
let palindrome : string -> bool = fun A (w, p)  ->  
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)


fix:
let rec palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

bad:
let _ = palindromeA (['a'], 0)

annotated:
let _ = palindromeA (['a'], 0)


fix:
let rec palindromeA (w, p) = 
if ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))
then true
else palindromeA (w, p + 1)

bad:
let _ = palindromeA (['a','b', 'c'], 0)

annotated:
let _ = palindromeA (['a','b', 'c'], 0)


fix:
let rec palindromeA (w, p) = 
if (List.length w) <= (2 * p)
then if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else false
else palindromeA (w, p + 1)

bad:
let rec palindromeA (w, p) = 
if (List.length w) <= (2 * p)
if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else false
else palindromeA (w, p + 1)

annotated:
let rec palindrome : string -> bool = fun A (w, p)  ->  
if (List.length w) <= (2 * p)
if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else false
else palindromeA (w, p + 1)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((f, (f b) != b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((f, (f b) != b),b)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((f, f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((f, f b = b),b)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((f, true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((f, true),b)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((failwith "asd", true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((failwith "asd", true),b)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((failwith "asd", failwith "asd"),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((failwith "asd", failwith "asd"),b)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((failwith "asd", undefined),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((failwith "asd", undefined),b)


fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((failwith "Asd"),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((failwith "Asd"),b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (failwith "asd") else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else failwith "asd" ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (if f b = b then (f b, false) else failwith "asd" ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (failwith "asd") else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then (f b, false) else failwith "asd") ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b then (f b, false) else failwith "asd") ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (failwith "asd") else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then failwith "asd" else failwith "asd") ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b then failwith "asd" else failwith "asd") ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (f b, false)) else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then (true, failwith "asd") else failwith "asd") ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b then (true, failwith "asd") else failwith "asd") ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (f b, false)) else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then (b, failwith "asd") else failwith "asd") ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b then (b, failwith "asd") else failwith "asd") ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (f b, false)) else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then (failwith "Asd", failwith "asd") else failwith "asd") ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b then (failwith "Asd", failwith "asd") else failwith "asd") ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (f b, false)) else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (failwith "Asd", failwith "asd")) else failwith "asd") ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b then (fun b''
-> (failwith "Asd", failwith "asd")) else failwith "asd") ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b'' -> (f b, false)) 
else (fun b'' -> (f b, true))), b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b''
-> (f b, false)) 
else (fun b'' -> (f b, true) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b 
then (fun b''
-> (f b, false)) 
else (fun b'' -> (f b, true) ,b)


fix:
let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b'' -> (f b, false)) 
else (fun b'' -> (f b, true))), b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b''
-> (f b, false)) 
else (fun b'' -> (f b, true))) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((if f b = b 
then (fun b''
-> (f b, false)) 
else (fun b'' -> (f b, true))) ,b)


fix:
let fixpoint (f,b) =
wwhile ((fun b' -> if f b' = b' 
then (f b', false)
else (f b', true)), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) <. (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi * eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi * eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) <. (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) <. (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) <. (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
let r = rand (if depth = 0 then (6, 7) else (1, 5)) in
match r with
1 -> buildSine (build (rand, depth - 1))
| 2 -> buildCosine (build (rand, depth - 1))
| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))
| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))
| 6 -> VarX
| 7 -> VarY

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let r = rand (if depth = 0 then (6, 7) else (1, 5)) in
match r with
1 -> buildSine (build (rand, depth - 1))
| 2 -> buildCosine (build (rand, depth - 1))
| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))
| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))
| 6 -> VarX
| 7 -> VarY


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
let r = rand (if depth = 0 then (6, 7) else (1, 5)) in
match r with
1 -> buildSine (build (rand, depth - 1))
| 2 -> buildCosine (build (rand, depth - 1))
| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))
| 6 -> VarX
| 7 -> VarY

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let r = rand (if depth = 0 then (6, 7) else (1, 5)) in
match r with
1 -> buildSine (build (rand, depth - 1))
| 2 -> buildCosine (build (rand, depth - 1))
| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))
| 6 -> VarX
| 7 -> VarY


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a
in max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0


fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a
in max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a
in max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a
in max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let _ = pipe [(fun x -> x)] 4

bad:
let _ = pipe [(fun x -> x + 2)] 4

annotated:
let _ = pipe [(fun x -> x + 2)] 4


fix:
let _ = pipe [(fun x -> x)] 4

bad:
let _ = pipe [(fun x -> 2)] 4

annotated:
let _ = pipe [(fun x -> 2)] 4


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y + 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun y -> y _+ 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun y -> y _+ 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 3 + a in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = 3 + a in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 3 + a in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = 3 + a in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x); (fun x -> x)] 4

annotated:
let _ = pipe [(fun x -> x); (fun x -> x)] 4


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> g (x a) in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> g (x a) in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> (a x) g in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> (a x) g in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> g (a x)  in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> g (a x)  in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> g (x a)  in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> g (x a)  in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> (g x) a  in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> (g x) a  in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> (g a) x  in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> (g a) x  in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> (a x) g in
let base = fun g -> g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> (a x) g in
let base = fun g -> g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> x (a g) in
let base = fun g -> g in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ "a" in
let base = failwith "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = ^ "a" in
let base = failwith "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = ^ "a" in
let base = failwith "" in
let l = sl in
List.fold_left f base l


fix:
 h in
let l = t in
List.fold_left f base l

bad:
let stringOfList f l = sepConcat "; " (map f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "; " (map f l)


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x :: clone x (n - 1)

bad:
let rec clone x n = match n with
| 0 -> []
| x :: clone x (n - 1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| x :: clone x (n - 1)


fix:
let padZero l1 l2 = 
let ll1 = List.length l1
in let ll2 = List.length l2
in ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)

bad:
let padZero l1 l2 = 
let l1 = List.length l1
in let l2 = List.length l2
in ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let l1 = List.length l1
in let l2 = List.length l2
in ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in
let base = (0, 1) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in
let base = (0, 1) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, 1) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, 1) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in
let base = (0, []) in
let args = List.reverse (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in
let base = (0, []) in
let args = List.reverse (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = (2, ds @ [(c + x1 + x2)]) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = if List.length ds = List.length l1 
then (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)
else ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = if List.length ds = List.length x1 
then (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)
else ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f (c, ds) (x1, x2) = if List.length ds = List.length x1 
then (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)
else ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd [] (clone l2 x)) @ indent) in
let base = ([], []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in
let base = ([], []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in
let base = ([], []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
val sumList : int list -> int

annotated:
val sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
sumList : int list -> int

annotated:
sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
sumList : int list -> int

annotated:
sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
val sumList : int list -> int

annotated:
val sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
val sumList : int list -> int

annotated:
val sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
let sumList : int list -> int

annotated:
let sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
let sumList : int list -> int

annotated:
let sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
let sumList : int list -> int

annotated:
let sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
sumList : int list -> int

annotated:
sumList : int list -> int


fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
sumList : int list -> int

annotated:
sumList : int list -> int


fix:
let rec sumList xs =
match xs with
| [] -> []
| let sum  = sum + hd :: sumLists tl

bad:
let rec sumList xs =
match xs with
| [] -> []
| let sum in hd::tl -> sum = sum + hd :: sumLists tl

annotated:
let rec sumList : int list -> int = fun  xs  -> 
match xs with
| [] -> []
| let sum in hd::tl -> sum = sum + hd :: sumLists tl


fix:
let rec sumList xs =
match xs with
| [] -> []
| hd::tl -> hd + (sumList tl)

bad:
let rec sumList xs =
match xs with
| [] -> []
| hd::tl -> sum  = sum + hd :: sumLists tl

annotated:
let rec sumList : int list -> int = fun  xs  -> 
match xs with
| [] -> []
| hd::tl -> sum  = sum + hd :: sumLists tl


fix:
let digitsOfInt n = 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let digitsOfInt n = 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n acc

bad:
let _ = digitsOfInt 345

annotated:
let _ = digitsOfInt 345


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n = 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n [7]

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n [7]


fix:
let digitsOfInt n = 
let rec loop n tlist =
if n = 0 then tlist
else loop (n/10) (n mod 10::tlist) in
match n with
| 0 -> [0]
| _ -> loop n [7]

bad:
let digitsOfInt n = 
let rec loop n tlist =
if n = 0 then tlist
else loop (n/10) (n mod 10::tlist)

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec loop n tlist =
if n = 0 then tlist
else loop (n/10) (n mod 10::tlist)


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> 
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> 
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| () -> d
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> 
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| () -> d
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)


fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen::h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen::h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = (seen::h) in
let rest' = (t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = (seen::h) in
let rest' = (t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl 2 = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl hd = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl hd = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl 2 = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl 2 = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl 2 = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem h tl = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl hd = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl hd = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b in
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b

bad:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b;
if (c' = false) then b'
else wwhelper f b'
in wwhelper fb

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec wwhelper f b =
let (b', c') = f b;
if (c' = false) then b'
else wwhelper f b'
in wwhelper fb


fix:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b in
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b in
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b

bad:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b;
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec wwhelper f b =
let (b', c') = f b;
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b


fix:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b in
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec exprToString e =
let rec eTShelper e expr =
let e::= x 
| y 
| sin (pi*e) 
| cos (pi*e) 
| ((e + e)/2) 
| e * e 
| (e<e ? e : e) in
match e with
| VarX -> expr ^ e
| VarY -> expr ^ e
| Sine -> expr ^ e
| Cosine -> expr ^ e
| Average  -> expr ^ e
| Times    -> expr ^ e
| Thresh   -> expr ^ e
in
eTShelper e ""

bad:
let rec exprToString e =
let rec eTShelper e expr =
let e::= x 
| y 
| sin (pi*e) 
| cos (pi*e) 
| ((e + e)/2) 
| e * e 
| (e<e ? e : e) in
match e with
| VarX -> expr ^ e
| VarY -> expr ^ e
| Sine -> expr ^ e
| Cosine -> expr ^ e
| Average  -> expr ^ e
| Times    -> expr ^ e
| Thresh   -> expr ^ e
in
eTShelper e ""

annotated:
let rec exprToString : expr -> string = fun  e  -> 
let rec eTShelper e expr =
let e::= x 
| y 
| sin (pi*e) 
| cos (pi*e) 
| ((e + e)/2) 
| e * e 
| (e<e ? e : e) in
match e with
| VarX -> expr ^ e
| VarY -> expr ^ e
| Sine -> expr ^ e
| Cosine -> expr ^ e
| Average  -> expr ^ e
| Times    -> expr ^ e
| Thresh   -> expr ^ e
in
eTShelper e ""


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi * evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi * evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(Varx), 0.5, -0.5)

annotated:
let _ = eval(Sine(Varx), 0.5, -0.5)


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(Varx), 0.5, -0.5)

annotated:
let _ = eval(Sine(Varx), 0.5, -0.5)


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. float evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. float evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(Varx), 0.5, -0.5)

annotated:
let _ = eval(Sine(Varx), 0.5, -0.5)


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(Varx), 0.5, -0.5)

annotated:
let _ = eval(Sine(Varx), 0.5, -0.5)


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(Varx), 0.5, -0.5)

annotated:
let _ = eval(Sine(Varx), 0.5, -0.5)


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(Varx), 0.5, -0.5)

annotated:
let _ = eval(Sine(Varx), 0.5, -0.5)


fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

bad:
let _ = eval(Sine(VarX), 0.5, -0.5)

annotated:
let _ = eval(Sine(VarX), 0.5, -0.5)


fix:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ (buildhelper 0 (depth-1) expr) ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
in
buildhelper (rand 0 4) depth ""

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 depth-1 expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 depth-1 expr ^ ")"
in
buildhelper (rand 0 4) depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 depth-1 expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 depth-1 expr ^ ")"
in
buildhelper (rand 0 4) depth ""


fix:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ (buildhelper 0 (depth-1) expr) ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
in
buildhelper (rand 0 4) depth ""

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 depth-1 expr ^ ")"
in
buildhelper (rand 0 4) depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 depth-1 expr ^ ")"
in
buildhelper (rand 0 4) depth ""


fix:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand 0 1 = 0) then 
expr ^ "((" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "+" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "*" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)
| 4 -> 
expr ^ "(" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "<" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "?" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ":" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")"
in
buildhelper (rand 0 4) depth ""

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand 0 1 = 0) then 
expr ^ "((" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "+" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "*" ^ (eTShelper p2 expr)
| 4 -> 
expr ^ "(" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "<" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "?" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ":" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")"
in
buildhelper (rand 0 4) depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand 0 1 = 0) then 
expr ^ "((" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "+" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "*" ^ (eTShelper p2 expr)
| 4 -> 
expr ^ "(" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "<" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "?" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ":" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")"
in
buildhelper (rand 0 4) depth ""


fix:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand 0 1 = 0) then 
expr ^ "((" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "+" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "*" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)
| 4 -> 
expr ^ "(" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "<" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "?" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ":" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")"
in
buildhelper (rand 0 4) depth ""

bad:
let _ = build (rand, 3)

annotated:
let _ = build (rand, 3)


fix:
let g1 () = failwith "to be implemented"

bad:
let _ = build (rand, 3)

annotated:
let _ = build (rand, 3)


fix:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
(*
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildCosine(buildhelper 0 (depth-1) expr)
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
in
let num = rand(1,4) in 
buildhelper num depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
(*
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildCosine(buildhelper 0 (depth-1) expr)
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
in
let num = rand(1,4) in 
buildhelper num depth ""


fix:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

bad:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper (depth-1) (depth-1) expr)
else buildCosine(buildhelper 0 (depth-1) (depth-1) expr)
| (2 || 3) ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| (4 || _) ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
(*
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper (depth-1) (depth-1) expr)
else buildCosine(buildhelper 0 (depth-1) (depth-1) expr)
| (2 || 3) ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| (4 || _) ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""


fix:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

bad:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper (depth-1) (depth-1) expr)
else buildCosine(buildhelper 0 (depth-1) (depth-1) expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
(*
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper (depth-1) (depth-1) expr)
else buildCosine(buildhelper 0 (depth-1) (depth-1) expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""


fix:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

bad:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
(*
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  x in k b), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  b in k b), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((fun k x -> f x  ->  x), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x = x

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
), b)

annotated:
), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x = x;), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x;), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in k b), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  x in k b), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (x, x -> b)), b)


fix:
let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)

bad:
let fixpoint (f,b) = wwhile({let k x = f x in (b, k b!=b)), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile({let k x = f x in (b, k b! -> b)), b


fix:
let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)

bad:
let fixpoint (f,b) = wwhile({let k x = f x in (b, (k b)!=b)), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile({let k x = f x in (b, (k b)! -> b)), b


fix:
let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (b, b! -> b)), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x in (b, b! -> b), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x = y in (x, y! -> x), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x = x in (x, x! -> x), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile(let k x = let y = f x in (x, y!=x), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = let y = f x in (x, y! -> x), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = let y = f x in f x in (x, y! -> x), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let f x = let xx  ->  x*x*x in (xx, xx < 100), b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x<100), b)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (g x, x<100), b)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in g x in (x, x<100), b


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in g b in (x, x<100), b


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in g b in (x, x<100)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
), b

annotated:
), b


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = (f x) in g b in (x, x<100), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  (f x) in g b in (x, x<100), b


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

annotated:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let g x = (f x) in g b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  (f x) in g b, b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in g b ! ->  x, b)


fix:
let fixpoint (f,b) = wwhile(let g x = f x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in g b ! ->  b, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in (g b, (g b)! ->  b), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let xx  ->  x*x*x in (xx, xx < 100), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let xx  ->  b*b*b in (xx, xx < 100), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let f x = let xx  ->  x*x*x in (xx, xx < 100), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = f x in f), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in f), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g f x = let y = f x in (y,y != x)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g f x = let y = f x in (y,y ! ->  x)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let y = let g f x = f x in (y,y != x)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let y = let g f x = f x in (y,y ! ->  x)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = f x != x in (y,y != x)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x != x in (y,y ! ->  x)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x in (x, x! -> x)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = f x !=x), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x ! -> x), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = f x !=x in g b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x ! -> x in g b), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = f x in g b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in g b), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g b), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)


fix:
let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (b, xx! -> b) in g), b)


fix:
let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f b in (xx, xx! -> b) in g), b)


fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)

bad:
let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g xx = let xx = f x in (xx, xx! -> b) in g), b)


fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)

bad:
let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = xx = f x in (xx, xx! -> b) in g


fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)


fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)! -> b)), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx! -> b)), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx! -> b) in inwwhile), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)

bad:
let _ = fixpoint (collatz, 48)

annotated:
let _ = fixpoint (collatz, 48)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let _ = fixpoint (collatz, 48)

annotated:
let _ = fixpoint (collatz, 48)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=(f b)) in 
printf("%d\n", helper)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = let res = f x in (res, res!=(f b)) in 
printf("%d\n", helper)), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x != (f b)) in helper), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x != (f b)) in helper), b


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
)

annotated:
)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x != (f b)) in helper b), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x != (f b)) in helper b), b


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x != (f b)) in helper), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x != (f b)) in helper), b


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x != (f b)) in helper), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x, f x != (f b)) in helper), b


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x, f x = (f b)) in helper), b


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper b), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x, f x = (f b)) in helper b), b


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
)

annotated:
)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x, f x = (f b)) in helper b, b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let helper x = (f x, f x = (f b)) in helper b, b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = (f b)) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, f x = (f b)) in helper b), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=(f b)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, (f x)=(f b)) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, b=(f b)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f b, b=(f b)) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, b=(f b)) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f b, b=(f b)) in helper b), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, b=f b) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f b, b=f b) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b!=f x) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, b=f x) in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = f x, b=f x in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = f x, b=f x in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, b=f x) in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in (helper b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, b=f x) in (helper b)), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, b=f x) in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper b = (f b, b=f x) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper b = (f b, b=f x) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper b = (f b, b=f b) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper b = (f b, b=f b) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b < 10) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, b < 10) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x=x) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, f x=x) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=x) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, (f x)=x) in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=x) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, (f x)=x) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, x!=(f x)) in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, x!=(f x)) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, x!=(f x)) in helper b), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, x!=(f x)) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b!=(f x)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, b!=(f x)) in helper), b)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
wwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let _ = fixpoint (collatz, 48)

annotated:
let _ = fixpoint (collatz, 48)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let helper x = (f x, x!=(f x)) in helper), b)


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = base + xs**2 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = failwith "to be implemented" in
let base = base + xs**2 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = base**2 in
let base = base+a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = base**2 in
let base = base+a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = base**2 in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = base**2 in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2 in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a**2 in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = int a**2 in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = int a**2 in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a+base in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a+base in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = base + f a x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = base + f a x in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = f a x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = f a x in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = base in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = base in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = a ** 2 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = a ** 2 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = 3**2 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = 3**2 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = 2 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = 2 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = base + 1 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = base + 1 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+)
in
let base = base + a**2
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+)
in
let base = base + a**2
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+)
in
let base = a**2
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+)
in
let base = a**2
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+)
in
let base = f a**2 x
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+)
in
let base = f a**2 x
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 x
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+)
in
let base = f 2 x
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2 in
let base = f 2 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a**2 in
let base = f 2 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + base in
let base = f 2 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + base in
let base = f 2 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = []
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = []
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = _
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = _
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> []
| x::xs' -> f x xs'
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| [] -> []
| x::xs' -> f x xs'
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 0
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x*x in
let base = f 2 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x*x in
let base = f 2 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match x with
| hd::tl -> hd * hd + f a tl
in
let base = f 4 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = 
match x with
| hd::tl -> hd * hd + f a tl
in
let base = f 4 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match x with
| hd::tl -> hd * hd + (f a tl)
in
let base = f 4 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = 
match x with
| hd::tl -> hd * hd + (f a tl)
in
let base = f 4 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match x with
| hd::tl -> hd * hd
in
let base = f 4 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = 
match x with
| hd::tl -> hd * hd
in
let base = f 4 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = f 4 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x*x in
let base = f 4 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f (f 0 xs) xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f a xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f a xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f (f 0 xs) xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f base xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f base xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f (f 0 xs) xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f (f a xs) xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f (f a xs) xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f _ xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f _ xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f 4 thing
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f 4 thing
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 8 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = f 4 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a + x in
let base = f 4 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 8 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = base + f 4 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = base + f 4 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 8 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f base xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f base xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 8 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f xs xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = f xs xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 0
| hd::tl -> f (f 0 hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> base
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| [] -> base
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 0
| hd::tl -> f (f 0 hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 0
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| [] -> 0
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 4
| hd::tl -> f (f 2 hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x =  
match xs with
| [] -> a
| hd::tl -> f (f a hd) tl in
let base = 0
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x =  
match xs with
| [] -> a
| hd::tl -> f (f a hd) tl in
let base = 0
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 4
| hd::tl -> f (f 2 hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let rec f a x =  
match xs with
| [] -> a
| hd::tl -> f (f a hd) tl in
let base = 0
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let rec f a x =  
match xs with
| [] -> a
| hd::tl -> f (f a hd) tl in
let base = 0
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = base
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = base
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f a hd) tl
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f a hd) tl
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> xs
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| [] -> xs
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f hd hd + f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f hd hd + f tl tl
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f hd hd + f tl tl
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = match xs with
| [] -> a
| hd::tl -> hd*hd in
let base = f 0 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match xs with
| [] -> a
| hd::tl -> f hd tl in
let base = f 0 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match xs with
| [] -> a
| hd::tl -> f hd tl in
let base = f 0 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + hd*hd in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + hd*hd in
let base = []
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + hd*hd in
let base = []
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = match xs with
| [] -> 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + x*x in
let base = f 0 xs
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + x*x in
let base = f 0 xs
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = match xs with
| [] -> 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = match xs with
| [] -> []
| hd::tl -> f 0 hd
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x*x in
let base = match xs with
| [] -> []
| hd::tl -> f 0 hd
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> f 0 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> f 0 []
| hd::tl -> f 0 hd
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x*x in
let base = 
match xs with
| [] -> f 0 []
| hd::tl -> f 0 hd
in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> 0
| hd::tl -> f -1 hd
in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x*x in
let base = 
match xs with
| [] -> 0
| hd::tl -> f -1 hd
in
List.fold_left f base xs


fix:
let _ = sqsum [1;2;3]

bad:
let _ = sqsum [1;2;3]

List.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]

annotated:
let _ = sqsum [1;2;3]

List.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]


fix:
let pipe fs = 
let f a x = x in
let base = 0
in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x in
let base = 0
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x in
let base = 0
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = 0
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = 0
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  in
let base = x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a x in
let base = x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a x in
let base = x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> 0
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a x in
let base = fun x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x -> x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun x -> x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> 0
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a x in
let base = x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a x in
let base = x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> 0
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> a
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a x in
let base = fun x -> a
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y ->  a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y ->  y a x in
let base = fun x -> x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y ->  y a x in
let base = fun x -> x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun k -> x k(a) in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y ->  a (y x) in
let base = fun x -> x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y ->  a (y x) in
let base = fun x -> x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun k -> x a in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun k -> x a in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun k -> x k(k) in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun k -> x k(f a k) in
let base = fun x -> x
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun k -> x k(f a k) in
let base = fun x -> x
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun k -> x k(a) in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun k -> x k(a) in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun k -> a x in
let base = fun y -> y
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun k -> fun a x in
let base = fun y -> y
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun k -> fun a x in
let base = fun y -> y
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun k -> a x in
let base = fun y -> y
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun k -> a k(x) in
let base = fun y -> y
in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun k -> a k(x) in
let base = fun y -> y
in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun k -> x k a in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun k -> x k a in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun k -> x a k in
let base = fun x -> x
in
List.fold_left f base fs

bad:
et _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
et _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun k -> x a k in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n > 0 with
| true -> x::(clone x n-1)
| false -> x

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n > 0 with
| true -> x::(clone x n-1)
| false -> x


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n > 0 with
| true -> x::(clone x n-1)
| false -> x::[]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n > 0 with
| true -> x::(clone x n-1)
| false -> x::[]


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n > 0 with
| true -> x @ clone x n-1
| false -> x @ []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n > 0 with
| true -> x @ clone x n-1
| false -> x @ []


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n > 0 with
| true -> x @ clone x n-1
| false -> []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n > 0 with
| true -> x @ clone x n-1
| false -> []


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n = 0 with
| true -> x
| false -> x @ clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n = 0 with
| true -> x
| false -> x @ clone x n-1


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n = 0 with
| true -> (x)
| false -> (x) @ (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n = 0 with
| true -> (x)
| false -> (x) @ (clone x n-1)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) @ (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n = 0 with
| true -> []
| false -> (x) @ (clone x n-1)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) :: (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n = 0 with
| true -> []
| false -> (x) :: (clone x n-1)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) @ (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n = 0 with
| true -> []
| false -> (x) @ (clone x n-1)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) :: (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match n = 0 with
| true -> []
| false -> (x) :: (clone x n-1)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
match (n = 0) with
| true -> []
| false -> (x) :: (clone x n-1)


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone "foo" 2

annotated:
let _ = clone "foo" 2


fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let _ = clone clone (-3)

annotated:
let _ = clone clone (-3)


fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
(clone 0 (List.length l1 - List.length l2)) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if(List.length l1 > List.length l2) then
(clone 0 (List.length l1 - List.length l2)) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1


fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
(clone 0 (List.length l1 - List.length l2)) @ l2
else if (List.length l1 < List.length l2) then
(clone 0 (List.length l2 - List.length l1)) @ l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if(List.length l1 > List.length l2) then
(clone 0 (List.length l1 - List.length l2)) @ l2
else if (List.length l1 < List.length l2) then
(clone 0 (List.length l2 - List.length l1)) @ l1


fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1


fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::(clone 0 (List.length l1 - List.length l2) @ l2)
else if (List.length l1 < List.length l2) then
l2::(clone 0 (List.length l2 - List.length l1) @ l1)

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::(clone 0 (List.length l1 - List.length l2) @ l2)
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if(List.length l1 > List.length l2) then
l1::(clone 0 (List.length l1 - List.length l2) @ l2)
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1


fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
else if (List.length l1 < List.length l2) then
l2::((clone 0 (List.length l2 - List.length l1)) @ l1)

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
else if (List.length l1 < List.length l2) then
l2::((clone 0 (List.length l2 - List.length l1)) @ l1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if(List.length l1 > List.length l2) then
l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
else if (List.length l1 < List.length l2) then
l2::((clone 0 (List.length l2 - List.length l1)) @ l1)


fix:
let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
| false -> ((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]
else if (List.length l1 < List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if(List.length l1 > List.length l2) then
l1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]
else if (List.length l1 < List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2


fix:
let _ = (([0;0]@[1;1]), [1])

bad:
let _ = [9;9;9;9]::([0;0]@[1;1])

annotated:
let _ = [9;9;9;9]::([0;0]@[1;1])


fix:
let _ = (([0;0]@[1;1]), [1])

bad:
let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))
| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
match List.length l1 > List.length l2 with
| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))
| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = [0] in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([],[]) in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([],[]) in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
let comb a (hd::tl) =
a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

bad:
let rec mulByDigit i l = 
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i/10 != 0) then
hd*i mod 10::(hd*i/10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i/10 != 0) then
hd*i mod 10::(hd*i/10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l


fix:
let rec mulByDigit i l = 
let comb a (hd::tl) =
a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

bad:
let rec mulByDigit i l = 
let rec mBDhelper i x =
match x with
| [] -> 0
| hd::tl ->
if (hd*i/10 != 0) then
(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec mBDhelper i x =
match x with
| [] -> 0
| hd::tl ->
if (hd*i/10 != 0) then
(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l


fix:
let rec mulByDigit i l = 
let comb a (hd::tl) =
a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

bad:
let rec mulByDigit i l = 
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l


fix:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> (a)
| hd::tl -> (a + hd)
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

bad:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> a
| hd::tl -> a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let comb a b =
match b with
| [] -> a
| hd::tl -> a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l


fix:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> [a]
| hd::tl -> [a + hd]::[tl]
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

bad:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> [a]
| hd::tl -> [a + hd]::tl
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let comb a b =
match b with
| [] -> [a]
| hd::tl -> [a + hd]::tl
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x,[]) -> (new_carry, new_carry::[digit]) 
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x,[]) -> (new_carry, new_carry::digit) 
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  -> 
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x,[]) -> (new_carry, new_carry::digit) 
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args =
let rec argmaker x y =
match y with
| [] -> (,)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args =
let rec argmaker x y =
match y with
| [] -> (,)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append (x,[hd]) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append (x,[hd]) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,0)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,0)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then (x,hd) 
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append ((x,hd)) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append ((x,hd)) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = List.combine a x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = List.combine a x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = a::x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a::x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let rec digitsOfInt n = match n with 
0 -> []
| n -> [n % 10]::digitsOfInt (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with 
0 -> []
| n -> [n % 10]::digitsOfInt (n/10)


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let rec digitsOfInt n = 
if n > 0 then digitsOfInt(n/10)::n mod 10
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then digitsOfInt(n/10)::n mod 10
else []


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let rec digitsOfInt n = 
if n > 0 then digitsOfInt n/10::n mod 10
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then digitsOfInt n/10::n mod 10
else []


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let rec digitsOfInt n = 
if n >0 then n/10::n mod 10
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n >0 then n/10::n mod 10
else []


fix:
let rec digitsOfInt n = 
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []

bad:
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []

annotated:
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []


fix:
let rec digitsOfInt n = 
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []

bad:
et rec digitsOfInt n = 
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []

annotated:
et rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let rec additivePersistence n = match n with
| [] -> []
| h :: t -> t + digitsOfInt (additivePersistence h)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  match n with
| [] -> []
| h :: t -> t + digitsOfInt (additivePersistence h)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let rec additivePersistence n = 
if n < 10 then n + sum
else let sum _ = sumList (digitsOfInt(n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n < 10 then n + sum
else let sum _ = sumList (digitsOfInt(n))


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let rec additivePersistence n = 
if n < 10 then n + sum
else let sum _ = sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n < 10 then n + sum
else let sum _ = sumList (digitsOfInt n)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let rec additivePersistence n = 
if n < 10 then n + sum
else let sum _ = additivePersistence sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n < 10 then n + sum
else let sum _ = additivePersistence sumList (digitsOfInt n)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let rec additivePersistence n = 
if n < 10 then n + sum
else let sum = additivePersistence sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n < 10 then n + sum
else let sum = additivePersistence sumList (digitsOfInt n)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let additivePersistence n = 
if n < 10 then count
else (sumList (digitsOfInt n), count + 1)

annotated:
let additivePersistence : int -> int = fun  n  ->  
if n < 10 then count
else (sumList (digitsOfInt n), count + 1)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else (sumList (digitsOfInt n), count + 1)

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if n < 10 then count
else (sumList (digitsOfInt n), count + 1)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList (digitsOfInt n) count + 1

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if n < 10 then count
else sumList (digitsOfInt n) count + 1


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then 1
else 1 + sumList(digitsOfInt n)

bad:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else count + 1 sumList(digitsOfInt n)

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if n < 10 then count
else count + 1 sumList(digitsOfInt n)


fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then 1
else 1 + sumList(digitsOfInt n)

bad:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else count + 1 in sumList(digitsOfInt n)

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if n < 10 then count
else count + 1 in sumList(digitsOfInt n)


fix:
let rec additivePersistence n = 
if n < 10 then 1
else 1 + additivePersistence (sumList(digitsOfInt n))

bad:
let rec additivePersistence n = 
if n < 10 then 1
else 1 + additivePersistence sumList(digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n < 10 then 1
else 1 + additivePersistence sumList(digitsOfInt n)


fix:
let rec digitalRoot n = 
let sum = 0 in
if n < 10 then n + sum
else sum = digitalRoot(sumList(digitsOfInt n))

bad:
let rec digitalRoot n = 
if n < 10 then n + sum
else let sum = digitalRoot(sumList(digitsOfInt n))

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n < 10 then n + sum
else let sum = digitalRoot(sumList(digitsOfInt n))


fix:
let rec assoc (d,k,l) =   
match l with
| [] -> d
| x :: xs -> match x with
| (s,i) -> if s = k then i
else assoc(d,k,xs)

bad:
let rec assoc (d,k,l) =   
match l with
| [] -> d
| x :: xs -> match x
| (s,i) -> if s = k then i
else assoc(d,k,xs)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->    
match l with
| [] -> d
| x :: xs -> match x
| (s,i) -> if s = k then i
else assoc(d,k,xs)


fix:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen' @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen' @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen@ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen@ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> (eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> (eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y))


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + .eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + .eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then d = d -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,d))
| 1 -> buildCosine(build(rand,d))
| 2 -> buildAverage(build(rand,d))
| 3 -> buildTimes(build(rand,d))
| 4 -> buildThresh(build(rand,d))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then d = d -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,d))
| 1 -> buildCosine(build(rand,d))
| 2 -> buildAverage(build(rand,d))
| 3 -> buildTimes(build(rand,d))
| 4 -> buildThresh(build(rand,d))


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then let depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then let depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then let d = depth -1 in
match rand(0,4) with
| 0 -> buildSine((build(rand,d)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let d = depth -1 in
match rand(0,4) with
| 0 -> buildSine((build(rand,d)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildY()

bad:
 rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
 rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f nest -> x(a nest)  in
let base = f x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f nest -> x(a nest)  in
let base = f x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f nest -> (x(a nest))  in
let base = f x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f nest -> (x(a nest))  in
let base = f x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let stringOfList f l = "["^sepConcat ";" [List.map(f l)]^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat ";" [List.map(f l)]^"]"


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let stringOfList f l = "["^sepConcat ";"^[List.map(f l)]^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat ";"^[List.map(f l)]^"]"


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let stringOfList f l = "["^sepConcat ";" [List.map(f l)]^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat ";" [List.map(f l)]^"]"


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let stringOfList f l = "["^sepConcat ";" [List.map(f l)]^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat ";" [List.map(f l)]^"]"


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let stringOfList f l = "["^sepConcat ";" List.map(f l)^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat ";" List.map(f l)^"]"


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let stringOfList f l = "["^sepConcat ";" List.map(f l)^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat ";" List.map(f l)^"]"


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let stringOfList f l = "["^sepConcat(";" List.map(f l))^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^sepConcat(";" List.map(f l))^"]"


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then l1, l2
else if List.length l1 > List.length l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then l1, l2
else if List.length l1 > List.length l2


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2

annotated:
let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then l1, l2
else if (List.length l1 > List.length l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then l1, l2
else if (List.length l1 > List.length l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2

annotated:
let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then l1, l2
else if (List.length l1) > (List.length l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then l1, l2
else if (List.length l1) > (List.length l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2

annotated:
let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2)
(y, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2)
(y, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) then(y, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) then(y, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) -> (y, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) -> (y, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) (y, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) (y, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone l2 (List.length l2 - List.length l1) in
(z, l1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone l2 (List.length l2 - List.length l1) in
(z, l1)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone List.hd l2 (List.length l2 - List.length l1) in
(z, l1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone List.hd l2 (List.length l2 - List.length l1) in
(z, l1)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone List.hd l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone List.hd l2 (List.length l2 - List.length l1) in
(z, l1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone List.hd l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone List.hd l2 (List.length l2 - List.length l1) in
(z, l1)


fix:
let rec removeZero l = 
match l with 
| x::xs -> if x = 0 then removeZero(xs) else l

bad:
let rec removeZero l = 
match l with 
x::xs -> if x = 0 then removeZero(xs)
| [] -> xs

annotated:
let rec removeZero : int list -> int list = fun  l  ->  
match l with 
x::xs -> if x = 0 then removeZero(xs)
| [] -> xs


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  failwith "tba" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  failwith "tba" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec removeZero l = failwith "to be implemented"

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else then let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else then let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)


fix:
let rec removeZero l = failwith "to be implemented"

bad:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec removeZero l = failwith "to be implemented"

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> match a with
| (carry,[result]) -> if carry = 1 then 

match 
let base = (0,[]) in

if d1 + d2 > 9 then let carry = 1
else let carry = 0

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> match a with
| (carry,[result]) -> if carry = 1 then 

match 
let base = (0,[]) in

if d1 + d2 > 9 then let carry = 1
else let carry = 0


fix:
let rec removeZero l = failwith "to be implemented"

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)


fix:
let rec removeZero l = failwith "to be implemented"

bad:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1, List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1, List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@[List.combine(List.rev l1)(List.rev l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@[List.combine(List.rev l1)(List.rev l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  match x with 
| (_,n) -> 
match a with
| (numzero,result) ->
(i + 1, bigAdd(mulByDigit n l1 @ clone 0 i) result)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  match x with 
| (_,n) -> 
match a with
| (numzero,result) ->
(i + 1, bigAdd(mulByDigit n l1 @ clone 0 i) result)


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let base = (0,[]) in
let args = List.combine (List.rev l1)(List.rev l2)

annotated:
let base = (0,[]) in
let args = List.combine (List.rev l1)(List.rev l2)


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
)

annotated:
)


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let (_, res) = List.fold_left f base args in
res

annotated:
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit x l1 @ clone 0 numzero) result)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit x l1 @ clone 0 numzero) result)


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let base = (0,[]) in
let args = List.rev l2

annotated:
let base = (0,[]) in
let args = List.rev l2


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let (_, res) = List.fold_left f base args in
res

annotated:
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 @ clone 0 numzero) result)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 @ clone 0 numzero) result)


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let base = (0,[]) in
let args = List.rev l2

annotated:
let base = (0,[]) in
let args = List.rev l2


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let (_, res) = List.fold_left f base args in
res

annotated:
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result)


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let base = (0,[]) in
let args = List.rev l2

annotated:
let base = (0,[]) in
let args = List.rev l2


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let (_, res) = List.fold_left f base args in
res

annotated:
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let (_, res) = List.fold_left f base args in
res

annotated:
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

bad:
let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->   
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs in
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
match l2 with
| x::xs -> xs in
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
match l2 with
| x::xs -> t in
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
match l2 with
| x::xs -> t in
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = 
if n <= 0
then []
else n - (n/10) * 10 :: digitsOfInt (n/10)

bad:
let rec digitsOfInt n = 
if n <= 0
then []
else n - (n/10) * 10 :: digitsOfInt n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0
then []
else n - (n/10) * 10 :: digitsOfInt n/10


fix:
let _ = additivePersistence (-1)

bad:
let _ = additivePersistence -1

annotated:
let _ = additivePersistence -1


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> append (listReverse tl) [hd]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> append (listReverse tl) [hd]

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]

annotated:
let _ = listReverse ["a"; "b"; "c"; "d"]


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> append (listReverse tl) [hd]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> append (listReverse tl) [hd]

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]

annotated:
let _ = listReverse ["a"; "b"; "c"; "d"]


fix:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse tail)
then palindrome (List.tl (listReverse tail))
else false

bad:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = hd (listReverse w)
then palindrome (tl (listReverse tail))
else false

annotated:
let palindrome : string -> bool = fun  w  ->  match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = hd (listReverse w)
then palindrome (tl (listReverse tail))
else false


fix:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse tail)
then palindrome (List.tl (listReverse tail))
else false

bad:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse w)
then palindrome (List.tl (listReverse tail))
else false

annotated:
let palindrome : string -> bool = fun  w  ->  match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse w)
then palindrome (List.tl (listReverse tail))
else false


fix:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse tail)
then palindrome (List.tl (listReverse tail))
else false

bad:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse [w])
then palindrome (List.tl (listReverse [tail]))
else false

annotated:
let palindrome : string -> bool = fun  w  ->  match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse [w])
then palindrome (List.tl (listReverse [tail]))
else false


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di,ki) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di * ki) ->
if ki = k
then di
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| (di * ki) ->
if ki = k
then di
else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di,ki) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di,ki) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| di * ki ->
if ki = k
then di
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| di * ki ->
if ki = k
then di
else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di,ki) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di * ki) ->
if ki = k
then di
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| (di * ki) ->
if ki = k
then di
else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di,ki) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di*ki) ->
if ki = k
then di
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| (di*ki) ->
if ki = k
then di
else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (ki,di) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem h seen
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem (h, seen)
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem (h, seen)
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem h seen
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem h
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem h
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let fixpoint (f,b) = wwhile (
let g a = 
f a, f a != a
in 
g, b)

bad:
 g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
 g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)

bad:
let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a
in 
g, b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
fun a ->
f a, f a != a
in 
g, b


fix:
let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)

bad:
let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
fun a ->
f a, f a != a, b)


fix:
let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)

bad:
let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a
, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
fun a ->
f a, f a != a
, b)


fix:
let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)

bad:
let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a
, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
fun a ->
f a, f a != a
, b)


fix:
let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)

bad:
let fixpoint (f,b) = wwhile (fun a -> f a, f a != a, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun a -> f a, f a ! ->  a, b)


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> String.concat "pi* " ^ exprToString s

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> String.concat sep ["pi* "; exprToString s]

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> String.concat sep ["pi* "; exprToString s]


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi *. eval e)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi * eval e)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi * eval e)


fix:
let rec build (rand, depth) =
if 
(depth = 0)
then
match rand(0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rand (0,100) with
| i when (i<5) -> 
buildSine (build (rand, depth-1))
| i when (i<10) -> 
buildCosine (build (rand, depth-1))
| i when (i<20) -> 
buildAverage (build (rand, depth-1), build (rand, depth-1))
| i when (i<80) -> 
buildTimes (build (rand, depth-1), build (rand, depth-1))
| i when (i<100) ->
buildThresh (build (rand, depth-1), build (rand, depth-1), 
build (rand, depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
if 
(depth = 0)
then
match rand(0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rand (0,100) with
| i if (i<5) -> 
buildSine (build (rand, depth-1))
| i if (i<10) -> 
buildCosine (build (rand, depth-1))
| i if (i<20) -> 
buildAverage (build (rand, depth-1), build (rand, depth-1))
| i if (i<80) -> 
buildTimes (build (rand, depth-1), build (rand, depth-1))
| i if (i<100) ->
buildThresh (build (rand, depth-1), build (rand, depth-1), 
build (rand, depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if 
(depth = 0)
then
match rand(0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rand (0,100) with
| i if (i<5) -> 
buildSine (build (rand, depth-1))
| i if (i<10) -> 
buildCosine (build (rand, depth-1))
| i if (i<20) -> 
buildAverage (build (rand, depth-1), build (rand, depth-1))
| i if (i<80) -> 
buildTimes (build (rand, depth-1), build (rand, depth-1))
| i if (i<100) ->
buildThresh (build (rand, depth-1), build (rand, depth-1), 
build (rand, depth-1), build (rand, depth-1))


fix:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0

bad:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0


fix:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)


fix:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)


fix:
let sqsum xs = 
let f a x = x**2.0 in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x**2 in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x**2 in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x**2.0 in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x**2.0 in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x**2.0 in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x**2.0 in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x**.2.0 in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x**.2.0 in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x*xin

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x*xin


fix:
let sqsum xs = 
let f a x = x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = 0 in
List.fold_left f base xs

annotated:
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = base + x in
let base = x*x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = base + x in
let base = x*x in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = z in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = z in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a->'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'a->'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x  in
let base = fun b->b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x  in
let base = fun b->b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a->a) in
let base = fun a->a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x (a->a) in
let base = fun a->a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x  in
let base = fun b->b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a->a in
let base = fun a->a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a->a in
let base = fun a->a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c->x c in
let base = fun b->b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x-> x a in
let base = fun b->b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x-> x a in
let base = fun b->b in
List.fold_left f base fs


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = List.map sepConcat ";" l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat ";" l


fix:
let padZero l1 l2 = 
let length1 = List.length l1 in
let length2 = List.length l2 in
if (length1 > length2)
then List.append (clone 0 (length1 - length2)), length2
else List.append (clone 0 (length2 - length1)), length1

bad:
let padZero l1 l2 = 
let length1 = List.length l1 in
let length2 = List.length l2 in
if (lenth1 > length2)
then List.append (clone 0 (length1 - length2)), length2
else List.append (clone 0 (length2 - length1)), length1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.length l1 in
let length2 = List.length l2 in
if (lenth1 > length2)
then List.append (clone 0 (length1 - length2)), length2
else List.append (clone 0 (length2 - length1)), length1


fix:
let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

bad:
let rec sumList xs = match xs with
| [] -> []
| h::t -> h+sumList t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
| [] -> []
| h::t -> h+sumList t


fix:
let rec digitsOfInt n = 
if n < 0
then true
else false

bad:
let rec digitsOfInt n = 
if n < 0
then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0
then []


fix:
let rec digitsOfInt n = 
if n < 0
then true
else false

bad:
let rec digitsOfInt n = 
if n < 0
then -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0
then -> []


fix:
let rec digitsOfInt n = 
if n < 0
then true
else false

bad:
let rec digitsOfInt n = 
if n < 0
then true

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0
then true


fix:
let rec digitsOfInt n = 
if n < 0
then []
else []

bad:
let rec digitsOfInt n = 
if n < 0
then []
else

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0
then []
else


fix:
let rec digitsOfInt n = 
if n < 0
then []
else 
let (x,y) = (n mod 10, n / 10) in
n::(digitsOfInt n)

bad:
let rec digitsOfInt n = 
| n < 0 -> true

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
| n < 0 -> true


fix:
let rec digitsOfInt n = 
if n < 0
then []
else 
let (x,y) = (n mod 10, n / 10) in
n::(digitsOfInt n)

bad:
let rec digitsOfInt n =

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 


fix:
let rec digitsOfInt n = 
if n < 0
then []
else 
let (x,y) = (n mod 10, n / 10) in
n::(digitsOfInt n)

bad:
with
| n < 0 -> true

annotated:
with
| n < 0 -> true


fix:
let rec digitsOfInt n = 
if n > 0
then []
else if (n mod 10) < 10
then []
else (n mod 10)::(digitsOfInt (n / 10))

bad:
let rec digitsOfInt n = 
if n > 0
then []
else 
if (n mod 10) < 10
then [x]
else x::(digitsOfInt (n / 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0
then []
else 
if (n mod 10) < 10
then [x]
else x::(digitsOfInt (n / 10))


fix:
let rec digitsOfInt n = 
if n > 0
then []
else if (n mod 10) < 10
then []
else (n mod 10)::(digitsOfInt (n / 10))

bad:
let rec digitsOfInt n = 
if n > 0
then []
else if (n mod 10) < 10
then []
else x::(digitsOfInt (n / 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0
then []
else if (n mod 10) < 10
then []
else x::(digitsOfInt (n / 10))


fix:
let rec additivePersistence n = 
let x = sumList n in
if x < 10
then countlist n
else additivePersistence [x]

bad:
let rec additivePersistence n = 
let x = sumList n in
if x < 10
then countlist n
else additivePersistence x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = sumList n in
if x < 10
then countlist n
else additivePersistence x


fix:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits n
else additivePersistence sumList n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if sumList (digits n) < 10
then numdigits n
else additivePersistence sumList n


fix:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence sumList n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence sumList n


fix:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList n)


fix:
let _ = digitsOfInt (-3124)

bad:
let _ = digitsOfInt -3124

annotated:
let _ = digitsOfInt -3124


fix:
let _ = digitsOfInt (-3124)

bad:
let _ = digitsOfInt -3124

annotated:
let _ = digitsOfInt -3124


fix:
let rec wwhile (f,b) =
let (b',c') = f b in
if c'
then wwhile (f, b')
else
b'

bad:
let rec wwhile (f,b) =
let (b',c') = f b in
if c'
then f b'
else
b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let (b',c') = f b in
if c'
then f b'
else
b'


fix:
let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)

bad:
let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> if(f x) -> x then (b,false) else (f x,true),b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)

bad:
let fixpoint (f,b) = wwhile (fun x -> if (x=b) then (b,false) else (f x,true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> if (x -> b) then (b,false) else (f x,true),b)


fix:
let rec exprToString e = match e with 
VarX -> 1
| VarY-> 1
| Sine x -> 1
| Cosine  x -> 1
| Average (x,y) -> 1
| Times  (x,y)  -> 1
| Thresh  (x,y,z,w) -> 1

bad:
let rec exprToString e = match e with 
VarX -> printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average x y -> printf "A"
| Times  x y  -> printf "A"
| Thresh  x y z w -> printf "A"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average x y -> printf "A"
| Times  x y  -> printf "A"
| Thresh  x y z w -> printf "A"


fix:
let rec exprToString e = match e with 
VarX -> 1
| VarY-> 1
| Sine x -> 1
| Cosine  x -> 1
| Average (x,y) -> 1
| Times  (x,y)  -> 1
| Thresh  (x,y,z,w) -> 1

bad:
let rec exprToString e = match e with 
VarX -> printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average (x,y) -> printf "A"
| Times  (x,y)  -> printf "A"
| Thresh  (x,y,z,w) -> printf "A"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average (x,y) -> printf "A"
| Times  (x,y)  -> printf "A"
| Thresh  (x,y,z,w) -> printf "A"


fix:
let rec exprToString e = match e with 
VarX -> 1
| VarY-> 1
| Sine x -> 1
| Cosine  x -> 1
| Average (x,y) -> 1
| Times  (x,y)  -> 1
| Thresh  (x,y,z,w) -> 1

bad:
let rec exprToString e = match e with 
VarX -> Printf.printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average (x,y) -> printf "A"
| Times  (x,y)  -> printf "A"
| Thresh  (x,y,z,w) -> printf "A"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> Printf.printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average (x,y) -> printf "A"
| Times  (x,y)  -> printf "A"
| Thresh  (x,y,z,w) -> printf "A"


fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
let sprintf=Printf.sprintf in
VarX -> sprintf("x")
| VarY-> sprintf("x")
| Sine x ->3
| Cosine  x -> 4
| Average (x,y) -> 5
| Times  (x,y)  -> 6
| Thresh  (x,y,z,w) -> sprintf("%s<%s?%s:") x,y,z

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
let sprintf=Printf.sprintf in
VarX -> sprintf("x")
| VarY-> sprintf("x")
| Sine x ->3
| Cosine  x -> 4
| Average (x,y) -> 5
| Times  (x,y)  -> 6
| Thresh  (x,y,z,w) -> sprintf("%s<%s?%s:") x,y,z


fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
VarX -> Printf.sprintf("x")
| VarY-> sprintf("x")
| Sine x ->3
| Cosine  x -> 4
| Average (x,y) -> 5
| Times  (x,y)  -> 6
| Thresh  (x,y,z,w) -> sprintf("%s<%s?%s:") x,y,z

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> Printf.sprintf("x")
| VarY-> sprintf("x")
| Sine x ->3
| Cosine  x -> 4
| Average (x,y) -> 5
| Times  (x,y)  -> 6
| Thresh  (x,y,z,w) -> sprintf("%s<%s?%s:") x,y,z


fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
VarX -> Printf.sprintf("x")
| VarY-> Printf.sprintf("x")
| Sine x ->Printf.sprintf ("")
| Cosine  x -> Printf.sprintf ("")
| Average (x,y) -> Printf.sprintf ("")
| Times  (x,y)  -> Printf.sprintf ("")
| Thresh  (x,y,z,w) -> Printf.sprintf("%s<%s?%s:") x,y,z

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> Printf.sprintf("x")
| VarY-> Printf.sprintf("x")
| Sine x ->Printf.sprintf ("")
| Cosine  x -> Printf.sprintf ("")
| Average (x,y) -> Printf.sprintf ("")
| Times  (x,y)  -> Printf.sprintf ("")
| Thresh  (x,y,z,w) -> Printf.sprintf("%s<%s?%s:") x,y,z


fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "x"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" x,y,z

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "x"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" x,y,z


fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "x"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" x y z

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "x"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" x y z


fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" exprToString x exprToString y exprToStringz

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" exprToString x exprToString y exprToStringz


fix:
eval(Sine(VarX),0.,0.)

bad:
eval(Sine(0))

annotated:
eval(Sine(0))


fix:
eval(Sine(VarX),0.,0.)

bad:
eval(Sine(VarX),0,0)

annotated:
eval(Sine(VarX),0,0)


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y))
| Cosine a -> x
| Average (a,b) -> x
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(pi*eval(a,x,y))
| Cosine a -> x
| Average (a,b) -> x
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(pi*eval(a,x,y))
| Cosine a -> x
| Average (a,b) -> x
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x


fix:
let pi = 4.0 *. atan 1.0

bad:
eval(a,x,y)*2.

annotated:
eval(a,x,y)*2.


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y)*.pi)
| Cosine a -> cos(eval(a,x,y)*.pi)
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y)*.pi)
| Cosine a -> cos(eval(a,x,y)*.pi)
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y)*.pi)
| Cosine a -> cos(eval(a,x,y)*.pi)
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> x

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let _ = eval (sampleExpr1,0.5,0.2)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let g1 () = failwith "to be implemented"

bad:
build(rand,1)

annotated:
build(rand,1)


fix:
let rec build (rand, depth) =

bad:
let rec build (rand, depth) =

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 


fix:
let rec build (rand, depth) = 
if depth<2
then let x=rand(0,2) in
match x with
|0 -> buildX()
|1 -> buildY()
else
let x=rand(0,5) in
match x with
|0 -> buildSine(build(rand,depth))
|1 -> buildCosine(build(rand,depth))

bad:
let rec build (rand, depth) = 
if depth<2
then let x=rand(0,2) in
match x with
|0 -> buildX()
|1 -> buildY()
else
let x=rand(0,5) in
match x with
|0 -> buildSin(build(rand,depth))
|1 -> buildCosin(build(rand,depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth<2
then let x=rand(0,2) in
match x with
|0 -> buildX()
|1 -> buildY()
else
let x=rand(0,5) in
match x with
|0 -> buildSin(build(rand,depth))
|1 -> buildCosin(build(rand,depth))


fix:
let g1 () = doRandomGray(2,1,1)

bad:
build(rand,1)

annotated:
build(rand,1)


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*eval(a,x,y)) else (.1*eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*eval(a,x,y)) else (.1*eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*.eval(a,x,y)) else (.1*.eval(a,x,y)
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*.eval(a,x,y)) else (.1*.eval(a,x,y)
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)


fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)


fix:
let sqsum xs = 
let f a x = x*x
in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = x*x
in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x(a) in
let base = f 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = f 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun a -> 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun a'->_ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun a'->_ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun 'a->'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun 'a->'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun a -> a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun a -> a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun z -> a (x z) in
let base = fun a-> f a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun a-> f a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun a-> f a in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  h in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]

annotated:
let _ = sepConcat ", " ["foo";"bar";"baz"]


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  f in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  f in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep t in
let l =  h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base =  sepConcat sep t in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep t in
let l =  "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep t in
let l =  "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base =  sepConcat sep t in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep {} in
let l =  "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep {} in
let l =  "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base =  sepConcat sep t in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep [] in
let l =  "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep [] in
let l =  "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base =  sepConcat sep t in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  "" in
let l =  "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  "" in
let l =  "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  if t=[] then "A" else h in
let l =  sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  if t=[] then "A" else t in
let l =  sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  if t=[] then "A" else t in
let l =  sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^x in
let base =  if t=[] then sep else h in
let l =  sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^x in
let base =  if t="" then sep else h in
let l =  sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^x in
let base =  if t="" then sep else h in
let l =  sl in
List.fold_left f base l


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

fun x -> x

annotated:
let _ = sepConcat "X" ["hello"]

fun x -> x


fix:
let _ = sepConcat "X" ["hello"]

bad:
let stringOfList f l = failwith List.map (fun x-> "") l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> "") l


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

fun x -> x

annotated:
let _ = sepConcat "X" ["hello"]

fun x -> x


fix:
let _ = sepConcat "X" ["hello"]

bad:
let stringOfList f l = failwith List.map (fun x-> "") l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> "") l


fix:
let asd_ x = x

bad:
let stringOfList f l = failwith List.map (fun x-> x) (l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> x) (l)


fix:
let stringOfList f l = List.map (sepConcat "") l

bad:
let stringOfList f l = List.map asd l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map asd l


fix:
let stringOfList f l = List.map (sepConcat " ") l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map (sepConcat "") l

bad:
let stringOfList f l = List.map (sepConcat " ") l.string

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat " ") l.string


fix:
let stringOfList f l = List.map (fun x->x) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map (fun x-> Printf.sprintf "%d" x) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map (sepConcat f) l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = List.map (f) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let rec clone x n =
let acc = [] in
if x=0
then acc
else acc::clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let acc = [] in
if x=0
then acc
else acc::clone x n-1


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let rec clone x n =
let acc = [] in
if n=0
then acc
else clone x::acc n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let acc = [] in
if n=0
then acc
else clone x::acc n-1


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let rec clone x n =
let acc = [] in
if n=0
then acc
else clone x::acc n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let acc = [] in
if n=0
then acc
else clone x::acc n-1


fix:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n

bad:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let accum=[] in
if n<1
then []
else clone x n-1


fix:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n

bad:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x ne

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let accum=[] in
if n<1
then []
else clone x ne


fix:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x (n-1)

bad:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
let accum=[] in
if n<1
then []
else clone x n-1


fix:
let _ = clone 3 5

bad:
let _ = clone 3 -1

annotated:
let _ = clone 3 -1


fix:
let padZero l1 l2 = ((clone (clone 0 1)::l1 2),l2)

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let padZero l1 l2 = ((clone 0::l1 2),l2)

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
else []

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
else []

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
else []

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
else []

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append l2 l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
List.append l2 l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
else []

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1
else []

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1
else []


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then (List.append (clone 0 (a-b)) l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then (List.append (clone 0 (a-b)) l2)


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then (List.append (clone 0 (a-b)) l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then (List.append (clone 0 (a-b)) l2)


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then List.append (clone 0 (a-b)) l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then List.append (clone 0 (a-b)) l2


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 b-a) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 b-a) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 1) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 1) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(1)
then List.append (clone 0 1) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(1)
then List.append (clone 0 1) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(true)
then List.append (clone 0 1) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(true)
then List.append (clone 0 1) l1


fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(true)
then List.append l1 l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(true)
then List.append l1 l1


fix:
let padZero l1 l2 = List.length l1

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then a

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then a


fix:
let padZero l1 l2 = List.length l1

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then 1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then 1


fix:
let padZero l1 l2 = List.length l1

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then 1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then 1


fix:
let padZero l1 l2 = List.length l1

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then ""

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in
if(a<b)
then ""


fix:
let padZero l1 l2 = let a = List.length l1 in
a

bad:
let padZero l1 l2 = let a = List.length l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1


fix:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then 1
else 2

bad:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (a<b)
then a

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in
let b= List.length l2 in
if (a<b)
then a


fix:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then 1
else 2

bad:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then 1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in
let b= List.length l2 in
if (1<2)
then 1


fix:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then 1
else 2

bad:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then clone 0 1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in
let b= List.length l2 in
if (1<2)
then clone 0 1


fix:
let stringOfList f l = sepConcat "," (List.map (f) l)

bad:
let stringOfList f l = sepConcat(" " (List.map (f) l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat(" " (List.map (f) l))


fix:
let stringOfList f l = (sepConcat ";" (List.map (f) l))

bad:
let stringOfList f l = "["::(sepConcat ";" (List.map (f) l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["::(sepConcat ";" (List.map (f) l))


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let stringOfList f l = (sepConcat ";" (List.map (f) l))."]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  (sepConcat ";" (List.map (f) l))."]"


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x+1::a in
let base = [] in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x+1::a in
let base = [] in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x+1::a in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x+1::a in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a  in
let base = ([],[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a  in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a  in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(t,(h+x))::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(t,(h+x))::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(_,(h+x))
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(_,(h+x))
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(l1,(h+x))
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(l1,(h+x))
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
x+h
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
x+h
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(x+h,_)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(x+h,_)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(x+h,[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(x+h,[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(0,0)::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(0,0)::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
0::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
0::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[0;0]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[0;0]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[[0];[0]]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[[0];[0]]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],0)::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],0)::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[([],0)]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[([],0)]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[],0::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[],0::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(t,b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(t,b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(l1,[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(l1,[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h::t in
(asd,padZero(asd,x+h::b))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h::t in
(asd,padZero(asd,x+h::b))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h::t in
(asd,padZero(asd,(x+h::b)))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h::t in
(asd,padZero(asd,(x+h::b)))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero(asd3,asd2))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero(asd3,asd2))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero(asd3 asd2))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero(asd3 asd2))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 asd2)
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 asd2)
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 asd2::b)
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 asd2::b)
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 (asd2::b))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 (asd2::b))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 (asd2::b))
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 (asd2::b))
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[] & (x+h)>9)
then
let asd2=x+h-10 in
let asd3=asd2::b in
([],1::asd3)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[])
then
let asd2=x+h-10 in
let asd3=t in
let asd3=h2+1::t2 in
(_,asd2::b)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[])
then
let asd2=x+h-10 in
let asd3=t in
let asd3=h2+1::t2 in
(_,asd2::b)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[] & (x+h)>9)
then
let asd2=x+h-10 in
let asd3=asd2::b in
([],1::asd3)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[])
then
let asd2=x+h-10 in
let asd3=t in
let asd3=h2+1::t2 in
([],asd2::b)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[])
then
let asd2=x+h-10 in
let asd3=t in
let asd3=h2+1::t2 in
([],asd2::b)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
if(t=[])
then
([],1::(x+h-10)::b)
else
let h2::t2=t in
((h2+1::t2),(x+h-10)::b)

else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
if((t=[])
then
([],1::(x+h-10)::b)
else
let h2::t2=t in
((h2+1::t2),(x+h-10)::b)

else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
if((t=[])
then
([],1::(x+h-10)::b)
else
let h2::t2=t in
((h2+1::t2),(x+h-10)::b)

else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)

bad:
let rec mulByDigit i l = 
let accum = [] in
let rec helper i l accum = 
if(i ~=0)
then
match l with
| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum
else accum
in
helper

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let accum = [] in
let rec helper i l accum = 
if(i ~=0)
then
match l with
| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum
else accum
in
helper


fix:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)

bad:
let rec mulByDigit i l = 
let accum = [] in
let rec helper i l accum = 
if(i != 0)
then
match l with
| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum
else accum
in
helper

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let accum = [] in
let rec helper i l accum = 
if(i != 0)
then
match l with
| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum
else accum
in
helper


fix:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)

bad:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper x-1 l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper x-1 l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)


fix:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)

bad:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)


fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
mulByDigit x q in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
mulByDigit x q in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q)


fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(q+1,mulByDigit x l1) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
((+)1,mulByDigit x q) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
((+)1,mulByDigit x q) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(q+1,mulByDigit x l1) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(q+1,mulByDigit x q) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(q+1,mulByDigit x q) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec wwhile (f,b) =   
let (b', c') = f b in 
if c' then 
wwhile (f,b') 
else 
b'

bad:
let rec wwhile (f,b) =   
let (b', c') = f b in 
if c' then 
wwhile (f,b') 
else 
b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->    
let (b', c') = f b in 
if c' then 
wwhile (f,b') 
else 
b'


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile (let f b =  let fb  = f b in
(fb,fb=b) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b =  let fb   ->  f b in
(fb,fb=b) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile (let f b in  let fb  = f b in
(fb,fb=b) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b in  let fb   ->  f b in
(fb,fb=b) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile ((  let fb  = f b in
(fb,fb=b)) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let fb   ->  f b in
(fb,fb=b)) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in
(fb,fb=b)) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b = let fb   ->  f b in
(fb,fb=b)) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in 
(fb,fb=b) in f b) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b = let fb   ->  f b in 
(fb,fb=b) in f b) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in 
(fb,fb=b') in f b) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b' = let fb   ->  f b' in 
(fb,fb=b') in f b) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in 
(fb,fb=b') in f b') ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b' = let fb   ->  f b' in 
(fb,fb=b') in f b') ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in 
(fb,fb=b') in f b) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b' = let fb   ->  f b' in 
(fb,fb=b') in f b) ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = let w b' = let fb  = f b' in 
(fb,fb=b') in  wwhile ( w ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let w b' = let fb   ->  f b' in 
(fb,fb=b') in  wwhile ( w ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in 
(fb,fb=b') in  w ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) =  wwhile (let w b' = let fb   ->  f b' in 
(fb,fb=b') in  w ,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let _ = exprToString build (makeRand,5)

bad:
let rec build (rand, depth) = 
if depth = 0 then
let x= rand 1 2 in 
if x=1 then
buildX()
else
buildY()
else
let b = build(rand,depth-1) in 
match rand 1 5 with
| 1 -> buildSine(b)
| 2 -> buildCosine(b)
| 3 -> buildAverage(b,build(rand,depth-1))
| 4 -> buildTimes(b,build(rand,depth-1))
| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
let x= rand 1 2 in 
if x=1 then
buildX()
else
buildY()
else
let b = build(rand,depth-1) in 
match rand 1 5 with
| 1 -> buildSine(b)
| 2 -> buildCosine(b)
| 3 -> buildAverage(b,build(rand,depth-1))
| 4 -> buildTimes(b,build(rand,depth-1))
| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))


fix:
let rec build (rand, depth) = 
if depth = 0 then
let x= rand (1,2) in 
if x=1 then
buildX()
else
buildY()
else
let b = build(rand,depth-1) in 
match rand(1,5) with
| 1 -> buildSine(b)
| 2 -> buildCosine(b)
| 3 -> buildAverage(b,build(rand,depth-1))
| 4 -> buildTimes(b,build(rand,depth-1))
| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let _ = exprToString (build (makeRand,5))

annotated:
let _ = exprToString (build (makeRand,5))


fix:
let _ = let rand=makeRand(10,10) in exprToString (build (rand,5))

bad:
let _ = let rand=makeRand(10,39) in exprToString (build (rand,5))

annotated:
let _ = let rand=makeRand(10,39) in exprToString (build (rand,5))


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a^2::x  in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a^2::x  in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (a^2)::x  in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (a^2)::x  in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (a^2.)::x  in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (a^2.)::x  in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (a*a)::x  in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (a*a)::x  in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let pipe fs n= 
let f a x = x a  in
let base = n in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a  in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = f a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = f _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = f fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = _  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = _  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x   in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f fs  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = f fs  in
List.fold_left f base fs


fix:
let pipe fs  = 
let f a x = x   in
let base = 0   in
List.fold_left f base fs

bad:
let pipe fs  = 
let f a x = x   in
let base =   in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  
let f a x = x   in
let base =   in
List.fold_left f base fs


fix:
let pipe fs  = 
let f a x = x   in
let base = 0   in
List.fold_left f base fs

bad:
let pipe fs  = 
let f a x = x   in
let base =   in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  
let f a x = x   in
let base =   in
List.fold_left f base fs


fix:
let pipe fs  = 
let f a x = x a  in
let base = function y ->y  in
List.fold_left f base fs

bad:
let pipe fs  = 
let f a x = x a  in
let base = function y   in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  
let f a x = x a  in
let base = function y   in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun y  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun y  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base xs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = function y -> y  in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat "; " (map f l)) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sepConcat "; " (map f l)) ^ "]"


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let rec clone x n = 
let rec helper x n acc =
if n<= 0 then
acc
else
helper x (n-1) (x::acc) 
in
helper x n []

bad:
let rec clone x n = 
let rec helper x n acc 
if n<= 0 then
acc
else
helper x (n-1) (x::acc) 
in
helper x n []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper x n acc 
if n<= 0 then
acc
else
helper x (n-1) (x::acc) 
in
helper x n []


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
l1
else
l2

bad:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
((clone 0 (len1-len2)) @ len2),len1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
((clone 0 (len1-len2)) @ len2),len1


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
l1
else
l2

bad:
)
else
((clone 0 (len2-len1)) @ len1),len2

annotated:
)
else
((clone 0 (len2-len1)) @ len1),len2


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
l1
else
l2

bad:
)

annotated:
)


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
l1
else
l2

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
l1
else
l2

bad:
let _ = padZero [1;0;0;2] [9;9]

annotated:
let _ = padZero [1;0;0;2] [9;9]


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
(clone 0 (len2-len1))

bad:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
((clone 0 (len2-len1)) @ l1),l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
((clone 0 (len2-len1)) @ l1),l2


fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
(clone 0 (len2-len1))

bad:
)

annotated:
)


fix:
let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit ac mul in 
(ac*10,bigAdd shift la)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,(List.rev l2))) l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit ac a in 
(ac*10,bigAdd mul shift)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,l2)) l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit ac a in 
(ac*10,bigAdd mul shift)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,l2)) l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit ac mul in 
(ac*10,bigAdd shift la)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,(List.rev l2))) l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit mul ac in 
(ac*10,bigAdd shift la)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,(List.rev l2))) l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit mul ac in 
(ac*10,bigAdd shift la)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,(List.rev l2))) l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let pipe fs = 
let f a x = x(a) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = function  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = function  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = function x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = function x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x(a) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function x(a) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function x(a) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x(a) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function _ ->x(a) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function _ ->x(a) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x(a) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  x(a) in
let base = function in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  x(a) in
let base = function in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function v ->  x (a v) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function f' -> f' x(a) in
let base = function y ->y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function f' -> f' x(a) in
let base = function y ->y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function v ->  x (a v) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function f'->  x(f' a) in
let base = function y ->y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function f'->  x(f' a) in
let base = function y ->y in
List.fold_left f base fs


fix:
let rec multByDigit i l =
let rec helper i l2 acc s =
match l2 with
| []   -> 
s::acc
| h::t -> 
let n = i*h + s in
if n>9 then
helper i t ((n mod 10)::acc) (n/10) 
else
helper i t (n::acc) 0
in 
removeZero (helper i (List.rev l) [] 0)

bad:
let rec multByDigit i l =
rec helper i l2 acc s =
match l2 with
| []   -> 
s::acc
| h::t -> 
let n = i*h + s in
if n>9 then
helper i t ((n mod 10)::acc) (n/10) 
else
helper i t (n::acc) 0
in 
removeZero (helper i (List.rev l) [] 0)

annotated:
let rec multByDigit i l =
rec helper i l2 acc s =
match l2 with
| []   -> 
s::acc
| h::t -> 
let n = i*h + s in
if n>9 then
helper i t ((n mod 10)::acc) (n/10) 
else
helper i t (n::acc) 0
in 
removeZero (helper i (List.rev l) [] 0)


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) @ (helper (n / 10)) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) @ (helper (n / 10)) in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
(helper n).reverse

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
(helper n).reverse


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
let rec reverse xs =
match xs with
| [] -> xs
| hd :: tl -> (reverse tl) :: hd in
reverse (helper n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
let rec reverse xs =
match xs with
| [] -> xs
| hd :: tl -> (reverse tl) :: hd in
reverse (helper n)


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
let rec reverse xs =
match xs with
| [] -> []
| hd :: tl -> (reverse tl) :: hd in
reverse (helper n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
let rec reverse xs =
match xs with
| [] -> []
| hd :: tl -> (reverse tl) :: hd in
reverse (helper n)


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append (helper (n / 10)) (n mod 10) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append (helper (n / 10)) (n mod 10) in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [(n mod 10)] in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [(n mod 10)] in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [n mod 10] in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [n mod 10] in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [(n mod 10)] in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [(n mod 10)] in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append [helper (n / 10)] [(n mod 10)]) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append [helper (n / 10)] [(n mod 10)]) in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)]


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
) in
helper n

annotated:
) in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)]


fix:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append (helper (n / 10)) [(n mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append helper (n / 10) [(n mod 10)]) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append helper (n / 10) [(n mod 10)]) in
helper n


fix:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  helper (append [(m / 10)] [(m mod 10)]) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  helper (append [(m / 10)] [(m mod 10)]) in
helper n


fix:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: append tl xs2 in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs2 with 
| [] -> xs1
| hd :: tl -> (append (xs1 :: hd) tl) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec append xs1 xs2 = 
match xs2 with 
| [] -> xs1
| hd :: tl -> (append (xs1 :: hd) tl) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n


fix:
let _ = digitsOfInt 352663

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec additivePersistence n = 
let rec helper count x =
if (x < 10) then count else  (helper (count + 1) (sumList (digits n)))
in (helper 0 n)

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec additivePersistence n = 
let rec helper count x =
if (count = 1) then count else  (helper (count + 1) (sumList (digits n)))
in (helper 0 n)

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n


fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2)

annotated:
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2)


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper xs []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper xs []


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper xs []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper xs []


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper l []


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h :: seen else seen  in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h :: seen else seen  in
let rest' = t in helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = f xx in (xx, (f xx)  ->  xx),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (let xx = in (xx, (f xx) = xx),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = in (xx, (f xx)  ->  xx),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx ((xx, (f xx)  ->  xx)),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (fun xx ((xx, f xx = xx)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx ((xx, f xx  ->  xx)),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx -> ((xx, f xx  ->  xx)),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx -> (xx, f xx  ->  xx),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, f xx = xx)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, f xx  ->  xx)),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) =
let rec acc result =
let res = (f result) in
match res with
(b', c') -> if c' then acc b' else b'
in
acc b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec acc result =
let res = (f result) in
match res with
(b', c') -> if c' then acc b' else b'
in
acc b


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)

bad:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx) ! ->  xx)),b)


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )


fix:
let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX x -> sprintf "%s" x
| VarY y -> sprintf "%s" y in
acc e

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX x -> sprintf "%s" x
| VarY y -> sprintf "%s" y in
acc e

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX x -> sprintf "%s" x
| VarY y -> sprintf "%s" y in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX x -> sprintf "%s" x
| VarY y -> sprintf "%s" y in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY y -> sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY y -> sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY y -> sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY y -> sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> printf "x" 
| VarY -> printf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> printf "x" 
| VarY -> printf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let rec acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let rec acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let rec acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let rec acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let rec accu curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
accu e ""

exprToString VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let rec accu curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
accu e ""

exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = 
let rec accu curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
accu e ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  
let rec accu curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
accu e ""


fix:
exprToString VarX

bad:
let rec exprToString e = 
match e with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x   -> Printf.sprintf "Sine(%s)" exprToString x

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x   -> Printf.sprintf "Sine(%s)" exprToString x


fix:
exprToString VarX

bad:
let rec exprToString e = 
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine\(%s\)" exprToString x

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine\(%s\)" exprToString x


fix:
exprToString VarX

bad:
let rec exprToString e = 
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine(%s)" exprToString x

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine(%s)" exprToString x


fix:
exprToString VarX

bad:
let rec exprToString e = 
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine(%s)" (exprToString x)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine(%s)" (exprToString x)


fix:
let rec assoc (d,k,l) = 
let rec acc xs = 
match xs with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
acc tl
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"
in
acc l

bad:
exprToString Sine(VarX)

annotated:
exprToString Sine(VarX)


fix:
let rec assoc (d,k,l) = 
let rec acc xs = 
match xs with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
acc tl
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"
in
acc l

bad:
exprToString Sine(VarX)

annotated:
exprToString Sine(VarX)


fix:
let rec assoc (d,k,l) = 
let rec acc xs = 
match xs with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
acc tl
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"
in
acc l

bad:
| failwith "Why don't you just make me write a lisp compiler"


exprToString Sine(VarX)

annotated:
| failwith "Why don't you just make me write a lisp compiler"


exprToString Sine(VarX)


fix:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)

exprToString Sine(VarX)

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)


fix:
exprToString Sine(VarX)

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)


fix:
exprToString Sine(VarX)

bad:
exprToString Sine(VarX)

annotated:
exprToString Sine(VarX)


fix:
exprToString Sine(VarX)

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)
| _ -> failwith "are we writing a lisp compiler now"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)
| _ -> failwith "are we writing a lisp compiler now"


fix:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(pi*%s)" (exprToString x)
| 
| _ -> failwith "are we writing a lisp compiler now"

bad:
let _ = exprToString (Sine(VarX))

annotated:
let _ = exprToString (Sine(VarX))


fix:
let _ = exprToString (Sine(VarX))

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(pi*%s)" (exprToString x)
| _ -> failwith "are we writing a lisp compiler now"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(pi*%s)" (exprToString x)
| _ -> failwith "are we writing a lisp compiler now"


fix:
let _ = exprToString (Sine(Average(VarX, VarY)))

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(e') -> Printf.sprintf "sin(pi*%s)" (exprToString e')
| Cosine(e') -> Printf.sprintf "cos(pi*%s)" (exprToString e')
| Average(e1, e2) -> Printf.sprintf "((%s+%s)/2)" 
(exprToString e1) 
(exprToString e2)
| Times (e1, e2) -> Printf.sprintf "%s*%s"
exprToString e1
exprToString e2
| _ -> failwith "are we writing a lisp compiler now"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(e') -> Printf.sprintf "sin(pi*%s)" (exprToString e')
| Cosine(e') -> Printf.sprintf "cos(pi*%s)" (exprToString e')
| Average(e1, e2) -> Printf.sprintf "((%s+%s)/2)" 
(exprToString e1) 
(exprToString e2)
| Times (e1, e2) -> Printf.sprintf "%s*%s"
exprToString e1
exprToString e2
| _ -> failwith "are we writing a lisp compiler now"


fix:
let _ = exprToString (Sine(Average(VarX, VarY)))

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(e') -> Printf.sprintf "sin(pi*%s)" (exprToString e')
| Cosine(e') -> Printf.sprintf "cos(pi*%s)" (exprToString e')
| Average(e1, e2) -> Printf.sprintf "((%s+%s)/2)" 
(exprToString e1) 
(exprToString e2)
| Times (e1, e2) -> Printf.sprintf "%s*%s"
(exprToString e1)
(exprToString e2)
| _ -> failwith "are we writing a lisp compiler now"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(e') -> Printf.sprintf "sin(pi*%s)" (exprToString e')
| Cosine(e') -> Printf.sprintf "cos(pi*%s)" (exprToString e')
| Average(e1, e2) -> Printf.sprintf "((%s+%s)/2)" 
(exprToString e1) 
(exprToString e2)
| Times (e1, e2) -> Printf.sprintf "%s*%s"
(exprToString e1)
(exprToString e2)
| _ -> failwith "are we writing a lisp compiler now"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2
| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2
| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match l with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
assoc (d, k, tl)
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
assoc (d, k, tl)
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) =
let res = (f b) in
match res with
(b', c') -> if c' then wwhile (f, b') else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let res = (f b) in
match res with
(b', c') -> if c' then wwhile (f, b') else b'


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs (eval e))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs (eval e))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (absF (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (absF (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"


fix:
let _  = eval (Quad (VarX, VarY, VarX), 0.5, 0.5)

bad:
let _  = eval (Quad (VarX, VarY, VarX), 0.5, -0.5)

annotated:
let _  = eval (Quad (VarX, VarY, VarX), 0.5, -0.5)


fix:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next next)
| 4 -> buildTimes next next
| 5 -> buildThresh next next next next
| 6 -> buildSqrt next
| 7 -> buildGauss next next next

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next next)
| 4 -> buildTimes next next
| 5 -> buildThresh next next next next
| 6 -> buildSqrt next
| 7 -> buildGauss next next next


fix:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes next next
| 5 -> buildThresh next next next next
| 6 -> buildSqrt next
| 7 -> buildGauss next next next

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes next next
| 5 -> buildThresh next next next next
| 6 -> buildSqrt next
| 7 -> buildGauss next next next


fix:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)


fix:
)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
(| 0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
(| 0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)


fix:
)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
( 0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
( 0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)


fix:
)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY


fix:
let buildAbs(e)			   = Abs(e)

bad:
let buildSqrt(e)                   = Sqrt(e)

annotated:
let build: ((int * int -> int) * int) -> expr = fun Sqrt(e)                    ->  Sqrt(e)


fix:
let rec build (rand, depth) = match depth with
| 0 -> (match rand (1, 3) with
1-> VarX
| 2 -> VarY )
| _ -> let next = build (rand, depth - 1) in
match rand (1, 8) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))

bad:
let rec build (rand, depth) = match depth with
| 0 -> (match rand (1, 3) with
1-> VarX
| 2 -> VarY )
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> (match rand (1, 3) with
1-> VarX
| 2 -> VarY )
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 8) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))
| _ -> buildAbs next)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 8) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))
| _ -> buildAbs next)


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| Logistic (e1, e2, e3) -> 
(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))
-. 1.0))
| _ -> failwith "error"

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| Logistic (e1, e2, e3) -> 
(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))
-. 1.0) ** eval (e3, x, y))
| _ -> failwith "error"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| Logistic (e1, e2, e3) -> 
(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))
-. 1.0) ** eval (e3, x, y))
| _ -> failwith "error"


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 1) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> 
(match rand (0, 1) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next)


fix:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildLogistic (next,
build (rand, depth - 1), 
build (rand, depth - 1)))

bad:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildLogistic (next,
build (rand, depth - 1), 
build (rand, depth - 1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildLogistic (next,
build (rand, depth - 1), 
build (rand, depth - 1)))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x^2 in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x^2 in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a +. x ** 2in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a +. x ** 2in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a +. x ** 2.0 in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a +. x ** 2.0 in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*xin

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x*xin


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h acc) tl in
iter (fun y-> y) fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h acc) tl in
iter (fun y-> y) fs

bad:
let pipe fs = 
let f a x = fs (a x) in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs (a x) in
let base = x in
List.fold_left f base fs


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h acc) tl in
iter (fun y-> y) fs

bad:
let pipe fs = 
let f a x = fs (a x) in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs (a x) in
let base = fun y -> y in
List.fold_left f base fs


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h acc) tl in
iter (fun y-> y) fs

bad:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h curr) tl in
iter (fun y-> y) fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h curr) tl in
iter (fun y-> y) fs


fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h (acc)) tl in
iter (fun y-> y) fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h (acc)) tl in
iter (fun y-> y) fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]


fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (fun x -> (h (acc x))) tl in
iter id fs

bad:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (fun x -> (h (acc x)) tl in
iter id fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (fun x -> (h (acc x)) tl in
iter id fs


fix:
let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun y -> ((a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun y -> ((a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *


fix:
let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun y -> ((a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun y -> ((a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *


fix:
let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs

bad:
)

annotated:
)


fix:
let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *


fix:
let stringOfList f l = 
"[" ^ List.fold_left (^) 
""
(List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ List.map f l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ List.map f l ^ "]"


fix:
let stringOfList f l = 
"[" ^
List.fold_left (fun x acc -> x ^ "; " ^ acc) 
""
(List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" (fun x acc -> x ^ "; " ^ acc) 
List.fold_left (^) 
""
(List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" (fun x acc -> x ^ "; " ^ acc) 
List.fold_left (^) 
""
(List.map f l) ^ "]"


fix:
let stringOfList f l = 
"[" ^
(List.fold_right (fun x acc -> x ^ "; " ^ acc) 
(List.map f l) 
"")
^ "]"

bad:
let stringOfList f l = 
"[" ^
List.fold_right (fun x acc -> x ^ "; " ^ acc) 
""
(List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^
List.fold_right (fun x acc -> x ^ "; " ^ acc) 
""
(List.map f l) ^ "]"


fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
( clone 0 (len2 - len1) @ l1,
clone 0 (len1 - len2)@  l2)

bad:
let padZero l1 l2 = 
let len1 = List.len l1 in
let len2 = List.len l2 in
( clone 0 (len2 - len1) @ l1,
clone 0 (len1 - len2)@  l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1 = List.len l1 in
let len2 = List.len l2 in
( clone 0 (len2 - len1) @ l1,
clone 0 (len1 - len2)@  l2)


fix:
let padZero l1 l2 = 
let diff = (List.length l2) - (List.length l1) in
( clone 0 diff @ l1,
clone 0 (-diff) @  l2)

bad:
let padZero l1 l2 = 
let diff = (List.length l2) - (List.length l1) in
( clone 0 diff @ l1,
clone 0 -diff @  l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = (List.length l2) - (List.length l1) in
( clone 0 diff @ l1,
clone 0 -diff @  l2)


fix:
let rec removeZero l = match l with
| [] -> l
| h :: t -> if (h = 0) then removeZero t 
else l

bad:
let rec removeZero l = match l with
| [] -> l
| h :: t -> if (h = 0) then removeZer t 
else l

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| [] -> l
| h :: t -> if (h = 0) then removeZer t 
else l


fix:
let _ = bigAdd [1] [2]

bad:
let _ = bigAdd [1] [2];


let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [1] [2];


let _ = bigAdd [9;9] [1;0;0;2]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then (addit / 10) else 0), 
( addit mod 10 :: num)	)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then (addit / 10) else 0), 
( addit mod 10 :: num)	  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then (addit / 10) else 0), 
( addit mod 10 :: num)	  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f x a = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then 1 else 0), 
( addit mod 10 :: num))  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_right f args base in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then 1 else 0), 
( addit mod 10 :: num))  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_right f args base in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then 1 else 0), 
( addit mod 10 :: num))  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_right f args base in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry 
print_int l1' in
(addit / 10, ( addit mod 10 :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry 
print_int l1' in
(addit / 10, ( addit mod 10 :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
if (x = [] && carry > 0) then carry :: num else num

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
if (x = [] && carry > 0) then carry :: num else num


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = x in
let (l1', l2') = a in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = x in
let (l1', l2') = a in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
(0, x :: a)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
(0, x :: a)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  (0, x :: a) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  (0, x :: a) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  (0, x :: a) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  (0, x :: a) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l1 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l1 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, nume ) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  
let (carry, nume ) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, nume ) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =  
let (carry, nume ) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ ((addit mod 10) )) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ ((addit mod 10) )) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) )

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) )


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) ) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) ) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) ) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) ) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in car
in 
(add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in _
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in _
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZeros (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZeros (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine [0; l1] [0; l2] in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine [0; l1] [0; l2] in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith (Printf.sprintf "hi %d" addit)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith printf.sprintf "hi %d" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith printf.sprintf "hi %d" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith (Printf.sprintf "hi %d" addit)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith Printf.sprintf "hi %d" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith Printf.sprintf "hi %d" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf "hi %d" car 
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf "hi %d" car 
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car );
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car );
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("hi %d") carry

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("hi %d") carry


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.kprintf ("hi %d") carry)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.kprintf ("hi %d") carry)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.kprintf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.kprintf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d" carry))
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d" carry))
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %s" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %s" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]


fix:
let _ = bigAdd [1; 9] [2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d"; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d"; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf "%d\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("%d\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("%d\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf "%d\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("%d\n", addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("%d\n", addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n" l1' l2' carry; (if addit >= 10 then 1 else 0), num @ [addit mod 10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n" l1' l2' carry; (if addit >= 10 then 1 else 0), num @ [addit mod 10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf; Printf.sprintf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf Printf.sprintf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf Printf.sprintf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf (Printf.sprintf "%8d%8d%8d\n" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf (Printf.sprintf "%8d%8d%8d\n" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s"; Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s "Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s "Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s"; Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s" Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s" Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((Printf.printf "%s\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((Printf.printf "%s\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(let _ = Printf.printf "%s\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(let _ = Printf.printf "%s\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%s\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%s\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf (string_of_int addit) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf (string_of_int addit) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10), num @ [addit mod 10]

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10), num @ [addit mod 10]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
List.rev res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
List.reve res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
List.reve res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)
else bigAdd l (mulByDibit (i - 1) l)

bad:
let _ = mulByDigit 9 [9;9;9;9]

annotated:
let _ = mulByDigit 9 [9;9;9;9]


fix:
let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)
else bigAdd l (mulByDibit (i - 1) l)

bad:
let rec mulByDigit i l = if i = 1 then l 
else mulByDigit (i - 1) (bigAdd l l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = if i  ->  1 then l 
else mulByDigit (i - 1) (bigAdd l l)


fix:
let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)
else bigAdd l (mulByDibit (i - 1) l)

bad:
let _ = mulByDigit 9 [9;9;9;9]

annotated:
let _ = mulByDigit 9 [9;9;9;9]


fix:
let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)
else bigAdd l (mulByDibit (i - 1) l)

bad:
let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = if i  ->  0 then 0
else if i = 1 then l 
else l


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement =  10 ** place  in
(addit / 10, (addit mod 10) :: num) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement =  10 ** place  in
(addit / 10, (addit mod 10) :: num) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(addit / 10, (addit mod 10) :: num) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(addit / 10, (addit mod 10) :: num) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a mulByDigit (x * place) l1) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a mulByDigit (x * place) l1) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a mulByDigit ((x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a mulByDigit ((x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = digitsOfInt 1

bad:
let _ = digitsOfInt -1

annotated:
let _ = digitsOfInt -1


fix:
let _ = digitsOfInt 1

bad:
let _ = digitsOfInt -1.5

annotated:
let _ = digitsOfInt -1.5


fix:
let _ = digitsOfInt 1

bad:
let _ = digitsOfInt -1

annotated:
let _ = digitsOfInt -1


fix:
let rec sumList xs = match xs with
| []     -> 0 
| hd::tl -> hd + sumList tl

bad:
let _ = digitsOfInt -12

annotated:
let _ = digitsOfInt -12


fix:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum pos

bad:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum

annotated:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum


fix:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum pos

bad:
let additivePersistence n = 
let pos = digits n in
addPHelper n pos

annotated:
let additivePersistence : int -> int = fun  n  ->  
let pos = digits n in
addPHelper n pos


fix:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum pos

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let _ = additivePersistence 1

bad:
let _ = additivePersistence 1

annotated:
let _ = additivePersistence 1


fix:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

bad:
let rec build (rand, depth) = match depth with
| 0 -> buildX 
| 1 -> (build (rand, depth-(depth -1)))
| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> buildX 
| 1 -> (build (rand, depth-(depth -1)))
| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))


fix:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

bad:
let rec build (rand, depth) = match depth with
| 0 -> buildX 
| 1 -> (build (rand, depth-(depth -1)))
| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> buildX 
| 1 -> (build (rand, depth-(depth -1)))
| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))


fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

bad:
let rec eval (e,x,y) = match e with 
| BuildX()              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| BuildX()              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)


fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

bad:
eval (Times(VarX,VarY), 0.5, -0.5)

annotated:
eval (Times(VarX,VarY), 0.5, -0.5)


fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

bad:
eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)

annotated:
eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)


fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

bad:
eval (Sine(Average(VarX,VarY)), 0.5, -0.5)

annotated:
eval (Sine(Average(VarX,VarY)), 0.5, -0.5)


fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

bad:
eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)

annotated:
eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)


fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

bad:
eval (sampleExpr1,0.5,0.2)

annotated:
eval (sampleExpr1,0.5,0.2)


fix:
let pipe fs = 
let f a x = x (a+1) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = [fs a] in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = [fs a] in
let base = 0 in
List.fold_left f base fs


fix:
let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
5

bad:
let rec wwhile (f,b) = 
let ( a , b ) = f b in
if b then wwhile f a else a

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let ( a , b ) = f b in
if b then wwhile f a else a


fix:
let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
5

bad:
let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
if b then wwhile f a else a

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let ( a , b ) = (f b) in
if b then wwhile f a else a


fix:
let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
5

bad:
let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
if b then wwhile (f a) else a

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let ( a , b ) = (f b) in
if b then wwhile (f a) else a


fix:
let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile ( f, b' ) else b'

bad:
let rec wwhile (f,b) = 
let ( b' , c' ) = (f b) in
if c' then f b' else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let ( b' , c' ) = (f b) in
if c' then f b' else b'


fix:
let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile ( f, b' ) else b'

bad:
let rec wwhile (f,b) = 
let ( b' , c' ) = (f b) in
if c' then wwhile (f b') else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let ( b' , c' ) = (f b) in
if c' then wwhile (f b') else b'


fix:
let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile ( f, b' ) else b'

bad:
let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile f b' else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let ( b' , c' ) = f b in
if c' then wwhile f b' else b'


fix:
let fixpoint (f,b) = 
let rec helper (f, b) =
let b' = f b in
if b' = b then b' else helper (f, b')
in helper (f, b)

bad:
let fixpoint (f,b) = 
let rec helper (f, b) =
let b' = f b in
if b' = b then b' else helper (f, b')

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let rec helper (f, b) =
let b' = f b in
if b' = b then b' else helper (f, b')


fix:
let _ = fixpoint (collatz, 9349802374897001)

bad:
let _ = fixpoint (collatz, 93rew001)

annotated:
let _ = fixpoint (collatz, 93rew001)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e' x y ) ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e' x y ) ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )


fix:
let _ = eval (Average(VarX,VarY)), 5.0, 10.0

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

bad:
let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )

annotated:
let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )


fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval sampleExpr 0.5 0.2

annotated:
let _ = eval sampleExpr 0.5 0.2


fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval( sampleExpr, 0.5, 0.2 )

annotated:
let _ = eval( sampleExpr, 0.5, 0.2 )


fix:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial( eval( e', x, y ), 1 )
| Sum3( e1, e2, e3 )
-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial( eval( e' ), 1 )
| Sum3( e1, e2, e3 )
-> eval( e1 ) +. eval( e2 ) +. eval( e3 )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial( eval( e' ), 1 )
| Sum3( e1, e2, e3 )
-> eval( e1 ) +. eval( e2 ) +. eval( e3 )


fix:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial( eval( e', x, y ), 1 )
| Sum3( e1, e2, e3 )
-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial (eval( e', x, y )) 1.0 
| Sum3( e1, e2, e3 )
-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial (eval( e', x, y )) 1.0 
| Sum3( e1, e2, e3 )
-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )


fix:
let _ = eval (Factorial(VarX), 5.0, 4.0 )

bad:
let _ = eval (Factorial(VarX), 5.0, 0.0 )

annotated:
let _ = eval (Factorial(VarX), 5.0, 0.0 )


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( (f, ( b, ( f b )  ->  b ))), b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ( f b, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( f b, b )


fix:
let fixpoint (f,b) = wwhile ( (f b) = b , b )

bad:
let fixpoint (f,b) = wwhile ( (f b), b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( (f b), b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( f, (f b) = b , b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( f, (f b)  ->  b , b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = let xx = f b in ( b' = b ) 
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' b' = let xx = f b in ( b' = b ) 
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = f b in ( b' = b ) 
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' b' = f b in ( b' = b ) 
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let b' = f b in ( b' = b ) 
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let b' = f b in ( b' = b ) 
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f x = x*x*x in (xx, xx < 512)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f x = x*x*x in (xx, xx < 512)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let f' x = let xx = x*x*x in (xx, xx < 512)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' x = let xx = x*x*x in (xx, xx < 512)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) = wwhile ( 
let b' = f b in ( f, b' = b)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let b' = f b in ( f, b' = b)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) =  
let b' = f b in wwhile( ( f, b' = b)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->   
let b' = f b in wwhile( ( f, b' = b)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) =  
let b' = f b in wwhile( ( f , b' = b)
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->   
let b' = f b in wwhile( ( f , b' = b)
, b )


fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

bad:
let fixpoint (f,b) =  
let b' = f b in wwhile( f , b' = b
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->   
let b' = f b in wwhile( f , b' = b
, b )


fix:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = f b in ( f', b' = b )
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' b' = f b in ( f', b' = b )
, b )


fix:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let b' = f b in ( f, b' = b )
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let b' = f b in ( f, b' = b )
, b )


fix:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let b' = f b in ( f, (b' = b) )
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let b' = f b in ( f, (b' = b) )
, b )


fix:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f b, b = b' )
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' b' = ( f b, b = b' )
, b )


fix:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f b, b = b' ) in f b
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' b' = ( f b, b = b' ) in f b
, b )


fix:
let fixpoint (f,b) = wwhile ( 
let f' = ( f, b = f b ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )


fix:
let f x = let xx = x*x*x in (xx, xx < 512)

bad:
let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fs a in
let base = fs x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs a in
let base = fs x in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fs a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs a in
let base = fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fs a x in
let base = fs a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs a x in
let base = fs a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fs a x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs a x in
let base = 0 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fs a in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs a in
let base = 0 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fs x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs x in
let base = 0 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'a in
List.fold_left f base fs


fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs y = 
let f a x = x a in
let base = y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x  in
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a + x a in
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a + x a in
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x + x a in
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x + x a in
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a -> x in
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a -> x in
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x', y -> x a + a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x', y -> x a + a


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' y -> x a + a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' y -> x a + a


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' y -> x a + a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' y -> x a + a


fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let base = fun x -> x  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a  in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x y -> y+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x y -> y+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x a  in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x y -> y+x); (fun x y -> x + y)] 3

annotated:
let _ = pipe [(fun x y -> y+x); (fun x y -> x + y)] 3


fix:
let pipe fs = 
let f a x = fun a -> x a  in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' y -> x a + a in
let base = fun x -> x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' y -> x a + a in
let base = fun x -> x  in
List.fold_left f base fs


fix:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] "corn"

bad:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] corn

annotated:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] corn


fix:
let cat = pipe []

bad:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] "corn"

annotated:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] "corn"


fix:
let cat = pipe []

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let cat = pipe []

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = sepConcat sep t in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l


fix:
let stringOfList f l = match l with
[] -> ""
| h::t -> 
let f' a x = x ^ a in
let base = f h in
let l = t in
List.fold_left f' base l

bad:
let stringOfList f l = match l with
[] -> ""
| h::t -> f h ^ stringOfList f t

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with
[] -> ""
| h::t -> f h ^ stringOfList f t


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fs a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a -> x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a -> x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a + x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a + x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x + x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x + x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a -> x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a -> x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y-> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a,x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a,x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let _ = pipe [] 3

bad:
let cat = pipe [(fun x -> x + x )] 3

annotated:
let cat = pipe [(fun x -> x + x )] 3


fix:
clone 0 5

bad:
List.append clone 0 5 a

annotated:
List.append clone 0 5 a


fix:
clone 0 5

bad:
List.append clone( 0 5 ) a

annotated:
List.append clone( 0 5 ) a


fix:
let rec padZero l1 l2 = 
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )

bad:
let rec padZero l1 l2 = 
if List.length l1 > List.length l2 then
( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )
else if List.length l1 < List.length l2 then
( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )
else
( l1, l2 )

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )
else if List.length l1 < List.length l2 then
( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )
else
( l1, l2 )


fix:
let rec padZero l1 l2 = 
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( List.append (clone 0 ( -1 * diffsize )) l1,  l2 )

bad:
let rec padZero l1 l2 = 
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( List.append clone 0 ( -1 * diffsize ) l1,  l2 )

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( List.append clone 0 ( -1 * diffsize ) l1,  l2 )


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )
| _ -> ( [], a )
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )
| _ -> ( [], a )
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = ([],[]) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = ([],[]) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = ([],[]) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = ([],[]) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x1, x2) -> match a with
(h1, h2::t2) -> let sum = x1 + x2 + h2 in
( ( sum / 10 ) , sum::( sum mod 10 )::t2)
in
let base = (0,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x1, x2) -> match a with
(_, h2::t2) ->
( ((x1 + x2 + h2) / 10 ) , (x1 + x2 + h2) / 10 )::(( x1 + x2 + h2 ) mod 10 )::t2

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (x1, x2) -> match a with
(_, h2::t2) ->
( ((x1 + x2 + h2) / 10 ) , (x1 + x2 + h2) / 10 )::(( x1 + x2 + h2 ) mod 10 )::t2


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x1, x2) -> match a with
(h1, h2::t2) -> let sum = x1 + x2 + h2 in
( ( sum / 10 ) , sum::( sum mod 10 )::t2)
in
let base = (0,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10 ** pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10 ** pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs = 
if xs = [] then 0
else let h::t = xs in
h + (sumList t)

bad:
let rec sumList xs = 
if (hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if (hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)


fix:
let rec sumList xs = 
if xs = [] then 0
else let h::t = xs in
h + (sumList t)

bad:
let rec sumList xs = 
if (xs hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if (xs hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)


fix:
let rec sumList xs = 
if xs = [] then 0
else let h::t = xs in
h + (sumList t)

bad:
let rec sumList xs = 
if (List.hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if (List.hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)


fix:
let rec digitsOfInt n = 
if (n mod 2 = 0) & (n > 0) then
let rec loop input =
if input = 0 then []
else (loop (input / 10))@[(input mod 10)]
in (loop n)
else []

bad:
let rec digitsOfInt n = 
if (n mod 2 = 0) and (n > 0) then
let rec loop input =
if input = 0 then []
else (loop (input / 10))@[(input mod 10)]
in (loop n)
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n mod 2 = 0) and (n > 0) then
let rec loop input =
if input = 0 then []
else (loop (input / 10))@[(input mod 10)]
in (loop n)
else []


fix:
let rec additivePersistence n = 
if (n / 10) = 0 then n
else additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if (n / 10) = 0 then n
else additivePersistence (sumList digits n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (n / 10) = 0 then n
else additivePersistence (sumList digits n)


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
if (List.hd w) = (List.tl w) then
let b::rest = w in
let c @ (x::[]) = rest in
palindrome x

annotated:
let palindrome : string -> bool = fun  w  ->  
if (List.hd w) = (List.tl w) then
let b::rest = w in
let c @ (x::[]) = rest in
palindrome x


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.size lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.size (palHelper wEx)) = 0 then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
let wEx = explode w in
let rec palHelper lst =
if (List.size lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.size (palHelper wEx)) = 0 then true
else false


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.tl lst) = (List.hd lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.tl lst) = (List.hd lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.tl lst) == (List.hd lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.tl lst) == (List.hd lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false


fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = (List.hd lst)) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = (List.hd lst)) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false


fix:
let rec digitsOfInt n = 
if (n mod 2 = 0) && (n > 0) then
let rec loop input =
if input < 10 then [input]
else let [y] = (loop (input / 10)) in
y::[(input mod 10)]
in loop n
else []

bad:
let rec digitsOfInt n = 
if (n mod 2 = 0) && (n > 0) then
let rec loop input =
if input < 10 then input
else (loop (input / 10))::[(input mod 10)]
in (loop n)
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n mod 2 = 0) && (n > 0) then
let rec loop input =
if input < 10 then input
else (loop (input / 10))::[(input mod 10)]
in (loop n)
else []


fix:
let fixpoint (f,b) = 
let y = (f b) in match y with
| (aPrime, _) -> 
if b = aPrime then b
else fixpoint (f, aPrime)

bad:
let fixpoint (f,b) = 
if b = (f b) then b
else fixpoint (f, f b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
if b = (f b) then b
else fixpoint (f, f b)


fix:
let fixpoint (f,b) = 
let y = (f b) in match y with
| (aPrime, _) -> 
if b = aPrime then b
else fixpoint (f, aPrime)

bad:
let fixpoint (f,b) = 
let y = f b in
if b = y then b
else fixpoint (f, y)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let y = f b in
if b = y then b
else fixpoint (f, y)


fix:
let fixpoint (f,b) = 
let y = (f b) in match y with
| (aPrime, _) -> 
if b = aPrime then b
else fixpoint (f, aPrime)

bad:
let fixpoint (f,b) = 
let y = f b in
if b = y then b
else fixpoint (f, y)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let y = f b in
if b = y then b
else fixpoint (f, y)


fix:
let fixpoint (f,b) = 
let y = (f b) in match y with
| (aPrime, _) -> 
if b = aPrime then b
else fixpoint (f, aPrime)

bad:
let fixpoint (f,b) = 
let y = (f b) in
if b = y then b
else fixpoint (f, y)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let y = (f b) in
if b = y then b
else fixpoint (f, y)


fix:
let fixpoint (f,b) = 
let y = (f b) in match y with
| (aPrime, _) -> 
if b = aPrime then b
else fixpoint (f, aPrime)

bad:
let fixpoint (f,b) = 
let y = (f b) in match y with
| aPrime -> 
if b = aPrime then b
else fixpoint (f, aPrime)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let y = (f b) in match y with
| aPrime -> 
if b = aPrime then b
else fixpoint (f, aPrime)


fix:
let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

bad:
let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0
| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0
| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )


fix:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in build(rand , y-1)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )


fix:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in build(rand , y-1)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then buildSine( build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then buildSine( build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in build(rand , y-1) 
if (y = 2) then buildSine( build(rand, depth-1) ) 
else 
if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in build(rand , y-1) 
if (y = 2) then buildSine( build(rand, depth-1) ) 
else 
if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then buildSine( build(rand, depth-1) ) 
else 
if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then buildSine( build(rand, depth-1) ) 
else 
if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y == 2 then buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y == 2 then buildX()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then 5

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then 5


fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
y


fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then y


fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if (y = 2) then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if (y = 2) then y


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then buildX()


fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then y


fix:
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then VarX else VarY
else
let y = rand(2,6) in
if y = 2 then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand(0,1) = 0 then VarX else VarY
else
let y = rand(2,6) in
if y = 2 then y


fix:
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand (0,1) = 0 then VarX else VarY
else
let y = rand (2,6) in
if y = 2 then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand (0,1) = 0 then VarX else VarY
else
let y = rand (2,6) in
if y = 2 then y


fix:
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
else
let y = rand (2,6) in
if y = 2 then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
else
let y = rand (2,6) in
if y = 2 then y


fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()

annotated:
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
if y = 2 then y

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
if y = 2 then y


fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()


fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in match y with
| 2 -> buildSine( build(rand, depth-1) ) 
| 3 -> buildCosine( build(rand, depth-1) )
| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )
| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )
| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

bad:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in match y with
| 2 -> buildSine( build(rand, depth-1) ) 
| 3 -> buildCosine( build(rand, depth-1) )
| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )
| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )
| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )  *

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in match y with
| 2 -> buildSine( build(rand, depth-1) ) 
| 3 -> buildCosine( build(rand, depth-1) )
| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )
| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )
| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )  *


fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x a) in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = h::t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x =  in
let base = "" in
let l = h in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x =  in
let base = "" in
let l = h in
List.fold_left f base l


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

string_of_int 5

annotated:
let _ = sepConcat "X" ["hello"]

string_of_int 5


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

string_of_int 5

annotated:
let _ = sepConcat "X" ["hello"]

string_of_int 5


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

string_of_int [1]

annotated:
let _ = sepConcat "X" ["hello"]

string_of_int [1]


fix:
let stringOfList f l = sepConcat "; " (List.append ("["::List.map f l) ["]"])

bad:
let stringOfList f l = sepConcat "; " ["["; List.map f l;"]"]

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "; " ["["; List.map f l;"]"]


fix:
let stringOfList f l = sepConcat "; " (List.append ("["::List.map f l) ["]"])

bad:
let stringOfList f l = sepConcat "; " [["["]; List.map f l;["]"]]

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "; " [["["]; List.map f l;["]"]]


fix:
let stringOfList f l = sepConcat "; " (List.append ("["::List.map f l) ["]"])

bad:
let stringOfList f l = sepConcat "; " (List.append ("["::List.map f l) "]")

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "; " (List.append ("["::List.map f l) "]")


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat "; " List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sepConcat "; " List.map f l) ^ "]"


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1+h2+r) in
helper ((sum%10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1+h2+r) in
helper ((sum%10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1+h2+r) in
helper ((sum % 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1+h2+r) in
helper ((sum % 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum % 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum % 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = (0 , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = (0 , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = (0 , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = (0 , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
([], helper [] 0 padded1 padded2)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
([], helper [] 0 padded1 padded2)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
([], helper [] 0 (List.rev padded1) (List.rev padded2))
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
([], helper [] 0 (List.rev padded1) (List.rev padded2))
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper (sum mod 10)::acc (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper (sum mod 10)::acc (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper (sum mod 10)::acc (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper (sum mod 10)::acc (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
([], helper [] 0 g)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
([], helper [] 0 g)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
([], helper [] 0 g)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
([], helper [] 0 g)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = (List.rev pad1 , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = (List.rev pad1 , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 -> []
else n mod 10 :: digitofInt n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 -> []
else n mod 10 :: digitofInt n/10


fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 then -> []
else n mod 10 :: digitofInt n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then -> []
else n mod 10 :: digitofInt n/10


fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsofInt n/10s


fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt n/10s


fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt n/10


fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else digitsOfInt (n/10):: n mod 10


fix:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []

bad:
let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []

annotated:
let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else digitsHelper n []


fix:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []

bad:
let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l

annotated:
let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l


fix:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []

bad:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l
in
if n<=0 then [] else digitsHelper n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l
in
if n<=0 then [] else digitsHelper n []


fix:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []

bad:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []


fix:
let rec digitalRoot n = 
let rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))
in
digHelper n

bad:
let rec digitalRoot n = 
let rec digHelper n = if n < 10 then n else digHelper (sumList n)
in
digHelper n

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
let rec digHelper n = if n < 10 then n else digHelper (sumList n)
in
digHelper n


fix:
let rec digitalRoot n = 
let rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))
in
digHelper n

bad:
let _ = digitalRoot 9876

annotated:
let _ = digitalRoot 9876


fix:
let rec listReverse l = 
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t (h::l2)
in
listHelper l []

bad:
let rec listReverse l = 
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t h::l2
in
listHelper l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t h::l2
in
listHelper l []


fix:
let rec listReverse l = 
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t (h::l2)
in
listHelper l []

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = 
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t (h::l2)
in
listHelper l []

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]

annotated:
let _ = listReverse ["a"; "b"; "c"; "d"]


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then true else assoc d k t

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| (s,i)::t -> if s = k then true else assoc d k t


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then true else assoc (d k t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| (s,i)::t -> if s = k then true else assoc (d k t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d k t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d k t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i) as h::t -> if s = k then i else assoc (d k t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| (s,i) as h::t -> if s = k then i else assoc (d k t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| ((s,i) as h)::t -> if s = k then i else assoc (d k t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| ((s,i) as h)::t -> if s = k then i else assoc (d k t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d k t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d k t)


fix:
let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)

bad:
let rec wwhile (f,b) = let snd (f b) then wwhile f fst (f b) else fst (f b)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  let snd (f b) then wwhile f fst (f b) else fst (f b)


fix:
let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)

bad:
let rec wwhile (f,b) = let snd f b then wwhile f fst f b else fst f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  let snd f b then wwhile f fst f b else fst f b


fix:
let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)

bad:
let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  if snd f b then wwhile f fst f b else fst f b


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if f b  ->  b then (true,b) else (false,b)),b)


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((f b)  ->  b, (f b)),b)


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = wwhile (f b, f b = b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f b, f b  ->  b,b)


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = 
wwhile(if f b = b then (f b, true) else (f b, false),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(if f b = b then (f b, true) else (f b, false),b)


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = 
wwhile((if f b = b then (f b, true) else (f b, false)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((if f b = b then (f b, true) else (f b, false)),b)


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = 
wwhile(let fx = if f b = b then (b,true) else (b,false),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(let fx = if f b = b then (b,true) else (b,false),b)


fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = 
wwhile((let fx = if f b = b then (b,true) else (b,false)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((let fx = if f b = b then (b,true) else (b,false)),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = let fx b= (f b, f b = b) in
wwhile(fx,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let fx b= (f b, f b  ->  b) in
wwhile(fx,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
)

annotated:
)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
let fx b = (f b, not (f b = b)) in
wwhile(fx,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let fx b = (f b, not (f b = b)) in
wwhile(fx,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(fun x = f x , not (f x = x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(fun x = f x , not (f x = x),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(fun x = f x , not (f x = x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(fun x = f x , not (f x = x),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(fun x -> f x , not (f x = x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(fun x -> f x , not (f x = x),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(fun x -> (f x , not (f x = x)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(fun x -> (f x , not (f x = x)),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((fun x -> f x , not (f x = x)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((fun x -> f x , not (f x = x)),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile(fun x -> f x  not (f x = x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile(fun x -> f x  not (f x = x),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((fun x -> f x  not (f x = x)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((fun x -> f x  not (f x = x)),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
wwhile((fun x -> f x , not (f x = x)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile((fun x -> f x , not (f x = x)),b)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average e1 e11 -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average e1 e11 -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times (e1,e2) -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh (e1,e2,e3,e4) -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times (e1,e2) -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh (e1,e2,e3,e4) -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi .* exprToString e1)
| Cosine e1 -> cos(pi .* exprToString e1)
| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)
| Times (e1,e2) -> exprToString e1 .* exprToString e2 
| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi .* exprToString e1)
| Cosine e1 -> cos(pi .* exprToString e1)
| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)
| Times (e1,e2) -> exprToString e1 .* exprToString e2 
| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. exprToString e1)
| Cosine e1 -> cos(pi *. exprToString e1)
| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)
| Times (e1,e2) -> exprToString e1 *. exprToString e2 
| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. exprToString e1)
| Cosine e1 -> cos(pi *. exprToString e1)
| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)
| Times (e1,e2) -> exprToString e1 *. exprToString e2 
| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y):eval (e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y):eval (e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : (eval(e4,x,y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : (eval(e4,x,y)))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> ((eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> ((eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y)))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
eval

annotated:
eval


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = let n = 
if (depth < 1) then rand (0,2) else rand(2,7)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  
if (depth < 1) then rand (0,2) else rand(2,7)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = let n = 
if (depth < 1) then rand (0,2) else rand(2,7)
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  
if (depth < 1) then rand (0,2) else rand(2,7)
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = let n = 
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
in if (depth < 1) then rand (0,2) else rand(2,7)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
in if (depth < 1) then rand (0,2) else rand(2,7)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
let n = 
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
in n = if (depth < 1) then rand (0,2) else rand(2,7)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let n = 
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
in n = if (depth < 1) then rand (0,2) else rand(2,7)


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
let n = if (depth < 1) then rand (0,2) else rand(2,7)
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let n = if (depth < 1) then rand (0,2) else rand(2,7)
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
let n = if (depth < 1) then match rand(0,2) with else match rand(2,7) with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let n = if (depth < 1) then match rand(0,2) with else match rand(2,7) with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
let n = if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let n = if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
let num = if (depth < 1) rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let num = if (depth < 1) rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)


fix:
let pipe fs = 
let f a x = x a in
let base =  1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a + f x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a + f x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a + f x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a + f x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a + x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a + x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = x a in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = x a in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = x a in
let base = 0 in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = x a in
let base = 0 in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = f (a y) in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = f (a y) in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = x (a y) in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = x (a y) in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = x a in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = x a in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = fun x a -> x a in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = fun x a -> x a in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = fun x a t-> x (a t) in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = fun x a t-> x (a t) in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = (fun x y -> x (a y)) in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = (fun x y -> x (a y)) in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = fun y ->  x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a = fun y ->  x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = fun y ->  x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = fun y ->  x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  x a


fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun y -> x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x =  fun y -> x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let a = x a in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let a = x a in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun y -> x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a x in 
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a x in 
let base = fun x -> x in 
List.fold_left f base fs


fix:
let stringOfList f l = "[" ^ (sepConcat ";" (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ List.map sepConcat ";" l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ List.map sepConcat ";" l ^ "]"


fix:
let stringOfList f l = "[" ^ (sepConcat ";" (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ sepConcat ";" List.map f l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ sepConcat ";" List.map f l ^ "]"


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper x n-1 x::acc in
cloneHelper x n []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper x n-1 x::acc in
cloneHelper x n []


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper x n []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper x n []


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper x n []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper x n []


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper (x ,n,[])

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper (x ,n,[])


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper (x,n,[])

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper (x,n,[])


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = if n < 0 then [] else clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then [] else clone x n-1


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = if n < 0 then [] else clone (x,n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then [] else clone (x,n-1)


fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let clone : 'a -> int -> 'a list = fun  x n  ->  if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append ((clone 0 (abs diff)) l1)
else if (diff > 0) then List.append ((clone 0 diff) l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append ((clone 0 (abs diff)) l1)
else if (diff > 0) then List.append ((clone 0 diff) l2)


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append ((clone 0 (abs diff)),l1)
else if (diff > 0) then List.append ((clone 0 diff),l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append ((clone 0 (abs diff)),l1)
else if (diff > 0) then List.append ((clone 0 diff),l2)


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)
else if (diff > 0) then (l1,List.append ((clone 0 diff),l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)
else if (diff > 0) then (l1,List.append ((clone 0 diff),l2))


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)
else if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)
else if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1


fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else if (diff > 0) then l1 else l1

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else if l2 else l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else if l2 else l1


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) mod 10 in
(sum/10, sum mod 10) in
let base = (0,0) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res::[] 
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + (fst x + snd x) mod 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + (fst x + snd x) mod 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) mod 10 in
(sum/10, sum mod 10) in
let base = (0,0) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res::[] 
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) mod 10 in
(sum/10, sum mod 10) in
let base = (0,0) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) mod 10 in
(sum/10, sum mod 10) in
let base = (0,0) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero 0::l1 0::l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.reverse l1) (List.reverse l2) in
let (_, res) = List.fold_left f base args in
List.reverse res
in 
removeZero (add (padZero 0::l1 0::l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.reverse l1) (List.reverse l2) in
let (_, res) = List.fold_left f base args in
List.reverse res
in 
removeZero (add (padZero 0::l1 0::l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero 0::l1 0::l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.reverse res
in 
removeZero (add (padZero 0::l1 0::l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.reverse res
in 
removeZero (add (padZero 0::l1 0::l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero (0::l1) (0::l2)))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero (0::l1) (0::l2))

let _ = bigAdd [5;1] [5;4]

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero (0::l1) (0::l2))

let _ = bigAdd [5;1] [5;4]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero (0::l1) (0::l2)))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero (0:l1) (0:l2)))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero (0:l1) (0:l2)))


fix:
let bigMul l1 l2 = 
let f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = 
if n < 1 then []
else n mod 10 :: digitsOfInt(n/10)

bad:
let rec digitsOfInt n = match n with
| n < 1 -> []
| n mod 10 :: digitsofInt(n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| n < 1 -> []
| n mod 10 :: digitsofInt(n/10)


fix:
let rec digitsOfInt n = 
if n < 1 then []
else n mod 10 :: digitsOfInt(n/10)

bad:
let rec digitsOfInt n = match n with
if n < 1 then []
else n mod 10 :: digitsofInt(n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
if n < 1 then []
else n mod 10 :: digitsofInt(n/10)


fix:
let rec digitsOfInt n = 
if n < 1 then []
else n mod 10 :: digitsOfInt(n/10)

bad:
let rec digitsOfInt n = 
if n < 1 then []
else n mod 10 :: digitsofInt(n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 1 then []
else n mod 10 :: digitsofInt(n/10)


fix:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if digitsOfInt(n).length = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if digitsOfInt(n).length = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))


fix:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if List.length digitsOfInt(n) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if List.length digitsOfInt(n) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))


fix:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length digitsOfInt(n)) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length digitsOfInt(n)) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))


fix:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))


fix:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
inc count
additivePersistence(addList(digitsOfInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
inc count
additivePersistence(addList(digitsOfInt(n)))


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
incr count
additivePersistence(addList(digitsOfInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
incr count
additivePersistence(addList(digitsOfInt(n)))


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
incr(count)
additivePersistence(addList(digitsOfInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
incr(count)
additivePersistence(addList(digitsOfInt(n)))


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else (
incr(count)
additivePersistence(addList(digitsOfInt(n)))
)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else (
incr(count)
additivePersistence(addList(digitsOfInt(n)))
)


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else (
incr(count)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else (
incr(count)


fix:
addList[1;2;3;4]

bad:
additivePersistence(addList(digitsOfInt(n)))
)

annotated:
additivePersistence(addList(digitsOfInt(n)))
)


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
incr(count)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
incr(count)


fix:
addList[1;2;3;4]

bad:
additivePersistence(addList(digitsOfInt(n)))

annotated:
additivePersistence(addList(digitsOfInt(n)))


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
count = count + 1
additivePersistence(addList(digitsOfInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
count = count + 1
additivePersistence(addList(digitsOfInt(n)))


fix:
addList[1;2;3;4]

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
let count = count + 1
additivePersistence(addList(digitsOfInt(n)))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
let count = count + 1
additivePersistence(addList(digitsOfInt(n)))


fix:
let rec addList (f,xs) = match xs with
| [] -> 0
| h::t -> h+ addList(f,t)

bad:
addList digitsOfInt 5

annotated:
addList digitsOfInt 5


fix:
let rec addNum n = 
if n < 10 then n
else 
addList(digitsOfInt(n))

bad:
let rec addNum = match n with
if n < 10 then n
else 
addList(digitsOfInt(n))

annotated:
let rec addNum = match n with
if n < 10 then n
else 
addList(digitsOfInt(n))


fix:
let rec addNum n = 
if n < 10 then n
else 
addList(digitsOfInt(n))

bad:
let rec addNum = 
if n < 10 then n
else 
addList(digitsOfInt(n))

annotated:
let rec addNum = 
if n < 10 then n
else 
addList(digitsOfInt(n))


fix:
let rec addList xs = match xs with
| [] -> 0
| h::t -> h + addList t

bad:
let rec additivePersistence n = 
let count = 0 in 
if n < 10 then
count + 1
else 
let count = count + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 0 in 
if n < 10 then
count + 1
else 
let count = count + 1


fix:
let palindrome w = 
let l = explode w in
if listReverse(l) = l then
true
else
false

bad:
let palindrome w = 
let l = explode s in
if listReverse(l) = l then
true
else
false

annotated:
let palindrome : string -> bool = fun  w  ->  
let l = explode s in
if listReverse(l) = l then
true
else
false


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' =
if List.mem h seen
then
seen
else
h::seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' =
if List.mem h seen
then
seem
else
h::seem
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' =
if List.mem h seen
then
seem
else
h::seem
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
 rec wwhile (f,b) = 
let f b = x, y in 
if y = true 
then wwhile (f, x)
else x

annotated:
 rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = x, y in 
if y = true 
then wwhile (f, x)
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
 rec wwhile (f,b) = 
let f b = (x, y) in 
if y = true 
then wwhile (f, x)
else x

annotated:
 rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = (x, y) in 
if y = true 
then wwhile (f, x)
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f(b) = (x, y) in 
if y = true 
then wwhile (f, x)
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f(b) = (x, y) in 
if y = true 
then wwhile (f, x)
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f(b) = (x, y) in 
if x = true 
then wwhile (f, x)
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f(b) = (x, y) in 
if x = true 
then wwhile (f, x)
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f(b) = (b', c') in 
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f(b) = (b', c') in 
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f(b) = b', c' in 
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f(b) = b', c' in 
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f b = b', c' in 
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = b', c' in 
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f b = q, x in 
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = q, x in 
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f b = q, x 
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = q, x 
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f b = q, x in  
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = q, x in  
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
let rec wwhile (f,b) = 
let f b = w in  
if c' = true 
then wwhile (f, b')
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b = w in  
if c' = true 
then wwhile (f, b')
else x


fix:
let rec wwhile (f,b) = 
let b', c' = f b in  
if c' = true 
then wwhile (f, b')
else b'

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' = fun b'
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' = fun b'
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' = fun b' = 
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' = fun b' = 
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let fun f' b' =  
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let fun f' b' =  
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' b' =  function
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f' b' =  function
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)


fix:
let rec exprToString e = match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine e1	  -> "(sin"^ exprToString e1 ^")"
| Cosine e1	  -> "(cos"^exprToString e1 ^ ")"
| Average (e1, e2)-> "("^ exprToString e1 ^"+" ^ exprToString e2 ^ ")/2"
| Times (e1, e2)  -> "("^ exprToString e1 ^"*"^exprToString e2 ^")"
| Thresh (e1, e2, e3, e4) -> "("^ exprToString e1 ^ "<" ^ exprToString e2 ^ ")?("^ exprToString e3 ^ "):("^exprToString e4 ^ ")"

bad:
exprToString (Sine(VarX))

annotated:
exprToString (Sine(VarX))


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e))


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e1))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e1))


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1, x, y)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))


fix:
let pi = 4.0 *. atan 1.0

bad:
let pi = 4.0 *. atan 1.0

(* eval : expr -> float * float -> float 
Evaluator for expressions in x and y *)
1<2?3:4

annotated:
let pi = 4.0 *. atan 1.0

(* eval : expr -> float * float -> float 
Evaluator for expressions in x and y *)
1<2?3:4


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if 
eval(e1, x, y) < eval(e2, x, y)
then
eval(e3, x, y)
else
eval(e4, x, y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if 
(eval(e1, x, y) < eval(e2, x, y) )
then
eval(e3, x, y)
else
eval(e4, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if 
(eval(e1, x, y) < eval(e2, x, y) )
then
eval(e3, x, y)
else
eval(e4, x, y)


fix:
let pipe fs = 
let f a x = (x a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = g x->x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x a) in
let base = g x->x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun q -> x(a(q)) in
let base = fun g q -> q in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x (n-1))

bad:
let rec clone x n =  
| 0 -> []
| _ -> x::clone n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->   
| 0 -> []
| _ -> x::clone n-1


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x (n-1))

bad:
let rec clone x n = match n with
| 0 -> []
| _ -> x::clone n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| _ -> x::clone n-1


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x (n-1))

bad:
let rec clone x n = match n with
| 0 -> []
| _ -> x::clone (x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| _ -> x::clone (x n-1)


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x (n-1))

bad:
let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| _ -> x::(clone x n-1)


fix:
let padZero l1 l2 =
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 (lenl1-lenl2))@l2)
else ((clone 0 (lenl2-lenl1))@l1, l2)

bad:
let padZero l1 l2 =
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 lenl1-lenl2)@l2)
else ((clone 0 lenl2-lenl1)@l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 lenl1-lenl2)@l2)
else ((clone 0 lenl2-lenl1)@l1, l2)


fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [0;0;0;0]

*

annotated:
let _ = removeZero [0;0;0;0]

*


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a in
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> new_carry, digit::y

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rem = match a in
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> new_carry, digit::y


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
) in

let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
) in

let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> new_carry, digit::y

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> new_carry, digit::y


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
) in

let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
) in

let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, (norm_sum::y)) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::y)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::y)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, (norm_sum::y)) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, (norm_sum::y)) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec removeZero l = match l with
| []      -> []
| h::t    -> 
if h = 0 
then removeZero(t)
else h::t

bad:
let rec removeZero l = match l with
| []      -> []
| h::t    -> 
if h = 0 
then removeZero(t)
else h::t

List.combine([1;2] [3;4])

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| []      -> []
| h::t    -> 
if h = 0 
then removeZero(t)
else h::t

List.combine([1;2] [3;4])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in
if ((List.length acc) = (List.length l1)) || (List.length acc = List.length l2)
then if rem = 1
then (0, 1::acc) 
else (0, acc)
else
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in
if (acc.length = l1.length) || (acc.length = l2.length)
then if rem = 1
then (0, 1::acc) 
else (0, acc)
else
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in
if (acc.length = l1.length) || (acc.length = l2.length)
then if rem = 1
then (0, 1::acc) 
else (0, acc)
else
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZ

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZ


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, norm_sum::acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, norm_sum@acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, norm_sum@acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = match i with
| 1 -> l
| _ -> bigAdd (mulByDigit (i-1) l) l

bad:
let rec mulByDigit i l = match i with
| 0 -> l
| _ -> bigAdd (mulByDigit i-1) l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match i with
| 0 -> l
| _ -> bigAdd (mulByDigit i-1) l


fix:
let rec mulByDigit i l = match i with
| 1 -> l
| _ -> bigAdd (mulByDigit (i-1) l) l

bad:
let rec mulByDigit i l = match i with
| 1 -> l
| _ -> bigAdd (mulByDigit i-1) l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match i with
| 1 -> l
| _ -> bigAdd (mulByDigit i-1) l


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (bigAdd (mulByDigit x l1) a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (bigAdd (mulByDigit x l1) a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (bigAdd (mulByDigit x l1) a) in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (bigAdd (mulByDigit x l1) a) in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, acc) = a in
(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, acc) = a in
(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (place, acc) = a in
(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else if n mod 10 = 0 then 0::digitsOfInt (n/10)
else if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 then []
else if n mod 10 = 0 then 0::digitsOfInt (n/10)
else if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else if n mod 10 = 0 then 0::digitsOfInt (n/10)
else if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 then []
else if n mod 10 = 0 then 0::digitsOfInt (n/10)
else if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList) in
match n with
| 0 -> [0]
| _ -> digits n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList) in
match n with
| 0 -> [0]
| _ -> digits n []

bad:
) in
match n with
| 0 -> [0]
| _ -> digits n []

annotated:
) in
match n with
| 0 -> [0]
| _ -> digits n []


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList) in
match n with
| 0 -> [0]
| _ -> digits n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList) in
match n with
| 0 -> [0]
| _ -> digits n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList) in
match n with
| 0 -> [0]
| _ -> digits n []

bad:
) in
match n with
| 0 -> [0]
| _ -> digits n []

annotated:
) in
match n with
| 0 -> [0]
| _ -> digits n []


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| (h::t) -> if h = (k,'a) then 'a else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| []     -> d
| (h::t) -> if h = (k,'a) then 'a else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| (h::t) -> if h = (k * 'a) then 'a else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| []     -> d
| (h::t) -> if h = (k * 'a) then 'a else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| (h::t) -> if h = [k,'a] then 'a else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| []     -> d
| (h::t) -> if h = [k,'a] then 'a else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| (('a,'b)::t) -> if 'a = k then 'b else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| []     -> d
| (('a,'b)::t) -> if 'a = k then 'b else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile (let a = (f b, b = f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let a = (f b, b  ->  f b),b)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile ((f b, b = f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, b  ->  f b),b)


fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)

bad:
let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g = let bb = f b in (bb, bb  ->  b) in g, b)


fix:
let rec exprToString e = match e with
| VarX -> x

bad:
let rec exprToString e = match e with
| VarX x -> Printf.printf "%s" x

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX x -> Printf.printf "%s" x


fix:
let rec build (rand, depth) = 
if depth = 0 then 
match rand mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
match rand (i,j) mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand (i,j) mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
match rand (i,j) mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand (i,j) mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))


fix:
let rec build (rand, depth) = 
if depth = 0 then 
match rand mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
match rand mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
match rand mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| [] -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> sqsum (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| []     -> a
| (h::t) -> sqsum (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> f a+(h*h) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| []     -> a
| (h::t) -> f a+(h*h) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (a + (x*x)) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x*x


fix:
let sqsum xs = 
let f a x = (a + (x*x)) in
let base = 0 in
List.fold_left f base xs

bad:
let base = 0 in
List.fold_left f base xs

annotated:
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x 'a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x 'a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x 'a in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x 'a in
let base = 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'a in
List.fold_left f base fs


fix:
let pipe fs num = 
let f a x = x a in
let base = num in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = b in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun 'a -> fs 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun 'a -> fs 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun a -> fs a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun a -> fs a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun (fun y)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun (fun y)


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 'b in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = int in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = int in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = let base = x in fun x -> fun2 (fun1 base)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  = let base  ->  x in fun x -> fun2 (fun1 base)


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let _ = pipe 3

annotated:
let _ = pipe 3


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = let base = fun x in fun x -> fun2 (fun1 base)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  = let base  ->  fun x in fun x -> fun2 (fun1 base)


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let _ = pipe 3

annotated:
let _ = pipe 3


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = let base =  in fun x -> fun2 (fun1 base)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  = let base  ->   in fun x -> fun2 (fun1 base)


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let _ = pipe 3

annotated:
let _ = pipe 3


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe fs = 
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun2 (fun1 base)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 base)


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let _ = pipe 3

annotated:
let _ = pipe 3


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe fs = 
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = p -> p in
List.fold_left f base fs


fix:
let _ = pipe fun1 fun2 3

bad:
let _ = pipe fun1 fun2

annotated:
let _ = pipe fun1 fun2


fix:
let _ = pipe fun1 fun2 3

bad:
let _ = pipe fun1 fun2 3

annotated:
let _ = pipe fun1 fun2 3


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun2 fun1

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun2 fun1


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun2 fun1

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 fun1


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun2 fun1 x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 fun1 x


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun2 x -> (fun1 x)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x -> (fun1 x)


fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun2 x (fun1 x)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x (fun1 x)


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let rec pipe fs = 
match fs with
| [] -> 0
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
let fsrev = List.rev fs in
match fsrev with
| [] -> x -> x
| (h::t) -> h (pipe t)

annotated:
let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let fsrev = List.rev fs in
match fsrev with
| [] -> x -> x
| (h::t) -> h (pipe t)


fix:
let rec pipe fs = 
match fs with
| [] -> 0
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
let fsrev = List.rev fs in
match fsrev with
| [x] -> x 
| (h::t) -> h (pipe t)

annotated:
let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let fsrev = List.rev fs in
match fsrev with
| [x] -> x 
| (h::t) -> h (pipe t)


fix:
let rec pipe fs = 
match fs with
| [] -> 0
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
match fs with
| [x] -> x 
| (h::t) -> h (pipe t)

annotated:
let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with
| [x] -> x 
| (h::t) -> h (pipe t)


fix:
let rec pipe fs = 
match fs with
| [] -> 0
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
match fs with
| [x] -> x 
| (h::t) -> h (pipe t)

annotated:
let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with
| [x] -> x 
| (h::t) -> h (pipe t)


fix:
let rec pipe fs = 
match fs with
| [] -> 0
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
match fs with
| [] -> x 
| (h::t) -> h (pipe t)

annotated:
let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with
| [] -> x 
| (h::t) -> h (pipe t)


fix:
let rec pipe fs = 
match fs with
| [] -> fun x -> x
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
match fs with
| [] -> fun
| (h::t) -> h (pipe t)

annotated:
let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with
| [] -> fun
| (h::t) -> h (pipe t)


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a _) in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x (a _) in
let base = fun y -> y in
List.fold_left f base fs


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = List.map f sepConcat l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f sepConcat l


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = sepConcat (List.map f)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (List.map f)


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = sepConcat "; " (List.map f)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "; " (List.map f)


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let _ = padZero [9;9] [1;2]

bad:
let _ padZero [9;9] [1;2]

annotated:
let _ padZero [9;9] [1;2]


fix:
let pipe fs p = 
let f a x = x a in
let base = p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = let p = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = let p = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs p = 
let f a x = x a in
let base = p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = let p = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = let p = fun x -> x in
List.fold_left f base fs


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let prevN (n1, n2) = n1 in
let prev = prevN a in
let sumlist (p1, p2) = p2 in
let sum = sumlist a in
let add (m,n) = m + n in
let digit = (add x) + prev in
if digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let prevN (n1, n2) in
let prev = prevN a in
let sumlist (p1, p2) = p2 in
let sum = sumlist a in
let add (m,n) = m + n in
let digit = (add x) + prev in
if digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let prevN (n1, n2) in
let prev = prevN a in
let sumlist (p1, p2) = p2 in
let sum = sumlist a in
let add (m,n) = m + n in
let digit = (add x) + prev in
if digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigMul [1] [0]

bad:
let _ bigMul [1] [0]

annotated:
let _ bigMul [1] [0]


fix:
let rec digitsOfInt n =
if n < 0 then []
else n :: digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> digitsOfInt n :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else a :: [] -> digitsOfInt n :: []


fix:
let rec digitsOfInt n =
if n < 0 then []
else n :: digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> digitsOfInt n :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else a :: [] -> digitsOfInt n :: []


fix:
let rec digitsOfInt n =
if n < 0 then []
else n :: digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> digitsOfInt n :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else a :: [] -> digitsOfInt n :: []


fix:
let rec digitsOfInt n =
if n < 0 then []
else n :: digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> a :: digitsOfInt n

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else a :: [] -> a :: digitsOfInt n


fix:
let rec digitsOfInt n =
if n < 0 then []
else n :: digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else a :: digitsOfInt n

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else a :: digitsOfInt n


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

bad:
let rec digitsOfInt n =
if n < 0 then []
else n%10

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else n%10


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

bad:
let rec digitsOfInt n =
if n < 0 then []
else n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else n mod 10


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

bad:
let rec digitsOfInt n =
if n < 0 then []
else h:: digitsOfInt n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else h:: digitsOfInt n mod 10


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

bad:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else digitsOfInt n mod 10


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

bad:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10) mod 10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else digitsOfInt (n/10) mod 10 :: []


fix:
let _ = digitsOfInt 98*-1

bad:
let _ = digitsOfInt 98

annotated:
let _ = digitsOfInt 98


fix:
let digitsOfInt n = 
if n < 0 then []
else
let rec digit n acc =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n

bad:
let _ = digitsOfInt -9

annotated:
let _ = digitsOfInt -9


fix:
let digitsOfInt n = 
if n < 0 then []
else
let rec digit n acc =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n

bad:
let _ = digitsOfInt ~-9

annotated:
let _ = digitsOfInt ~-9


fix:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []

bad:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
digit [] n

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
digit [] n


fix:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []

bad:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
n [] digit

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
n [] digit


fix:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []

bad:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
digit [] digit

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
digit [] digit


fix:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []

bad:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []


fix:
let _ = additivePersistence 9876

bad:
let additivePersistence n =
if n < 10 then 0  
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1

annotated:
let additivePersistence : int -> int = fun  n  -> 
if n < 10 then 0  
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1


fix:
let _ = additivePersistence 9876

bad:
let additivePersistence n =
if n < 10 then 0  
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

annotated:
let additivePersistence : int -> int = fun  n  -> 
if n < 10 then 0  
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n


fix:
let rec digitalRoot n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot(n/10)

bad:
let rec digitalRoot n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot(n/10)

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if n <= 0 then 0
else (n mod 10) + digitalRoot(n/10)


fix:
let _ = digitalRoot 9876

bad:
let digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digits(n/10)

annotated:
let digitalRoot : int -> int = fun  n  ->  
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digits(n/10)


fix:
let _ = digitalRoot 9876

bad:
let digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot (n/10)

annotated:
let digitalRoot : int -> int = fun  n  ->  
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot (n/10)


fix:
let _ = digitalRoot 9876

bad:
let digitalRoot n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot (n/10)

annotated:
let digitalRoot : int -> int = fun  n  ->  
if n <= 0 then 0
else (n mod 10) + digitalRoot (n/10)


fix:
let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

bad:
let rec digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digits (n/10) in
let x = digits n in 
if x > 9 then digitalRoot x
else x in digitalRoot n

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digits (n/10) in
let x = digits n in 
if x > 9 then digitalRoot x
else x in digitalRoot n


fix:
let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

bad:
let rec digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in 
if x > 9 then digitalRoot x
else x in digitalRoot n

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in 
if x > 9 then digitalRoot x
else x in digitalRoot n


fix:
let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

bad:
let rec digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in 
if x > 9 then digitalRoot x
else 1 in digitalRoot x

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in 
if x > 9 then digitalRoot x
else 1 in digitalRoot x


fix:
let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

bad:
let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

annotated:
let digitalRoot : int -> int = fun  n  -> 
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> []
| hd::l' -> 1 + listReverse l'

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| hd::l' -> 1 + listReverse l'


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> 0
| hd::l' -> 1 + listReverse l'

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> 0
| hd::l' -> 1 + listReverse l'


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> 0
| _::tl -> 1 + listReverse tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> 0
| _::tl -> 1 + listReverse tl


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse _ + tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| _::tl -> listReverse _ + tl


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl + tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| _::tl -> listReverse tl + tl


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| 0 -> []
| _::tl -> listReverse tl + tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| 0 -> []
| _::tl -> listReverse tl + tl


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl + tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| _::tl -> listReverse tl + tl


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| _::tl -> listReverse tl


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper tl l = match l with
| [] -> []
| _::tl -> reverseHelper tl l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper tl l = match l with
| [] -> []
| _::tl -> reverseHelper tl l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper l tl = match l with
| [] -> []
| _::t -> reverseHelper t l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper l tl = match l with
| [] -> []
| _::t -> reverseHelper t l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l =
match l with
| [] -> []
| hd::l -> listReverse l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| hd::l -> listReverse l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper acc = 
if [] then acc
else reverseHelper (h::acc) t in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper acc = 
if [] then acc
else reverseHelper (h::acc) t in
reverseHelper [] l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper acc = 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper acc = 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper acc = match acc with 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper acc = match acc with 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper acc = function
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper acc = function
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
if explode w = listReverse w then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if explode w = listReverse w then true
else false


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
if explode w = listReverse (explode w) then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if explode w = listReverse (explode w) then true
else false


fix:
let _ = palindrome "_"

bad:
let _ = palindrome ""

annotated:
let _ = palindrome ""


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper acc = function 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverseHelper acc = function 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l


fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
(*let rec reverseHelper acc = function 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l *)
let rec reverseHelper ln lo =
match ln with
| [] -> lo
| h::t -> reverseHelper t (h::lo) in
reverseHelper l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
(*let rec reverseHelper acc = function 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l *)
let rec reverseHelper ln lo =
match ln with
| [] -> lo
| h::t -> reverseHelper t (h::lo) in
reverseHelper l []


fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = [] in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a + x in
let base = [] in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a + x in
let base = a in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = fun y -> y |> a |> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun inner -> y |> a |> x in
let base = fun y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun inner -> y |> a |> x in
let base = fun y -> y in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^a in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^a t in
let base = h in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^a t in
let base = h in
let l = sl in
List.fold_left f base l


fix:
let stringOfList f l = List.map f l

bad:
let stringOfList f l = in List.map f sepConcat " " l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  in List.map f sepConcat " " l


fix:
let stringOfList f l = sepConcat "[" (List.map f l)

bad:
let stringOfList f l = sepConcat "[" List.map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "[" List.map f l


fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = sepConcat "; " List.map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "; " List.map f l


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

bad:
let padZero l1 l2 = 
let f a l = a+1 l in 
let base = a
in List.fold_left f base

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let f a l = a+1 l in 
let base = a
in List.fold_left f base


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in
if length1 < length2 then true
else false

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in
if length1 < length2 then true
else false


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2-length1) 0 
else if length2 < length1
then clone (length1-length2) 0

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2-length1) 0 
else if length2 < length1
then clone (length1-length2) 0


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2 - length1) 0 
else if length2 < length1
then clone (length1-length2) 0

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2 - length1) 0 
else if length2 < length1
then clone (length1-length2) 0


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2 - length1) 0 
else if length2 < length1
then clone (length1 - length2) 0

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2 - length1) 0 
else if length2 < length1
then clone (length1 - length2) 0


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone 0 (length2 - length1) 
else if length2 < length1
then clone 0 (length1 - length2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone 0 (length2 - length1) 
else if length2 < length1
then clone 0 (length1 - length2)


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1) in
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1) in
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1) in
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1) in
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1)
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1)
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1


fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1)
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1)
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1


fix:
let rec removeZero l = match l with
| [] -> l
| x::l' -> 
if x=0 
then removeZero l'
else l

bad:
let rec removeZero l = match l with
| [] -> 0
| x::l' -> if x = 0
then List.fold_left (fun acc x -> acc+1) 0 l

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| [] -> 0
| x::l' -> if x = 0
then List.fold_left (fun acc x -> acc+1) 0 l


fix:
let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(carry+1, result) in
let base =  (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(i+1, result) in
let base =  in
let args = in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(i+1, result) in
let base =  in
let args = in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(carry+1, result) in
let base =  (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(i+1, result) in
let base =  (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(i+1, result) in
let base =  (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)

bad:
let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with [] -> 0 | f::b -> f + sumList List.tl xs


fix:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)

bad:
let rec digitsOfInt n = if n<0 [] else match n with f::b -> f

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 [] else match n with f::b -> f


fix:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)

bad:
let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 then [] else match n with f::b -> f


fix:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)

bad:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 then [] else (n mod 10)::digitsOfInt n*10


fix:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)

bad:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 then [] else (n mod 10)::(digitsOfInt n*10)


fix:
let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))

bad:
let rec persistenceHelper q = let x = sumList q in

annotated:
let rec persistenceHelper q = let x = sumList q in


fix:
let _ = additivePersistence 9876

bad:
let _ = additivePersistence -9876

annotated:
let _ = additivePersistence -9876


fix:
let _ = additivePersistence 9

bad:
let _ = additivePersistence -9876

annotated:
let _ = additivePersistence -9876


fix:
let _ = digitalRoot (-45)

bad:
let _ = digitalRoot -4

annotated:
let _ = digitalRoot -4


fix:
let _ = digitalRoot (-45)

bad:
let _ = digitalRoot -434

annotated:
let _ = digitalRoot -434


fix:
let _ = digitalRoot 459

bad:
let _ = digitalRoot -459

annotated:
let _ = digitalRoot -459


fix:
let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false

bad:
let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false

annotated:
let palindrome : string -> bool = fun  w = let x = listReverse (explode w) in if(x -> (explode (w))) then true esle false


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen' then seen' else h::seen' in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen' then seen' else h::seen' in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true) ),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = if (f x) ->  x then (x,false) else (f x,true) ),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = if (f x) ->  x then (x,false) else (f x,true)),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else (f x,true))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if (f x) ->  x then (x,false) else (f x,true))),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else ((f x),true))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if (f x) ->  x then (x,false) else ((f x),true))),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if ((f x) ->  x) then (x,false) else (f x,true))),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (((if ((f x)= x) then (x,false) else (f x,true))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((if ((f x) ->  x) then (x,false) else (f x,true))),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if ((f x) ->  x) then (x,false) else (f x,true)) in func x),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if ((f x) ->  x) then (x,false) else (f x,true)) in func),b)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times ex1 ex2 -> ex1^"*"^ex2
| Thresh ex1 ex2 ex3 ex4 -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times ex1 ex2 -> ex1^"*"^ex2
| Thresh ex1 ex2 ex3 ex4 -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> ex1^"*"^ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> ex1^"*"^ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. exprToString ex )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. exprToString ex )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. eval ex )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. eval ex )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. eval ex x y )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. eval ex x y )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex x y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex x y) )


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)? eval (ex3,x,y): eval (ex4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)? eval (ex3,x,y): eval (ex4,x,y))


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)?eval (ex3,x,y): eval (ex4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)?eval (ex3,x,y): eval (ex4,x,y))


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval(ex1,x,y)<eval(ex2,x,y) ? eval(ex3,x,y):eval(ex4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval(ex1,x,y)<eval(ex2,x,y) ? eval(ex3,x,y):eval(ex4,x,y))


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y)


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y):eval(ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y):eval(ex4,x,y)


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y) : eval(ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y) : eval(ex4,x,y)


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
)

annotated:
)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
 rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) 
else let case = rand(0,6)in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then (let case  ->  rand(0,1)) 
else let case = rand(0,6)in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then (let case = rand(0,1)) else let case  ->  rand(0,6)in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = (if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = (if depth= 0 then (let case = rand(0,1)) else let case  ->  rand(0,6)) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) in  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then let case = rand(0,1) in  else let case  ->  rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1) in)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then (let case = rand(0,1) in)  else let case  ->  rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = let case = 0 in if depth= 0 then ( case = rand(0,1) in

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then ( case  ->  rand(0,1) in


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1) in  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1) in  else let case  ->  rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case  ->  rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case  ->  rand(0,6) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then let case = rand(0,1) else let case  ->  rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = let case = rand(0,6)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = let case = rand(0,6)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = let case = rand(0,6)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = let case = rand(0,6)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> VarX
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> VarX
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = let case = rand(0,6)

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = let case = rand(0,6)

bad:
let rec build (rand, depth) = let case = rand(0,6) in 
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6) in 
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = if depth=0 then(
match rand(0,5) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,0) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = let case = rand(0,6)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)


fix:
let rec build (rand, depth) = if depth=0 then(
match rand(0,5) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,0) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

annotated:
let if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))


fix:
let rec build (rand, depth) = if depth=0 then(
match rand(0,5) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,0) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = if depth=0 then(
match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth -> 0 then(
match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)
| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))
| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)
| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))
| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)
| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))
| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)


fix:
let rec build (rand, depth) = if depth>0 then(
match rand(0,8) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
| 7 -> buildSixtyNine(build (rand,depth-1))
| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = if depth>0 then(
match rand(0,8) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
| 7 -> buildSixtyNine(build (rand,depth-1))
| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth>0 then(
match rand(0,8) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
| 7 -> buildSixtyNine(build (rand,depth-1))
| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = 'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = 'a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(fs) in
let base = a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(fs) in
let base = _ in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = 'a->'a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(fs) in
let base = 'a->'a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(fs) in
let base = 0 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(fs) in
let base = fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(fs) in
let base = a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a+x(fs) in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a+x(fs) in
let base = a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  a'-> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  a'-> fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  'a-> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  'a-> fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  'a-> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  'a-> fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  'a -> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  'a -> fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fs->fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = fs->fs in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fs(fs) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = fs(fs) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x in
let base = fun q->q in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = fun q->q in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  in
let base = fun q->q in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a(x) in
let base = (fun q->q) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a(x) in
let base = (fun q->q) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a(x) in
let base = (fun q->q) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a(x) in
let base = (fun q->q) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  f x(a) in
let base = (fun q->q) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  f x(a) in
let base = (fun q->q) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun w -> x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = (fun q->q) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = (fun q->q) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun w -> x(a) in
let base = (fun a->a) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun w -> x(a) in
let base = (fun a->q) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun w -> x(a) in
let base = (fun a->q) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun a->a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun a->a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = (fun a->a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base = (fun a->a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = (fun 'a->'a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base = (fun 'a->'a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  match x with x:xs in
let base = (fun a->a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  match x with x:xs in
let base = (fun a->a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  match x with x:fs in
let base = (fun a->a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  match x with x:fs in
let base = (fun a->a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  match fs with x::xs in
let base = (fun a->a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  match fs with x::xs in
let base = (fun a->a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = fun s -> a s in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = fun s -> a s in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun w -> x(a(w))   in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a(x)   in
let base = fun a -> a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a(x)   in
let base = fun a -> a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun w -> x(a(w))   in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x   in
let base = fun a -> a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x   in
let base = fun a -> a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun w -> x(a(w))   in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x   in
let base =  a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x   in
let base =  a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun w -> x(a(w))   in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x   in
let base =  x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x   in
let base =  x in
List.fold_left f base fs


fix:
let stringOfList f l = "["^(sepConcat "; " (List.map f l))^"]"

bad:
let stringOfList f l = "["^(sepConcat "; "(List.map f "" l))^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^(sepConcat "; "(List.map f "" l))^"]"


fix:
let stringOfList f l = "["^(sepConcat "; " (List.map f l))^"]"

bad:
let stringOfList f l = "["^(sepConcat "; " (List.map f "" l))^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^(sepConcat "; " (List.map f "" l))^"]"


fix:
let rec clone x n = if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f (x-1)
in helper [] x n

bad:
let rec clone x n = if n<1 then return [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f x-1
in helper [] x n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n<1 then return [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f x-1
in helper [] x n


fix:
let rec clone x n = if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f (x-1)
in helper [] x n

bad:
let rec clone x n = if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f x-1
in helper [] x n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f x-1
in helper [] x n


fix:
let padZero l1 l2 = let x = (List.length l1 - List.length l2) in 
if x!=0 then
if x<0 then
(((clone 0 (abs x))@l1),l2)
else 
(l1,((clone 0 (abs x))@l2))
else 
(l1,l2)

bad:
let padZero l1 l2 = let x = (List.length l1 - List.length l2) in 
if x then
if x<0 then
(((clone 0 (abs x))@l1),l2)
else 
(l1,((clone 0 (abs x))@l2))
else 
(l1,l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let x  ->  (List.length l1 - List.length l2) in 
if x then
if x<0 then
(((clone 0 (abs x))@l1),l2)
else 
(l1,((clone 0 (abs x))@l2))
else 
(l1,l2)


fix:
let rec removeZero l = match l with
| x::xs -> if x=0 then removeZero xs
else xs
| _ -> l

bad:
let rec removeZero l = match l with
| x:xs -> if x=0 then removeZero xs
else xs
| _ -> l

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| x:xs -> if x=0 then removeZero xs
else xs
| _ -> l


fix:
let _ =List.combine (clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2])

bad:
let _ =List.combine ((clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2]) )

annotated:
let _ =List.combine ((clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2]) )


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
(len,-1::((sum mod 10)+1)::xs')
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = (List.length l1,[]) in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = (List.length l1,[]) in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
(len,-1::((sum mod 10)+1)::xs')
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::a)
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
-1::((sum mod 10)+1)::a
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::a)
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
-1::((sum mod 10)+1)::a
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
(len,-1::((sum mod 10)+1)::xs')
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
-1::((sum mod 10)+1)::a
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
-1::((sum mod 10)+1)::a
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::xs') xs
else
let num = (x*i) in
if(num<10) then
helper 0 (num::accum) xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::accum) xs
in helper 0 [] lre

bad:
let rec mulByDigit i l = let lrev = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum::xs

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = let lrev  ->  List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum::xs


fix:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::xs') xs
else
let num = (x*i) in
if(num<10) then
helper 0 (num::accum) xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::accum) xs
in helper 0 [] lre

bad:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre


fix:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::xs') xs
else
let num = (x*i) in
if(num<10) then
helper 0 (num::accum) xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::accum) xs
in helper 0 [] lre

bad:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre


fix:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::xs') xs
else
let num = (x*i) in
if(num<10) then
helper 0 (num::accum) xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::accum) xs
in helper 0 [] lre

bad:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre


fix:
let _ = digitsOfInt 0

bad:
let_ = digitsOfInt 0

annotated:
let_ = digitsOfInt 0


fix:
let rec additivePersistence n = 
let newList = digitsOfInt n in 1 + 2

bad:
let rec additivePersistence n = 
let newList = digitsOfInt n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let newList = digitsOfInt n


fix:
let _ = digitalRoot 9876

bad:
let _ = digitalRoot2 9876

annotated:
let _ = digitalRoot2 9876


fix:
let rec additivePersistence2 n = 
let newList = digitsOfInt n in
let sum = sumList newList in 
let count = 2 in
if(sum < 10) then count
else 1 + additivePersistence2 sum

bad:
let rec additivePersistence2 n = 
let newList = digitsOfInt n in
let sum = sumList newList in 
let count 2 in = 
if(sum < 10) then count
else 1 + additivePersistence2 sum

annotated:
let rec additivePersistence : int -> int = fun 2 n  ->  
let newList = digitsOfInt n in
let sum = sumList newList in 
let count 2 in = 
if(sum < 10) then count
else 1 + additivePersistence2 sum


fix:
let rec assoc (d,k,l) = failwith "to be written"

bad:
let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f b')
else c'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let (b', c') = f b in
if c' = true then wwhile (f b')
else c'


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
(
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
(
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f,b')
else b'

bad:
let fixpoint (f,b) = wwhile ((f (neg b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f (neg b)),b)


fix:
let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f,b')
else b'

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ( (f b),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(eval(e1,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi * eval(e1,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi * eval(e1,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(eval(e1,x,y))

bad:
eval(Sine(VarY), 11.0 ,0)

annotated:
eval(Sine(VarY), 11.0 ,0)


fix:
let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)

bad:
let _ = eval ((Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2

annotated:
let _ = eval ((Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2


fix:
let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)

bad:
)

annotated:
)


fix:
let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; 
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; 
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(1) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(1) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is ";
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is ";
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end else 1.0
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end else 1.0
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end


fix:
let _ = build(makeRand(2,3), 2)

bad:
let _ = build(rand(2,3), 2)

annotated:
let _ = build(rand(2,3), 2)


fix:
let rec assoc (d,k,l) = match l with
|[] -> d
|(ki, vi) :: t -> 
if ki = k then vi
else assoc (d, k, t)

bad:
let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand 1)

annotated:
let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand 1)


fix:
let rec assoc (d,k,l) = match l with
|[] -> d
|(ki, vi) :: t -> 
if ki = k then vi
else assoc (d, k, t)

bad:
let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand, 1)

annotated:
let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand, 1)


fix:
let rec build (rand, depth) = match (rand,depth)  with
|(_,0) -> if((rand mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()

bad:
let rec build (rand, depth) = match (r,d)  with
|(_,0) -> if((r mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (r,d)  with
|(_,0) -> if((r mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()


fix:
let rec build (rand, depth) = match (rand,depth)  with
|(_,0) -> if((rand mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()

bad:
let rec build (rand, depth) = match (rand,depth)  with
|(_,0) -> if((r mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
|(_,0) -> if((r mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))
else 
build(rand + 1, depth - 1)

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))
else 
build(rand + 1, depth - 1)

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), 
build(rand, depth - 1);
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), 
build(rand, depth - 1);
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)


fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))
else 
build(rand + 1, depth - 1)

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1)); 
else 
build(rand + 1, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1)); 
else 
build(rand + 1, depth - 1)


fix:
let rec build (rand, depth) = match depth with 
| 0 -> buildX() 
| 1 ->  let x = rand(1, 2) in 
if (x > 1) then buildCosine( build(rand, depth - 1) )
else buildSine( build(rand, depth - 1))
| _ -> buildCosine( build(rand, depth - 1) )

bad:
let rec build (rand, depth) = match depth with 
| 0 -> buildX() 
| 1 ->  let x = rand(_, _) in 
if (x > 1) then buildCosine( build(rand, depth - 1) )
else buildSine( build(rand, depth - 1))
| _ -> buildCosine( build(rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with 
| 0 -> buildX() 
| 1 ->  let x = rand(_, _) in 
if (x > 1) then buildCosine( build(rand, depth - 1) )
else buildSine( build(rand, depth - 1))
| _ -> buildCosine( build(rand, depth - 1) )


fix:
let rec build (rand, depth) = match depth with
| 0 -> let z = 2 in rand(1,z)

bad:
let rec build (rand, depth) = match rand with
| (x* y-> z) -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand with
| (x* y-> z) -> buildX()


fix:
let rec build (rand, depth) = match depth with
| 0 -> let z = 2 in rand(1,z)

bad:
let rec build (rand, depth) = match depth with |
| 0 -> let z = 2 in rand

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with |
| 0 -> let z = 2 in rand


fix:
let rec build (rand, depth) = match depth with
| 0 -> let z = 2 in rand(1,z)

bad:
let rec build (rand, depth) = match depth with |
| 0 -> let z = 2 in rand(1,z)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with |
| 0 -> let z = 2 in rand(1,z)


fix:
let rec build (rand, depth) = match depth with
| 0 -> let z = rand in
if( z > 1) then buildX()
else buildY()

bad:
let rec build (rand, depth) = match depth with
| 0 -> let z = rand in rand in 
if( z > 1) then buildX()
else buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> let z = rand in rand in 
if( z > 1) then buildX()
else buildY()


fix:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildSine( build( rand, depth - 1))
else buildCosine( build(rand, depth - 1))
| _ -> buildX()

bad:
let rec build (rand, depth) = match depth with |
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildSine( build( rand, depth - 1))
else buildCosine( build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with |
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildSine( build( rand, depth - 1))
else buildCosine( build(rand, depth - 1))


fix:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildX()
else buildY()
| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )
| 2 -> let num = rand(1, 3) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )
| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
build(rand, depth - 1))

bad:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildX()
else buildY()
| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )
| 2 -> let num = rand(1, 3) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )
| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildX()
else buildY()
| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )
| 2 -> let num = rand(1, 3) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )
| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))


fix:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,10) in 
if( num > 3) then buildX()
else buildY()

| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )

| 2 -> let num = rand(1, 30) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )

| 3 -> let num = rand (1, 50) in 
if (num mod 2 = 0) then 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildCosine(build(rand, depth - 1)))
else 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))

| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))

| 5 -> let num = rand(1, 10) in
if(num = 1) then 
buildSine(buildSine(buildSine( build(rand, depth - 1))))
else if(num = 2) then 
buildCosine(buildCosine(buildCosine( build(rand, depth - 1))))
else if (num = 3) then
buildSine(buildCosine( build(rand, depth - 1)))
else buildCosine(buildSine( build(rand, depth - 1)))
| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))

| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) 

| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))


| _ -> let num = rand(1, 3) in build(rand, depth - num )

bad:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,10) in 
if( num > 3) then buildX()
else buildY()

| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )

| 2 -> let num = rand(1, 30) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )

| 3 -> let num = rand (1, 50) in 
if (num mod 2 = 0) then 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildCosine(build(rand, depth - 1)))
else 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))

| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))

| 5 -> let num = rand(1, 10) in
if(num = 1) then 
buildSine(buildSine(buildSine( build(rand, depth - 1))))
else if(num = 2) then 
buildCosine(buildCosine(buildCosine( build(rand, depth - 1))))
else if (num = 3) then
buildSine(buildCosine( build(rand, depth - 1)))
else buildCosine(buildSine( build(rand, depth - 1)))
| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))

| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) 

| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))


| _ -> let num = rand(1, 3) in build(rand, depth num )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> let num = rand(1,10) in 
if( num > 3) then buildX()
else buildY()

| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )

| 2 -> let num = rand(1, 30) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )

| 3 -> let num = rand (1, 50) in 
if (num mod 2 = 0) then 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildCosine(build(rand, depth - 1)))
else 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))

| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))

| 5 -> let num = rand(1, 10) in
if(num = 1) then 
buildSine(buildSine(buildSine( build(rand, depth - 1))))
else if(num = 2) then 
buildCosine(buildCosine(buildCosine( build(rand, depth - 1))))
else if (num = 3) then
buildSine(buildCosine( build(rand, depth - 1)))
else buildCosine(buildSine( build(rand, depth - 1)))
| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))

| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) 

| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))


| _ -> let num = rand(1, 3) in build(rand, depth num )


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if(depth = 0) then
let num = rand(1, 10) in
if( num > 4) then buildX()
else buildY()
else 
let num = rand(1, 10) in match num with
| 1 | 2 -> buildSine(build(rand, depth - 1))
| 3 | 4 -> buildCosine(build(rand, depth - 1))
| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),
build(rand, depth - 1), build(rand, depth - 1))
| _ -> build(rand, depth - 1)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth = 0) then
let num = rand(1, 10) in
if( num > 4) then buildX()
else buildY()
else 
let num = rand(1, 10) in match num with
| 1 | 2 -> buildSine(build(rand, depth - 1))
| 3 | 4 -> buildCosine(build(rand, depth - 1))
| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),
build(rand, depth - 1), build(rand, depth - 1))
| _ -> build(rand, depth - 1)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != b) in g,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x = let xx = f x in (xx, xx ! ->  b) in g,b)


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + sqsum t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + sqsum t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + f base t

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + f base t


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let base = 0 in
List.fold_left f base xs

annotated:
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + f base t in 
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + f base t in 
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + List.fold_left f base t in 
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + List.fold_left f base t in 
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = fun x -> x * x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = fun x -> x * x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = fun _ x -> x * x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = fun _ x -> x * x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = fun a x -> x * x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = fun a x -> x * x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = g a x = x * x + a in
let base = 0 in
List.fold_left g base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = g a x = x * x + a in
let base = 0 in
List.fold_left g base xs


fix:
let sqsumL xs = 
let rec helper acc rest = match rest with
| [] -> acc * acc
| h :: t -> h + helper (acc + h) t
in helper 0 xs

bad:
let sqsumL xs = 
let rec helper acc rest = match xs with
| [] -> []
| h :: t -> h

annotated:
let sqsum : int list -> int  = fun L xs  ->  
let rec helper acc rest = match xs with
| [] -> []
| h :: t -> h


fix:
let sqsumL xs = 
let rec helper acc rest = match rest with
| [] -> acc * acc
| h :: t -> h + helper (acc + h) t
in helper 0 xs

bad:
let sqsumL xs = 
let rec helper acc xs = match xs with
| [] -> acc * acc
| h :: t -> h + helper (acc + h) t

annotated:
let sqsum : int list -> int  = fun L xs  ->  
let rec helper acc xs = match xs with
| [] -> acc * acc
| h :: t -> h + helper (acc + h) t


fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x =  failwith "TBD"

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  failwith "TBD"


fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let base = a in
List.fold_left f base fs

annotated:
let base = a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x =  failwith "TBD" in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  failwith "TBD" in
let base = a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x =  failwith "TBD" in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  failwith "TBD" in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a (f x) in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a (f x) in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a (x) in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a (x) in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun x' = a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let existing = a in 
let next x in 
existing(next) in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let existing = a in 
let next x in 
existing(next) in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun x' = a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let existing = a in 
let next = x in 
existing(next) in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let existing = a in 
let next = x in 
existing(next) in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun x' -> a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun x' = a x in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun x' = a x in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun x' -> a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x =  fun x' -> a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x)] 3

annotated:
let _ = pipe [(fun x -> x+x)] 3


fix:
let pipe fs = 
let f a x =  fun x' -> (a x) in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x =  a (f x) in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x =  failwith "hi" in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun y -> fun x -> a in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun y -> fun x -> a in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  let g x = a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let g a = let xx = f x in g in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let g a = let xx = f x in g in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  let g x = a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let g x = a x in
let base = fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let g x = a x in
let base = fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun a -> fun x ->  a x in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x =  fun g -> a x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let f g = fun x -> f (a x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let f g = fun x -> f (a x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun g -> a x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x =  fun g -> a x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  let g y = a (g x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  let g y = a (g x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let _ = sepConcat "hi" []

bad:
let _ = sepConcat sep []

annotated:
let _ = sepConcat sep []


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = sep in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then x :: a in
let base = sep in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then x :: a in
let base = sep in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = sep in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then x :: a 
else a in
let base = sep in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then x :: a 
else a in
let base = sep in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = sep in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then a ^ x in
let base = sep in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then a ^ x in
let base = sep in
let l = t in
List.fold_left f base l


fix:
let rec fold_l f acc xs = match xs with 
| [] -> acc 
| h :: t -> fold_l f (f acc h) t

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if a = "a" then a ^ x  ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = if a = "a" then a ^ x  ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let stringOfList f l = List.map (sepConcat f) l

bad:
let stringOfList f l = List.map sepConcat f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat f l


fix:
let stringOfList f l = List.map (f sepConcat ) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map (f sepConcat ) l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let stringOfList f l = List.map (f sepConcat ) l

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = padZero l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = padZero l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args =  in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigMul l1 l2 = 
let f a x = 
let (index, result) = a in
let (list1,list2) = x in
match list2 with
| [] -> []
| h::t ->
let resList = mulByDigit h list1 in
let newIndex = (index + 1) in 
let newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in
(newIndex, newRes)
in
let base = (0, []) in
let args = ((List.rev l1),(List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (index, result) = a in
let (list1,list2) = x in
match list2 with
| [] -> []
| h::t ->
let resList = mulByDigit h list1 in
let newIndex = (index + 1) in 
let newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in
(newIndex, newRes)
in
let base = (0, []) in
let args = ((List.rev l1),(List.rev l2)) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = x in carry in
let base = failwith "to be implemented" in
let args =  List.rev List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = x in carry in
let base = failwith "to be implemented" in
let args =  List.rev List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = x in carry in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = x in carry in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
1

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
1


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
x

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
x


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
|(x, y) -> x in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
|(x, y) -> x in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
|(x, y) -> x in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
|(x, y) -> x in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
|(x, y) -> x in carry in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
|(x, y) -> x in carry in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = [] in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = [] in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (x,y) -> x in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in
let num = (carry + add1 + add2) / 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in carry in 
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
let carry = match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in carry in 
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (x,y) -> x in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in
let num = (carry + add1 + add2) / 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (x,y) -> x in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in
let num = (carry + add1 + add2) / 10 in
match a with 
|(x,y) -> (newCarry, num :: y in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (x,y) -> x in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in
let num = (carry + add1 + add2) / 10 in
match a with 
|(x,y) -> (newCarry, num :: y in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (c,_) -> c in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in
let num = (carry + add1 + add2) mod 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (0, []) in
let args =  List.rev (List.combine (0::l1) (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (c,_) -> c in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in
let num = (carry + add1 + add2) mod 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (newCarry, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (c,_) -> c in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in
let num = (carry + add1 + add2) mod 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (newCarry, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = failwith "tbd" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 =
let g =
let f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in
let (_,res) = (List.fold_left f base args) in
res
in
List.fold_left bigAdd [] g

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  -> 
let g =
let f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in
let (_,res) = (List.fold_left f base args) in
res
in
List.fold_left bigAdd [] g


fix:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = failwith "tbd" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (index, result) = a in
let (list1,list2) = x in
match list2 with
| [] -> []
| h::t ->
let resList = mulByDigit h list1 in
let newIndex = (index + 1) in 
let newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in
(newIndex, newRes)
in
let base = (0, []) in
let args = ((List.rev l1),(List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (index, result) = a in
let (list1,list2) = x in
match list2 with
| [] -> []
| h::t ->
let resList = mulByDigit h list1 in
let newIndex = (index + 1) in 
let newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in
(newIndex, newRes)
in
let base = (0, []) in
let args = ((List.rev l1),(List.rev l2)) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = padZero [1;2;3] []

bad:
let _ padZero [1;2;3] []

annotated:
let _ padZero [1;2;3] []


fix:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); fun x -> x + 1] 3

annotated:
let _ = pipe : ('a -> 'a) list -> ('a -> 'a) = fun  [(fun x -> x + 3);(fun x-> x + x); (fun y -> x  ->  2); fun x -> x + 1] 3


fix:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); (fun x -> x + 1)] 3

annotated:
let _ = pipe : ('a -> 'a) list -> ('a -> 'a) = fun  [(fun x -> x + 3);(fun x-> x + x); (fun y -> x  ->  2); (fun x -> x + 1)] 3


fix:
let pipe fs = 
let f a x = x a in
let base =  fun y ->  y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  fun y ->  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  fun y ->  in
List.fold_left f base fs


fix:
let stringOfList f l = "[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = "[" ^ sepConcat ";" List.map f l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ sepConcat ";" List.map f l ^ "]"


fix:
let rec clone x n = 
let rec helper a x n =
if x <= 0 then []
else 
let a' = x::a in
helper a' x (n-1)
in helper [] x n

bad:
let rec clone x n = 
let helper a x n =
if x <= 0 then []
else 
let a' = x::a in
helper a' x (n-1)
in helper [] x n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let helper a x n =
if x <= 0 then []
else 
let a' = x::a in
helper a' x (n-1)
in helper [] x n


fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let padZero l1 l2 = 
let length1 = List.length l1 in
let length2 = List.length l2 in
if length1 > length2 then 
(l1, List.append (clone 0 (length1 - length2)) l2)
else if length2 > length1 then 
(List.append (clone 0 (length1 - length2)) l1, l2)
else (l1,l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.length l1 in
let length2 = List.length l2 in
if length1 > length2 then 
(l1, List.append (clone 0 (length1 - length2)) l2)
else if length2 > length1 then 
(List.append (clone 0 (length1 - length2)) l1, l2)
else (l1,l2)


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = 0 in
let args = 
let rec pair list1 list2 = match (list1, list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| ([], []) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = 0 in
let args = 
let rec pair list1 list2 = match (list1, list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| ([], []) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = 0 in
let args = 
let rec pair list1 list2 = match (list1, list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = 0 in
let args = 
let rec pair list1 list2 = match (list1, list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z)if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair list1 list2 = 
match (List.rev list1, List.rev list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z)if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair list1 list2 = 
match (List.rev list1, List.rev list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z) -> if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair list1 list2 = 
match (List.rev list1, List.rev list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z) -> if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair list1 list2 = 
match (List.rev list1, List.rev list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l =
let rec helper a i l = match l with
| [] -> a
| h::t -> let a' = h*i::a in
helper a' i t
in helper [] i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  -> 
let rec helper a i l = match l with
| [] -> a
| h::t -> let a' = h*i::a in
helper a' i t
in helper [] i l


fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l =
let rec helper acc carry i l = match l with
| [] -> acc
| h::t -> let x = (h*i + carry) in 
let n = if x > 9 then x mod 10 else x in
let carry' = if x > 9 then x - 10 else 0 in
let acc' = n::acc in
helper acc' carry' i t
in helper [] 0 i (List.rev l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  -> 
let rec helper acc carry i l = match l with
| [] -> acc
| h::t -> let x = (h*i + carry) in 
let n = if x > 9 then x mod 10 else x in
let carry' = if x > 9 then x - 10 else 0 in
let acc' = n::acc in
helper acc' carry' i t
in helper [] 0 i (List.rev l)


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z) -> if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair acc list1 list2 = 
match (list1, list2) with
| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2
| (_ , _) -> acc
in pair [(0,0)] (List.rev l1) (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z) -> if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair acc list1 list2 = 
match (list1, list2) with
| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2
| (_ , _) -> acc
in pair [(0,0)] (List.rev l1) (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1)) in
buildZeros [] place in 
let acc' = List.append (mulByDigit h l2) placeHolders) in
digitProducts acc' (place+1) t l2

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1)) in
buildZeros [] place in 
let acc' = List.append (mulByDigit h l2) placeHolders) in
digitProducts acc' (place+1) t l2


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
) in
let (_, res) = List.fold_left f base args in
res

annotated:
) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders) in
digitProducts acc' (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders) in
digitProducts acc' (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2)) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2)) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2)) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2)) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2+) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2+) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2) 
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2) 
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
) 
in
let (_, res) = List.fold_left f base args in
res

annotated:
) 
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t) 
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t) 
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts a::acc (place+1) t l2) 
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts a::acc (place+1) t l2) 
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts a::acc (place+1) t l2 in
digitsProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts a::acc (place+1) t l2 in
digitsProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitsProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitsProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, 0) in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, 0) in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, []) in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, []) in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, []) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, []) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let pipe fs = 
let f a x = x a in
let base = let ass y -> y in
ass y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = function y -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = function y -> y in
List.fold_left f base fs


fix:
let _ = pipe [] 3

bad:
let pipe fs = 
let f a x =  fun b -> x (a b) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun b -> x (a b) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let digitsOfInt n = 
let explodeNum n =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse (explodeNum n)

bad:
let digitsOfInt n = 
let explodeNum =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse explodeNum n

annotated:
let digitsOfInt n = 
let explodeNum =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse explodeNum n


fix:
let digitsOfInt n = 
let explodeNum n =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse (explodeNum n)

bad:
let digitsOfInt n = 
let explodeNum =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse (explodeNum n)

annotated:
let digitsOfInt n = 
let explodeNum =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse (explodeNum n)


fix:
let listReverse l = 
let rec r e a =
match a with
| [] -> []
| (x::l') -> x :: e :: r e l'
in r [] l

bad:
let rec listReverse l = 
match l with
| [] -> []
| (x::l') -> (listReverse l') :: x :: []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| (x::l') -> (listReverse l') :: x :: []


fix:
let listReverse l = 
let rec rev o = function
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

bad:
let listReverse l = 
let rec rev [] o = o
| (hd::tl) -> rev tl (hd::o)
in rev l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec rev [] o = o
| (hd::tl) -> rev tl (hd::o)
in rev l []


fix:
let listReverse l = 
let rec rev o = function
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

bad:
let listReverse l = 
let rec rev o = 
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec rev o = 
| [] -> o
| h::t -> rev (h::o) t
in rev [] l


fix:
let listReverse l = 
let rec rev o = function
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

bad:
let listReverse l = 
let rec rev o = fun
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec rev o = fun
| [] -> o
| h::t -> rev (h::o) t
in rev [] l


fix:
let digitsOfInt n =
let rec digits o a = 
if (a > 0)
then digitsOfInt ((a mod 10)::o) (a/10)
else []
in digits [] n

bad:
let digitsOfInt n =
let rec digits o a = 
if (a > 0)
then (digitsOfInt ((a mod 10)::o) (a/10))
else []
in digits [] n;

let _ = digitsOfInt 3124

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits o a = 
if (a > 0)
then (digitsOfInt ((a mod 10)::o) (a/10))
else []
in digits [] n;

let _ = digitsOfInt 3124


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k i else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| (s,i)::t -> if s = k i else assoc (d,k,t)


fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (fixpoint(f,b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fixpoint(f,b),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then b else f(b),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then b else f b,b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  (f b) then b else (f b),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  (f b) then (b,false) else ((f b),true),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if x  ->  f x then (b, false) else (b, true),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if x  ->  f x then (x, false) else (x, true),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then (b, false) else (b, true),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if b  ->  f b then (b, false) else (b, true)),b)


fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  
if b = f b then (b, false) else (b, true) 
in
wwhile (helper b,b)


fix:
let fixpoint (f,b) = let helper x = 
if b = (f b) then (b, false) else (f b, true) in
wwhile (helper,b)

bad:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)

bad:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if x  ->  (f x) then (x, false) else (f x, true)),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
l

annotated:
l


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (x->(if x  ->  (f x) then (x, false) else (f x, true)),b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
l

annotated:
l


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let helper x = 
if x = (f x) then (x, false) else (f x, true) in
wwhile (helper,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  
if x = (f x) then (x, false) else (f x, true) in
wwhile (helper,b)


fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
l

annotated:
l


fix:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average e1 e2 -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" + exprToString e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" + exprToString e


fix:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average e1 e2 -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e


fix:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average (e1,e2) -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"
| Times (e1,e2) -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1,e2,e3,e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average (e1,e2) -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average (e1,e2) -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec eval (e,x,y) = match e with
| buildX()		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval (e,x,y) = match e with
| buildX()		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
) e

annotated:
) e


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec eval (e,x,y) = match e with
| buildX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval (e,x,y) = match e with
| buildX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
) e

annotated:
) e


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec eval (e,x,y) = match e with
| buildX	                -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval (e,x,y) = match e with
| buildX	                -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
) e

annotated:
) e


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
) e

annotated:
) e


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| buildSine(e1)	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| buildSine(e1)	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
) e

annotated:
) e


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| buildSine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| buildSine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
) e

annotated:
) e


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
):(eval(e4,x,y))

annotated:
):(eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?(eval (e3,x,y)):(eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?(eval (e3,x,y)):(eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> (eval (e1,x,y)<eval (e2,x,y))?(eval (e3,x,y)):(eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> (eval (e1,x,y)<eval (e2,x,y))?(eval (e3,x,y)):(eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)


fix:
let rec build (rand, depth) = 
let e = build(rand,depth') in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = match rand (depth>0?(rand 0 1):(rand 2 6)) with
| 0 -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand (depth>0?(rand 0 1):(rand 2 6)) with
| 0 -> buildX()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth') in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = match (depth>0?(rand 0 1):(rand 2 6)) with
| 0 -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (depth>0?(rand 0 1):(rand 2 6)) with
| 0 -> buildX()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth') in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = match rand (depth>0?0:2) (depth>0?1:6) with
| 0 -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand (depth>0?0:2) (depth>0?1:6) with
| 0 -> buildX()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth') in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = if depth > 0 then match rand 0 4 with
| 0 -> buildX()
else match rand 0 1 with
| 0 -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth > 0 then match rand 0 4 with
| 0 -> buildX()
else match rand 0 1 with
| 0 -> buildX()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let e = build(rand,depth-1) in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let e = build(rand,depth-1) in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match (rand (0 4)) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0 1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let e = build(rand,depth-1) in
if depth > 1 then match (rand (0 4)) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0 1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match (rand(0 4)) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0 1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let e = build(rand,depth-1) in
if depth > 1 then match (rand(0 4)) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0 1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let _ = build(rand,2)

annotated:
let _ = build(rand,2)


fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()


fix:
let rand = makeRand(10,39)

bad:
let rand = makeRand(10,39) in 
build (rand, 8);

(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = (8,54765,10000)

annotated:
let rand = makeRand(10,39) in 
build (rand, 8);

(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = (8,54765,10000)


fix:
let rand = makeRand(10,39)

bad:
let rand = makeRand(10,39) in 
let _ = build (rand, 8);

(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = (8,54765,10000)

annotated:
let rand = makeRand(10,39) in 
let _ = build (rand, 8);

(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = (8,54765,10000)


fix:
let rand = makeRand(10,12)

bad:
let rec build (rand, depth) = 
if depth > 1 then match rand (0,16) with
| 0        ->  buildX()
| 1	   -> buildY()
| 3|4      -> buildSine(build(rand,depth-1))
| 5|6      -> buildCosine(build(rand,depth-1))
| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 13|14|15 -> buildThresh(build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1))
| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))
| _        -> buildMultDiv(build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1))

else match rand (0,2) with
| 0 -> buildX()
| _ -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth > 1 then match rand (0,16) with
| 0        ->  buildX()
| 1	   -> buildY()
| 3|4      -> buildSine(build(rand,depth-1))
| 5|6      -> buildCosine(build(rand,depth-1))
| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 13|14|15 -> buildThresh(build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1))
| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))
| _        -> buildMultDiv(build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1))

else match rand (0,2) with
| 0 -> buildX()
| _ -> buildY()


fix:
let _ = eval_fn (Square VarX) (2.,2.)

bad:
let _ = eval_fn (Square 5) (1,1)

annotated:
let _ = eval_fn (Square 5) (1,1)


fix:
let _ = eval_fn (Square VarX) (2.,2.)

bad:
let _ = eval_fn (Square VarX) (1,1)

annotated:
let _ = eval_fn (Square VarX) (1,1)


fix:
let _ = eval_fn (Square VarX) (2.,2.)

bad:
let _ = eval_fn (Square VarX) (1.,1.)

annotated:
let _ = eval_fn (Square VarX) (1.,1.)


fix:
let _ = eval (Square VarX,0.9,0.9)

bad:
let _ = eval (Square VarX,0.5,0.25)

annotated:
let _ = eval (Square VarX,0.5,0.25)


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
Format.sprintf("%d" !rv)

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let rv = eval (e,x,y) in
Format.sprintf("%d" !rv)


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
Format.sprintf "%d" !rv

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let rv = eval (e,x,y) in
Format.sprintf "%d" !rv


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
Format.sprintf "%f" !rv

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let rv = eval (e,x,y) in
Format.sprintf "%f" !rv


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in

let _ = eval_fn (Square VarX) (2.,1.)

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let rv = eval (e,x,y) in

let _ = eval_fn (Square VarX) (2.,1.)


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y)

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let rv = eval (e,x,y)


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let _ = eval (e,x,y)

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->  
let _ = eval (e,x,y)


fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) =  eval (e,x,y)

annotated:
let eval : expr * float * float -> float = fun _fn e (x,y)  ->   eval (e,x,y)


fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2 + x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a**2 + x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2. + x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a**2. + x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a**2. +. x in
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = x' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (f s = s) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (f s = s) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a -> x in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a -> x in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x y -> x y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x y -> x y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x y -> x y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x y -> x y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x y -> x y in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> y in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> a (x y) in
let base = fun x -> y in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = l in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = l in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if a != "" then a ^ sep ^ x else x in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = (fun x -> match x with
| sep ^ y -> y
| _ -> x) in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = (fun x -> match x with
| sep ^ y -> y
| _ -> x) in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = (^) h in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = (^) h in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = (^) h in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = (^) h in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = fun x-> h ^ x in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = fun x-> h ^ x in
let l = t in
List.fold_left f base l


fix:
let rec clone x n =
if n > 0 then
x :: clone x (n-1)
else
[]

bad:
let rec clone x n =
if n > 0 then
x :: clone x n-1
else
[]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  -> 
if n > 0 then
x :: clone x n-1
else
[]


fix:
let padZero l1 l2 = if (List.length l1) > (List.length l2) then
(l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)
else
((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> (b,(d+e)::c) 
in
let base = ([], [0]) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> (b,((d+e)::c) 
in
let base = ([], [0]) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> (b,((d+e)::c) 
in
let base = ([], [0]) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine (0::l1) (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine (0::l1) 0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine (0::l1) 0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = if i > 0
then
mulByDigit (i-1) (bigAdd l l)
else
0

bad:
let rec mulByDigit i l = mulByDigit i-1 bigAdd l l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit i-1 bigAdd l l


fix:
let rec mulByDigit i l = if i > 0
then
mulByDigit (i-1) (bigAdd l l)
else
0

bad:
let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit (i-1) bigAdd l l


fix:
let rec mulByDigit i l = if i > 0
then
mulByDigit (i-1) (bigAdd l l)
else
0

bad:
let rec mulByDigit i l = if i > 0
then
mulByDigit (i-1) bigAdd l l
else
0

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0
then
mulByDigit (i-1) bigAdd l l
else
0


fix:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> d 
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match (a,x) with
| ((b,c),d) -> d 
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [4;0] [1;0]

annotated:
let _ = bigMul [4;0] [1;0]


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [4;0] [1;1]

annotated:
let _ = bigMul [4;0] [1;1]


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [4;0] [1;1]

annotated:
let _ = bigMul [4;0] [1;1]


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + sumList List.tl

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| _ -> List.hd xs + sumList List.tl


fix:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs

bad:
let rec sumList xs = 
match xs with
| _ -> List.hd xs + sumList List.tl
| [] -> []

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| _ -> List.hd xs + sumList List.tl
| [] -> []


fix:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + List.tl sumList

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| _ -> List.hd xs + List.tl sumList


fix:
let rec sumList xs = 
match xs with
| [] -> []
| (x::xs') -> x

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + 2

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| _ -> List.hd xs + 2


fix:
let rec sumList xs = 
match xs with
| [] -> []
| (x::xs') -> x

bad:
let rec sumList xs = 
match xs with
| _ -> List.hd xs + 2
| [] -> []

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| _ -> List.hd xs + 2
| [] -> []


fix:
let rec sumList xs = 
match xs with
| [] -> []
| (x::xs') -> x

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + (sumList List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| _ -> List.hd xs + (sumList List.tl xs)


fix:
let rec sumList xs = 
match xs with
| [] -> []
| (x::xs') -> x

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + sumList List.tl xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| _ -> List.hd xs + sumList List.tl xs


fix:
let _ = sumList []

bad:
let _ = sumList [1; 2; 3; 4]

annotated:
let _ = sumList [1; 2; 3; 4]


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> []
| List.hd xs -> x

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| List.hd xs -> x


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> []
| List.hd xs -> 1

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| List.hd xs -> 1


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> []
| List.hd xs -> 1

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| List.hd xs -> 1


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> []
| xs -> List.hd xs + sumList List.tl xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> []
| xs -> List.hd xs + sumList List.tl xs


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> List.hd xs + sumList List.tl xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> 0
| xs -> List.hd xs + sumList List.tl xs


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs))

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs))


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]
(* uncomment and run AFTER you have implemented sumList

let _ = sumList [1; 2; 3; 4]
let _ = sumList [1; -2; 3; 5]
let _ = sumList [1; 3; 5; 7; 9; 11]

*)
List.hd 55

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]
(* uncomment and run AFTER you have implemented sumList

let _ = sumList [1; 2; 3; 4]
let _ = sumList [1; -2; 3; 5]
let _ = sumList [1; 3; 5; 7; 9; 11]

*)
List.hd 55


fix:
let rec digitsOfInt n = 
match n with
| n -> 5

bad:
let rec digitsOfInt n = 
match n with
| n <= 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n <= 0 -> []


fix:
let rec digitsOfInt n = 
match n with
| n -> 5

bad:
let rec digitsOfInt n = 
match n with
| n (<=) 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n (<=) 0 -> []


fix:
let rec digitsOfInt n = 
match n with
| n -> 5

bad:
let rec digitsOfInt n = 
match n with
| n < 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n < 0 -> []


fix:
let rec digitsOfInt n = 
match n with
| n -> 5

bad:
let rec digitsOfInt n = 
match n with
| (n < 0) -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| (n < 0) -> []


fix:
let rec digitsOfInt n = 
match n with
| n -> 5

bad:
let rec digitsOfInt n = 
match n with
| (n < 0) -> []
| n -> 5

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| (n < 0) -> []
| n -> 5


fix:
let rec digitsOfInt n = 
match n with
| n -> n :: []

bad:
let rec digitsOfInt n = 
match n with
| n -> 5
| (n < 0) -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n -> 5
| (n < 0) -> []


fix:
let rec digitsOfInt n = 
match n with
| n -> n :: []

bad:
let rec digitsOfInt n = 
match n with
| n -> 5
| n < 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n -> 5
| n < 0 -> []


fix:
let rec digitsOfInt n = 
match n with
| n -> n :: []

bad:
let rec digitsOfInt n = 
match n with
| n -> 5
| 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n -> 5
| 0 -> []


fix:
let rec digitsOfInt n = 
match n with
| (n::ns) -> n :: ns

bad:
let rec digitsOfInt n = 
match n with
| 0 -> [] :: ns
| n -> n :: ns

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| 0 -> [] :: ns
| n -> n :: ns


fix:
let rec digitsOfInt n = 
match n with
| (n::ns) -> n :: ns

bad:
let rec digitsOfInt n = 
match n with
| n -> n :: ns

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n -> n :: ns


fix:
let rec digitsOfInt n = 
match n with
| n::ns -> (n::ns)

bad:
let rec digitsOfInt n = 
match n with
| n -> (n::ns)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| n -> (n::ns)


fix:
let ns = []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| n -> List.hd ((n mod 10)::ns)

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| n -> List.hd (n mod 10)::ns

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| n -> List.hd (n mod 10)::ns


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0
| n -> ((n mod 10)::(digitsOfInt (n / 10)))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0
| n -> ((n mod 10)::(digitsOfInt (n / 10)))


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0
| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0
| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)


fix:
let _ = digitsOfInt 3124

bad:
)

annotated:
)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::(n mod 10)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::(n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::(n mod 10)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))


fix:
digitsOfInt (-1)

bad:
digitsOfInt -5

annotated:
digitsOfInt -5


fix:
digitsOfInt (-1)

bad:
digitsOfInt (-5)

annotated:
digitsOfInt (-5)


fix:
let rec additivePersistence n =

bad:
let rec additivePersistence n =

annotated:
let rec additivePersistence n =


fix:
let rec additivePersistence n =

bad:
let rec digitalRoot n = 
sumList digitsOfInt n

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
sumList digitsOfInt n


fix:
let rec additivePersistence n =

bad:
let rec additivePersistence n =

annotated:
let rec additivePersistence n =


fix:
let rec additivePersistence n =

bad:
let rec digitalRoot n = 
sumList (digitsOfInt n)

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
sumList (digitsOfInt n)


fix:
digitalRoot 9876

bad:
let rec digitalRoot n = 
sumList (digitsOfInt n)

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
sumList (digitsOfInt n)


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let l' = [] in
match l with
| [] -> l'
| h::t -> (List.hd l)::(listReverse (List.tl l))

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let l' = [] in
match l with
| [] -> l'
| h::t -> (List.hd l)::(listReverse (List.tl l))


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec lr l' =
match l with
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' =
match l with
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec lr l' = function
match l with
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' = function
match l with
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l


fix:
let palindrome w = 
explode w = listReverse (explode w )

bad:
palindrome "hello"

annotated:
palindrome "hello"


fix:
additivePersistence 98765

bad:
additivePersistence 1111

annotated:
additivePersistence 1111


fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) )

annotated:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) )


fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )

annotated:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )


fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )

annotated:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )


fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )

annotated:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)) )

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)) )


fix:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let rev = listReverse ns' in
((n mod 10) ::  ( digitsOfInt (n / 10)) )

bad:
let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l


fix:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let listReverse ns in
((n mod 10) ::  ( digitsOfInt (n / 10)) )

bad:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let rev = listReverse ns in
((n mod 10) ::  ( digitsOfInt (n / 10)) )

annotated:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let rev = listReverse ns in
((n mod 10) ::  ( digitsOfInt (n / 10)) )


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec digitsOfInt n = 
let this = function
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n

annotated:
let rec digitsOfInt n = 
let this = function
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec digitsOfInt n = 
let this = function
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n

annotated:
let rec digitsOfInt n = 
let this = function
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec digitsOfInt n = 
let this = 
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n

annotated:
let rec digitsOfInt n = 
let this = 
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n


fix:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in listReverse (xxx n)

annotated:
let digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in listReverse (xxx n)


fix:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( xxx (n / 10)))
in listReverse (xxx n)

annotated:
let digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( xxx (n / 10)))
in listReverse (xxx n)


fix:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let digitsOfInt n = 
let rec xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( xxx (n / 10)))
in listReverse (xxx n)

annotated:
let digitsOfInt n = 
let rec xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( xxx (n / 10)))
in listReverse (xxx n)


fix:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

annotated:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)


fix:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = failwith "to be written" in
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = failwith "to be written" in
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = failwith "to be written" in
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then seen' :: seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then seen' :: seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then seen' :: seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then seen' :: seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then (seen' :: seen)

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then (seen' :: seen)


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
if 1 < 2
then 12

annotated:
if 1 < 2
then 12


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest'); 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest'); 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest')

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest')


fix:
let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

bad:
let rec wwhile (f,b) =
let b' =
match x' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')
in f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let b' =
match x' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')
in f b


fix:
let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

bad:
let rec wwhile (f,b) =
let b' =
match b' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')
in f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let b' =
match b' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')
in f b


fix:
let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

bad:
let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

bad:
let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx  ->  x*x*x in (xx, xx < 100)),b)


fix:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b))

bad:
let fixpoint (f,b) = wwhile (
(let f' f b =
let f b = let g' = g(b) in (b , b = g')
),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
(let f' f b =
let f b = let g' = g(b) in (b , b = g')
),b)


fix:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b))

bad:
let fixpoint (f,b) = wwhile (
(let f' f b =
let f b = let g' = g(b) in (b , b = g')

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
(let f' f b =
let f b = let g' = g(b) in (b , b = g')


fix:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b))

bad:
let fixpoint (f,b) = wwhile (
(let f' f b = let f b = let g' = g(b) in (b , b = g')),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
(let f' f b = let f b = let g' = g(b) in (b , b = g')),b)


fix:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b))

bad:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g')),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g')),b)


fix:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b))

bad:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b)


fix:
let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)

bad:
let fixpoint (f,b) = wwhile (
(let whilesFun = let fOfB = f(b) in (b , b = fOfB),b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (
(let whilesFun = let fOfB = f(b) in (b , b = fOfB),b))


fix:
let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b)


fix:
let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)

bad:
let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB), b)


fix:
let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)

bad:
let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b


fix:
let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b)


fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| (k', d') :: t ->
if k = k'
then d'
else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b'  ->  fOfB) in whilesFun (f, b)), b)


fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| (k', d') :: t ->
if k = k'
then d'
else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b'  ->  fOfB) in whilesFun (f, b)), b)


fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b'  ->  fOfB) in whilesFun f), b)


fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun f), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)


fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)


fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB  ->  b') in whilesFun (f)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB  ->  b) in whilesFun (f)), b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB = b') in whilesFun (f)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB  ->  b') in whilesFun (f)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB  ->  b') in whilesFun (f)), b)


fix:
let rec exprToString e = match e with
| VarX -> e

bad:
let rec exprToString e = match e with
| VarX -> x

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> x


fix:
let rec exprToString e = match e with
| VarX -> e

bad:
let rec exprToString e = match e with
| VarX -> e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> e


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
exprToString VarX

annotated:
exprToString VarX


fix:
exprToString VarX

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "Sin(" ^ (exprToString e1) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "Sin(" ^ (exprToString e1) ^ ")"


fix:
exprToString (VarX, VarY)

bad:
exprToString (Sine VarX)

annotated:
exprToString (Sine VarX)


fix:
exprToString (Sine VarX)

bad:
exprToString (Sine (Sine VarX))

annotated:
exprToString (Sine (Sine VarX))


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ (exprToString e1) ^ ")"
| Cosine e1 -> "cos(pi*" ^ (exprToString e1) ^ ")"
| Average (e1, e2) -> "((" ^ (exprToString e1) ^ "+" ^ (exprToString e2) ^ ")" ^ "/2)"

bad:
exprToString (Average(VarX,VarY))

annotated:
exprToString (Average(VarX,VarY))


fix:
exprToString (Sine (Cosine VarX))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ (exprToString e1) ^ ")"
| Cosine e1 -> "cos(pi*" ^ (exprToString e1) ^ ")"
| Average (e1, e2) -> "((" ^ (exprToString e1) ^ "+" ^ (exprToString e2) ^ ")" ^ "/2)"
| Times (e1, e2) -> (exprToString e1) ^ "*" ^ (exprToString e2)

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ (exprToString e1) ^ ")"
| Cosine e1 -> "cos(pi*" ^ (exprToString e1) ^ ")"
| Average (e1, e2) -> "((" ^ (exprToString e1) ^ "+" ^ (exprToString e2) ^ ")" ^ "/2)"
| Times (e1, e2) -> (exprToString e1) ^ "*" ^ (exprToString e2)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x


fix:
eval ((VarX * VarY), 1, 2)

bad:
eval

annotated:
eval


fix:
eval (Times (VarX,VarY), 1, 2)

bad:
eval (Times(VarX,VarY), 1, 2)

annotated:
eval (Times(VarX,VarY), 1, 2)


fix:
eval ((Sine (VarY)), 0.2, 0.3)

bad:
eval (Sine (VarX,VarY), 0.2, 0.3)

annotated:
eval (Sine (VarX,VarY), 0.2, 0.3)


fix:
eval ((Sine (VarY)), 0.2, 0.3)

bad:
eval ((Sine (VarX,VarY)), 0.2, 0.3)

annotated:
eval ((Sine (VarX,VarY)), 0.2, 0.3)


fix:
eval ((Sine (VarY)), 0.2, 0.3)

bad:
eval ((Sine (VarX, VarY)), 0.2, 0.3)

annotated:
eval ((Sine (VarX, VarY)), 0.2, 0.3)


fix:
eval ((Sine (VarY)), 0.2, 0.3)

bad:
eval ((Sine (VarX)), 0.2, 0.3)

annotated:
eval ((Sine (VarX)), 0.2, 0.3)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if ((eval (e1, x, y)) < (eval (e1, x, y))
then x
else y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))


fix:
eval ((Sine (VarX)), 1.0, 0.3)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if (eval (e1, x, y)) < (eval (e1, x, y))
then x
else y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if (eval (e1, x, y)) < (eval (e1, x, y))
then x
else y


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x * x +  in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x * x +  in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x * x in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x * x in
let base = a in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = base + (x * x) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = base + (x * x) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = f base (x * x) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = f base (x * x) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + (x * x) in
let base = a in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + (x * x) in
let base = a in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x f in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x f in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = pipe in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = pipe in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = pipe in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = pipe in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = [] in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = [] in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = "" in
let l = h :: t in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]

annotated:
let _ = sepConcat ", " ["foo";"bar";"baz"]


fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

*

annotated:
let _ = sepConcat "X" ["hello"]

*


fix:
let stringOfList f l = 
List.map (sepConcat "; ") l

bad:
let stringOfList f l = 
List.map sepConcat ("; ")

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map sepConcat ("; ")


fix:
let stringOfList f l = 
List.map (sepConcat "; ") l

bad:
let stringOfList f l = 
List.map sepConcat ("; " l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map sepConcat ("; " l)


fix:
let stringOfList f l = 
List.map (sepConcat "; ") l

bad:
let stringOfList f l = 
List.map sepConcat "; " l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map sepConcat "; " l


fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
List.map (sepConcat "; ") l l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat "; ") l l


fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
List.map (sepConcat "; " l) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat "; " l) l


fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
List.map (sepConcat ("; " l)) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat ("; " l)) l


fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
List.map (sepConcat ("; " l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat ("; " l))


fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
List.map (sepConcat "; " l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat "; " l)


fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
sepConcat "; " List.map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
sepConcat "; " List.map f l


fix:
let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ sepConcat "; " (List.map f l) "]"


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

pipe [] 3

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

pipe [] 3

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = function e -> e in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun ee in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun ee in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function e -> e in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun e in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun e in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function e -> e in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function e -> e in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = function e in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = function e in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a) in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  Nil in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  Nil in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let x a = a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let x a = a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a in
let base = fun x -> a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun x -> fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x (a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> fun a -> x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> fun a -> x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun (x a) -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun (x a) -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let x a = a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let x a = a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> a in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> a in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> a in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a -> a in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = let f x = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = let f x = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = fun x -> b in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x(a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x(a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x in x(a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x in x(a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x in a(a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x in a(a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x in a(x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x in a(x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x in x(x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x in x(x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> fun a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> fun a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x(a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun a -> a(a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun a -> a(a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun a -> x(x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun a -> x(x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> f x a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> f x a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x (a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> x (a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> (x a)  in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> (x a)  in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> (x a) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> (x a) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> (x (a)) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> (x (a)) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x - in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x - in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x  in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x  in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = f x
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = f x
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = f x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = f x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = fun x -> fun a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = fun x -> fun a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a(x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a(x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let rec padZero l1 l2 = 
(clone 0 List.len l1 - l2)

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
(clone 0 List.len l1 - l2)


fix:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let rec padZero l1 l2 = 
(clone 0 (List.len l1 - l2)) @ smaller

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
(clone 0 (List.len l1 - l2)) @ smaller


fix:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - l2)) @ smaller

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
(clone 0 (List.length l1 - l2)) @ smaller


fix:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - l2)) @ l2

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
(clone 0 (List.length l1 - l2)) @ l2


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = let a = x(a) in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x(a) in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = let a = x a in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let a = x a in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x' -> a x in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let x' = x' (x a) in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let x' = x' (x a) in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x' -> a x in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let x' = x' (x a) in x' x a in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = let x' = x' (x a) in x' x a in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x' -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x' -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' -> x' (a x) in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' -> x' (a x) in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x' -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' -> x' (x a) in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' -> x' (x a) in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let rec padZero l1 l2 = 
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

bad:
let rec padZero l1 l2 = 
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

padZero [9;9] [8;8;8]

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

padZero [9;9] [8;8;8]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = (l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = (l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = (0, 0) in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = (0, 0) in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [0] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [0] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [a] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [a] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [0, 0] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [0, 0] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [_, _] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [_, _] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [,] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [,] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [(), ()] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [(), ()] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  res in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  res in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let pipe fs = 
let f a x = fun x'-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' x a -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' x a -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x'-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' a-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x' a-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0 [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0 [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  (0, [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  (0, [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base = [0], [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base = [0], [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, ((sum mod 10) :: a))
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, ((sum mod 10) :: a))
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = [0, 0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = [0, 0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.len s == List.len x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.len s == List.len x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.lenth s == List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.lenth s == List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s == List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s == List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s = List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s = List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length (x)))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length (x)))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length a) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length a) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length x) = (List.length s))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length x) = (List.length s))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((h :: t) x = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((h :: t) x = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [(,)])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [(,)])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [(), ()])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [(), ()])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length x = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length x = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length a = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length a = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s != [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s != [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s != [])
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s != [])
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s = [])
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s = [])
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s)
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s)
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> c :: s
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> c :: s
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + x' + x'') :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + x' + x'') :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + x' + x'' + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + x' + x'' + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> ((c + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> ((c + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> ((c) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> ((c) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length s) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length a) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length a) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length s) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length x) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length x) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length s) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length x) = (List.length x) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length x) = (List.length x) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length l1) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length a) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length a) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
if i > 0
then bigAdd l (mulByDigit (i - 1) l)
else [0]

bad:
let rec mulByDigit i l = 
if i > 0
then bigAdd l (mulByDigit (i - 1) l)
else bigAdd [0]

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i > 0
then bigAdd l (mulByDigit (i - 1) l)
else bigAdd [0]


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = (1, []) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = failwith "to be implemented" in
let base = (1, []) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> mulByDigit h l' :: a

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> mulByDigit h l' :: a


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> (mulByDigit h l') :: a

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> (mulByDigit h l') :: a


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> (mulByDigit h l'), t

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> (mulByDigit h l'), t


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> ((mulByDigit h l'), t)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> ((mulByDigit h l'), t)


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> 
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> 
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i' l' = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i', l' = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let i', l' = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l')

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l')


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> t, bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> t, bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1')) a' in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1')) a' in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd ((mulByDigit (h l1')) a)' in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd ((mulByDigit (h l1')) a)' in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd ((mulByDigit (h l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd ((mulByDigit (h l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = x in
match a with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = x in
match a with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = x in
match a with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = x in
match a with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = x in
match a with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = x in
match a with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit h (l1') a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit h (l1') a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit h (l1')) a'

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit h (l1')) a'


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> li', bigAdd (mulByDigit h (l1')) a'

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> li', bigAdd (mulByDigit h (l1')) a'


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, 0) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, 0) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.hd (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.hd (List.rev List.hd l2)) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.hd (List.rev List.hd l2)) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.hd (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.hd (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki tt
| _ -> 0
in
helper d k l

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki tt
| _ -> 0
in
helper d k l


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
| _ -> 0

annotated:
| _ -> 0


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
| _ -> 0
in
helper d k l

annotated:
| _ -> 0
in
helper d k l


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
in
helper d k l

annotated:
in
helper d k l


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t

| _ -> 0
in
helper d k l

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t

| _ -> 0
in
helper d k l

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t

| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t


fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t

| _ -> 0
in
helper d k l

bad:
| _ -> 0
in
helper d k l

annotated:
| _ -> 0
in
helper d k l


fix:
let assoc (d,k,l) = 
match l with
| h::t -> h

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let assoc (d,k,l) = 
match l with
| h::t -> h

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

bad:
let assoc (d,k,l) = 
match l with
| h::t ->
let rec helper di ki li = 
let (name,age) = li in
if name = ki then di
else 
match li with
| h::t -> helper di ki t
| _-> di
in
helper d k h

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| h::t ->
let rec helper di ki li = 
let (name,age) = li in
if name = ki then di
else 
match li with
| h::t -> helper di ki t
| _-> di
in
helper d k h


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

bad:
let assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

in
helper d k h

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

in
helper d k h


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

bad:
let assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

in
helper d k h

annotated:
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

in
helper d k h


fix:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f,value)
else value

bad:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (func, boo)
else value

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in
let (value,boo) = func in
if boo then wwhile (func, boo)
else value


fix:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f,value)
else value

bad:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (func)
else value

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in
let (value,boo) = func in
if boo then wwhile (func)
else value


fix:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f,value)
else value

bad:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f)
else value

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in
let (value,boo) = func in
if boo then wwhile (f)
else value


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = f b in (xx, xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((f b, xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let xx = f b, xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = f b, xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = (f b), xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((f b, xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (((let xx = f b), xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((let xx = f b), xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (((let xx = (f b), xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((let xx = (f b), xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = (f b), xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  b*b*b in (xx, xx < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let f b = let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b = let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((b*b*b, b*b*b < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((b*b*b, b < 100),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((f b, false),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b, false),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let f b = let xx = f b in (xx, xx = b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = f b in (xx, xx  ->  b)),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx  ->  b)),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx  ->  b)),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx  ->  b),b)


fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = f x in (xx, xx  ->  b) in d b),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let xx = f x in (xx, xx  ->  b) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let xx = f x in (xx, xx  ->  b) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx  ->  b) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = (f x, x  ->  fx) in g,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = (f x, x  ->  fx) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = (f x, x  ->  f x) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = f x in (d, x  ->  d) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f b) in (d, x  ->  d) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = let (f b) in (d, x ! ->  d) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f b) in (d, x ! ->  d) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f x) in (d, x  ->  d) in g),b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f x) in (d, x  ->  d) in g),b)


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then age
else assoc(d,k,t)
| _-> d

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4

annotated:
^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
VarX = "x"
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
VarX = "x"
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
|VarX = "x"
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
|VarX = "x"
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with 
|VarX = x
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
|VarX = x
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = 
match e with 
|VarX = "x"
|VarY = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
|VarX = "x"
|VarY = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = 
match e with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString ex = 
match ex with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString ex = 
match ex with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString ex = 
match ex with 
(*|VarX = "x"
|VarY = "y"*)
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
(*|VarX = "x"
|VarY = "y"*)
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString ex = 
match ex with 
|VarX = ("x")
|VarY = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
|VarX = ("x")
|VarY = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString ex = 
match ex with 
|VarX -> ("x")
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
|VarX -> ("x")
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let random = makeRand(5,16) in
let _ = build(random,5)

annotated:
let random = makeRand(5,16) in
let _ = build(random,5)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let random = makeRand(5,16) in
let _ = build(random,5)

annotated:
let random = makeRand(5,16) in
let _ = build(random,5)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let random = makeRand(5,16) in
let _ = build(random,5)

annotated:
let random = makeRand(5,16) in
let _ = build(random,5)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let random = makeRand(5,16) in
build(random,5)

annotated:
let random = makeRand(5,16) in
build(random,5)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
Let _ = let random = makeRand(5,16) in
build(random,5)

annotated:
Let _ = let random = makeRand(5,16) in
build(random,5)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let _ = let random = makeRand(5,16) in
build(random,5)

annotated:
let _ = let random = makeRand(5,16) in
build(random,5)


fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(rand, depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(rand, depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()


fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then age
else assoc(d,k,t)
| _-> d

bad:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(makeRand(5,16), depth))
|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))
|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))
|_ -> buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(makeRand(5,16), depth))
|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))
|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))
|_ -> buildY()


fix:
let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"
|MyExpr2 (e) -> "halve("^exprToString^")"

bad:
let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"


fix:
let sampleExpr1 = MyExpr2(MyExpr1(Varx,VarY,Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))))

bad:
let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"
|MyExpr2 (e) -> "halve("^exprToString e^")"

annotated:
let rec exprToString : expr -> string = fun  ex  ->  
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"
|MyExpr2 (e) -> "halve("^exprToString e^")"


fix:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)

bad:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)


fix:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)

bad:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)


fix:
let sqsum xs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = ( +. ) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = ( +. ) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = ( +. ) in
let base = 0. in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = ( +. ) in
let base = 0. in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = ( +. ) in
let base = 0. in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = ( +. ) in
let base = 0. in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = ( + ) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = ( + ) in
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.map f x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = List.map f x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.map x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = List.map x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.map x -> x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = List.map x -> x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.map x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = List.map x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.map x in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = List.map x in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = base in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = base in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f x a in
let base = f x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f x a in
let base = f x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = f x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = f x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a' in
let base = a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a' in
let base = a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a x in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f a x in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = pipe a x in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = pipe a x in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = pipe a x in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = pipe a x in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = pipe fs in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = pipe fs in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = pipe base  in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = pipe base  in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = pipe fs  in
let base = 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = pipe fs  in
let base = 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x  in
let base = fun a -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x  in
let base = fun a -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = pipe [] in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = pipe [] in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = pipe [] in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x -> a in
let base = pipe [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x -> a in
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a -> x in
let base = pipe [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a -> x in
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = pipe [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a in
let base = pipe [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a in
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = pipe [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a-> a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a-> a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a-> a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a-> x in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a-> x in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d x -> g in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d x -> g in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d x -> a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d x -> a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> d in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a -> d in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> fun x a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a -> fun x a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x a -> fun d -> d in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fun a x -> fun d -> d

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> fun d -> d


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = fun p -> p in
List.fold_left f base fs

annotated:
let base = fun p -> p in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = fun p -> p in
List.fold_left f base fs

annotated:
let base = fun p -> p in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = fun p -> p in
List.fold_left f base fs

annotated:
let base = fun p -> p in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fun a x -> a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> a x


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = fun p -> p in
List.fold_left f base fs

annotated:
let base = fun p -> p in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = fun p -> p in
List.fold_left f base fs

annotated:
let base = fun p -> p in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = (fun p -> p) in
List.fold_left f base fs

annotated:
let base = (fun p -> p) in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fun p -> p

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> p


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = pipe [] in
List.fold_left f base fs

annotated:
let base = pipe [] in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fun p -> p

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> p


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = pipe [] in
List.fold_left f base fs

annotated:
let base = pipe [] in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = pipe [] in
List.fold_left f base fs

annotated:
let base = pipe [] in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let base = pipe [] in
List.fold_left f base fs

annotated:
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = pipe [] in
List.fold_left f base fs

annotated:
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = pipe [] in
List.fold_left f base fs

annotated:
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> x a


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d -> x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d -> x a


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d -> a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d -> a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun b a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun b a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun b a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x -> x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x -> x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> fun x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a -> fun x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> fun d in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a -> fun d in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun d -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> fun x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x a -> fun x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a ->  x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a ->  x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x ->  a x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun x ->  a x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun x ->  a x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun p a -> a x  in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun p a -> a x  in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun p a -> a x  in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = fun a x -> x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun a x -> x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a x -> x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x  in
let base = fun d-> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x  in
let base = fun d-> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun d-> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a in
let base = fun d-> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> a in
let base = fun d-> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun d ->  x a in
let base = fun d-> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d -> a in
let base = fun d-> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d -> a in
let base = fun d-> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d x -> a x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d x -> a x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> fun s a x -> a x

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> fun s a x -> a x


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> fun s a x -> x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> fun s a x -> x a


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> fun s a -> x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> fun s a -> x a


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let base = fun d -> d in
List.fold_left f base fs

annotated:
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> fun s a -> x a

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> fun s a -> x a


fix:
let pipe fs = 
let f a x = fun p -> fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun p -> fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun b (fun a -> x a) -> b in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun b (fun a -> x a) -> b in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun b (a -> x a) -> b in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun b (a -> x a) -> b in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a d -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a x -> x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x  in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = let p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x  in
let base = let p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x  in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = fun p -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x  in
let base = fun p -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x  in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x  in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x  in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x  in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.rev x in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = List.rev x in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base List.rev fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = fun p -> p in
List.fold_left f base List.rev fs


fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base List.rev fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = fun p -> p in
List.fold_left f base List.rev fs


fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in fun x-> x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in fun x-> x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)


fix:
let pipe fs = 
let f a x = x a  in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x fs in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x fs in
let base = fun p -> p in
List.fold_left f base (List.rev fs)


fix:
let pipe fs = 
let f a x = fun d-> x a d in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = fun d-> a x d in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun d-> a x d in
let base = fun p -> p in
List.fold_left f base (List.rev fs)


fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in
let base = fun p -> x p in
List.fold_left f base (List.rev fs)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = fun p -> x p in
List.fold_left f base (List.rev fs)


fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in
let base = fun p ->a  p in
List.fold_left f base (List.rev fs)

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base = fun p ->a  p in
List.fold_left f base (List.rev fs)


fix:
let pipe fs = 
let f a x = x a in
let base = fun a' -> a' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun a' -> a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun a' -> a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun a' -> a' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = fun a' -> a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = fun a' -> a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p' -> a x  in
let base = fun a' -> a' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p' -> a  in
let base = fun a' -> a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p' -> a  in
let base = fun a' -> a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  fun p -> a x in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a x in
let base = pipe [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a x in
let base = pipe [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =   in
let base = p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =   in
let base = p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> a x in
let base = p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> a x in
let base = p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p -> x a in
let base = p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun p -> x a in
let base = p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> fun x -> a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun l -> fun x -> a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun l -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun l -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun l -> fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun l -> x (a l) in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> l(x a) in
let base = fun p -> p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun l -> l(x a) in
let base = fun p -> p in
List.fold_left f base fs


fix:
let stringOfList f l = "["^ sepConcat "; " (List.map f l) ^"]"

bad:
let stringOfList f l = List.map f (sepConcat l);


let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l);


let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "["^ sepConcat "; " (List.map f l) ^"]"

bad:
let stringOfList f l = "["^ List.map f (sepConcat l) ^"]";


let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^ List.map f (sepConcat l) ^"]";


let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "["^ sepConcat "; " (List.map f l) ^"]"

bad:
let stringOfList f l = "["^ List.map f (sepConcat l) ^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^ List.map f (sepConcat l) ^"]"


fix:
let stringOfList f l = "["^ sepConcat "; " (List.map f l) ^"]"

bad:
let stringOfList f l = "["^ List.map f (sepConcat "; " l) ^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "["^ List.map f (sepConcat "; " l) ^"]"


fix:
let rec clone x n = 
if n < 1 then 
[]
else 
x::(clone x (n-1))

bad:
let rec clone x n = 
if n > 0 then 
x @ clone x n-1
else 
[]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n > 0 then 
x @ clone x n-1
else 
[]


fix:
let rec clone x n = 
if n < 1 then 
[]
else 
x::(clone x (n-1))

bad:
let rec clone x n = 
if n > 0 then 
x @ (clone x n-1)
else 
[]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n > 0 then 
x @ (clone x n-1)
else 
[]


fix:
let rec clone x n = 
if n < 1 then 
[]
else 
x::(clone x (n-1))

bad:
let rec clone x n = 
if n < 1 then 
[]
else 
x::(clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n < 1 then 
[]
else 
x::(clone x n-1)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let x = List.length l1 - List.length l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.length l1 < List.length l2 then
let x = List.length l2 - List.length l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

bad:
let padZero l1 l2 = 
if List.length l1 == List.length l2 then
(l1)@(l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 == List.length l2 then
(l1)@(l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let x = List.length l1 - List.length l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.length l1 < List.length l2 then
let x = List.length l2 - List.length l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then
l1 @ l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then
l1 @ l2


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let x = List.length l1 - List.length l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.length l1 < List.length l2 then
let x = List.length l2 - List.length l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

bad:
let padZero l1 l2 = 
if List.length l1 == List.length l2 then
l1 @ l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 == List.length l2 then
l1 @ l2


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let x = List.length l1 - List.length l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.length l1 < List.length l2 then
let x = List.length l2 - List.length l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

bad:
let padZero l1 l2 = 
if List.length l1 == List.length l2 then
(l1 @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 == List.length l2 then
(l1 @ l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let x = List.length l1 - List.length l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.length l1 < List.length l2 then
let x = List.length l2 - List.length l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

bad:
let padZero l1 l2 = 
if List.l1 > List.l2 then
let x = List.l1 - List.l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.l1 < List.l2 then
let x = List.l2 - List.l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.l1 > List.l2 then
let x = List.l1 - List.l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.l1 < List.l2 then
let x = List.l2 - List.l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)


fix:
let rec removeZero l = match l with
| [] -> []
| h::t ->
if h == 0 then 
removeZero t
else 
l

bad:
let rec removeZero l = match l with
| [] = []
| h::t = 
if h == 0 then 
removeZero t
else 
l

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| [] = []
| h::t = 
if h == 0 then 
removeZero t
else 
l


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy@initsum)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy@initsum)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy@initsum)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy@initsum)

bad:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy @ initsum)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy @ initsum)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy @ initsum)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy @ initsum)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ initsum)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ initsum)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ [initsum])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ [initsum])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ [initsum])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ [initsum])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ initsum)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ initsum)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ initsum) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ initsum) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-initKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-initKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-initKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-initKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@intKeep in
removeZero(list.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@intKeep in
removeZero(list.rev(helpy i l 0 [0,0]))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(list.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(list.rev(helpy i l 0 [0,0]))


fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0,0]))

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0,0]))


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = in
let base =  in
let args =  in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = in
let base =  in
let args =  in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match a with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal updateTotal in
(t,updateTotal)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (bottom_mult, total) = a in match a with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal updateTotal in
(t,updateTotal)


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal updateTotal in
(t,updateTotal)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal updateTotal in
(t,updateTotal)


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal total in
(t,updateTotal)

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal total in
(t,updateTotal)


fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal total in
(t,updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal total in
(t,updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x1->x1 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> x a in
let base = fun x1->x1 in
List.fold_left f base fs


fix:
let stringOfList f l = List.map (f (sepConcat " " l))

bad:
let stringOfList f l = List.map (f (sepconcat " " l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (f (sepconcat " " l))


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let stringOfList f l = sepConcat (" " List.map(f l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (" " List.map(f l))


fix:
let stringOfList f l = sepConcat " " l

bad:
let stringOfList f l = sepConcat (" " List.map(f l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (" " List.map(f l))


fix:
let stringOfList f l = sepConcat " " l

bad:
let stringOfList f l = sepConcat (" " (List.map(f l)))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (" " (List.map(f l)))


fix:
let rec clone x n = 
if (n <= 0) then []
else x::(clone x (n-1))

bad:
let rec clone x n = 
if (n <= 0) then []
else x::(clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if (n <= 0) then []
else x::(clone x n-1)


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10 in
let base = [] in
let args = failwith List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10 in
let base = [] in
let args = failwith List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10] in
let base = [] in
let args = failwith List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10] in
let base = [] in
let args = failwith List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = failwith List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = failwith List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| _ -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.rev(List.combine l1 l2) in
(*let (_, res) =*) List.fold_left f base args (*in
res*)
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| _ -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| _ -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l =  
let f a x = let mult = i*x in
match a with 
|h::t -> ((h+mult)/10)::(h+mult) mod 10::t
| _ -> mult/10::[mult mod 10] in
let base = [] in
removeZero (List.fold_left f base (List.rev l))

bad:
let rec mulByDigit i l = match l with 
let f a x = let mult = i*x in
match a with 
|h::t -> ((h+mult)/10)::(h+mult) mod 10::t
| _ -> mult/10::[mult mod 10] in
let base = [] in
removeZero (List.fold_left f base (List.rev l))

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match l with 
let f a x = let mult = i*x in
match a with 
|h::t -> ((h+mult)/10)::(h+mult) mod 10::t
| _ -> mult/10::[mult mod 10] in
let base = [] in
removeZero (List.fold_left f base (List.rev l))


fix:
let bigMul l1 l2 = 
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g

bad:
let bigMul l1 l2 = 
let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args


fix:
let bigMul l1 l2 = 
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g

bad:
let bigMul l1 l2 = 
let g =
let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let g =
let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g


fix:
let bigMul l1 l2 = 
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g

bad:
let bigMul l1 l2 = 
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g


fix:
let _ = mulByDigit (-9) [9;9;9;9]

bad:
let _ = mulByDigit -9 [9;9;9;9]

annotated:
let _ = mulByDigit -9 [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = match a with
|(move,result) -> match x with
|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in
(move +1, bigAdd result prod) in 
let base = (0,[]) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in 
let (_,res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
|(move,result) -> match x with
|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in
(move +1, bigAdd result prod) in 
let base = (0,[]) in
let args = List.combine (clone l1 (List.length l2)) (List.rev 12) in 
let (_,res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
|(move,result) -> match x with
|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in
(move +1, bigAdd result prod) in 
let base = (0,[]) in
let args = List.combine (clone l1 (List.length l2)) (List.rev 12) in 
let (_,res) = List.fold_left f base args in
res


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
if( h % 2) = 0 
then [] 
else tail

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
if( h % 2) = 0 
then [] 
else tail


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if( h % 2) = 0 
then [] 
else tail

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if( h % 2) = 0 
then [] 
else tail


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if( h mod 2) = 0 
then [] 
else tail

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if( h mod 2) = 0 
then [] 
else tail


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if( head mod 2) = 0 
then [] 
else tail

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if( head mod 2) = 0 
then [] 
else tail


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if( hd mod 2) = 0 
then [] 
else tl

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if( hd mod 2) = 0 
then [] 
else tl


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
|if( hd mod 2) = 0 
then [] 
else tl

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
|if( hd mod 2) = 0 
then [] 
else tl


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
|if( n < 0) -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
|if( n < 0) -> []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
|( n < 0) -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
|( n < 0) -> []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
| n < 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| n < 0 -> []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
| (n < 0) -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| (n < 0) -> []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if n < 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 -> []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if (n < 0) then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n < 0) then []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
| [] -> []
| h::t -> if (n < 0) then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| [] -> []
| h::t -> if (n < 0) then []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
| [] -> []
| _ -> if n < 0 then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| [] -> []
| _ -> if n < 0 then []


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = match n with
| _ -> if n < 0 then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| _ -> if n < 0 then []


fix:
let digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt(n/10)::[]

bad:
let digitsOfInt n = 
if n < 0 
then []
else if n < 10
then n:: []
else
digitsOfInt (n mod 10)

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
if n < 0 
then []
else if n < 10
then n:: []
else
digitsOfInt (n mod 10)


fix:
let digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt(n/10)::[]

bad:
let digitsOfInt n = 
if n < 0 
then []
else if n < 10
then n:: []
else
digitsOfInt (n / 10)

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
if n < 0 
then []
else if n < 10
then n:: []
else
digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n/10) @ (n mod 10)::[]

bad:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n/10) ::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 
then []
else
digitsOfInt (n/10) ::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n/10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 
then []
else
digitsOfInt (n/10)::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
let myList = []
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = []
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt n mod 10::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if n <= 0 
then []
else
digitsOfInt n mod 10::[]


fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

bad:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []


fix:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
if n < 10
then [n]
else
digitsOfInt (n/10) @ n mod 10 :: []

bad:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
if n < 10
then [num]
else
digitsOfInt (n/10) @ n mod 10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if n <= 0 
then []
else
if n < 10
then [num]
else
digitsOfInt (n/10) @ n mod 10 :: []


fix:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse(t)

bad:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse(t) :: l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
|[] -> [];
|h::t -> listReverse(t) :: l


fix:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse(t)

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse t @ [h]

bad:
let rec listReverse l = match l with
|[] -> [];
|h::t -> h:: [listReverse t]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
|[] -> [];
|h::t -> h:: [listReverse t]


fix:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse t @ [h]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let _ = digitsOfInt 352663

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = x*x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = failwith "to be implemented" in
let base = x*x in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = List.fold_left f a x in
let base = x*x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = List.fold_left f a x in
let base = x*x in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = List.fold_left f a b in
let base = x*x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = List.fold_left f a b in
let base = x*x in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = failwith "to be implemented" in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = failwith "to be implemented" in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = a(0) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = a(0) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = match base with
|0 -> 0
|_ -> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = match base with
|0 -> 0
|_ -> fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = match x with
|0 -> 0
|_ -> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = match x with
|0 -> 0
|_ -> fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = match fs with
|0 -> 0
|_ -> fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = match fs with
|0 -> 0
|_ -> fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a (x) in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a x in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f a x in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a x in
let base = x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f a x in
let base = x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> g in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g a x in
let base = function x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> g a x in
let base = function x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> g in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g x a in
let base = function x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> g x a in
let base = function x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> g in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g(x a) in
let base = function x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> g(x a) in
let base = function x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> g in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g(x) in
let base = function x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> g(x) in
let base = function x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g (a(x)) in
let base = function x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> g (a(x)) in
let base = function x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> a( x g)  in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g( a x) in
let base = function x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> g( a x) in
let base = function x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> x (a g)  in
let base = function b -> b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> function x (a x)  in
let base = function b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> function x (a x)  in
let base = function b -> b in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> x (a g)  in
let base = function b -> b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> function z (a x)  in
let base = function b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> function z (a x)  in
let base = function b -> b in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = function g -> x (a g)  in
let base = function b -> b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> function z (a z)  in
let base = function b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = function g -> function z (a z)  in
let base = function b -> b in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if x.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if x.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if sl.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if sl.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if t.length = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if t.length = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length() = 0
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(l) = 0
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(l) = 0
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) > 2
then a ^ x ^ sep
else x ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) > 2
then a ^ x ^ sep
else x ^ x in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) > 2
then a ^ x ^ sep
else x ^ x in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l


fix:
let _ = sepConcat "---" ["a"]

bad:
let _ = sepConcat "---" [a]

annotated:
let _ = sepConcat "---" [a]


fix:
let stringOfList f l = sepConcat ";" (List.map f l)

bad:
let stringOfList f l = sepConcat ";" List.map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat ";" List.map f l


fix:
let stringOfList f l = 
let string str = sepConcat "; " (List.map (f) l )
in "[" ^str ^ "]"

bad:
let stringOfList f l = let

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  let


fix:
let stringOfList f l = 
let string str = sepConcat "; " (List.map (f) l )
in "[" ^str ^ "]"

bad:
val str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"

annotated:
val str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"


fix:
let stringOfList f l = 
let string str = sepConcat "; " (List.map (f) l )
in "[" ^str ^ "]"

bad:
let stringOfList f l = let

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  let


fix:
let stringOfList f l = 
let string str = sepConcat "; " (List.map (f) l )
in "[" ^str ^ "]"

bad:
val str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"

annotated:
val str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"


fix:
let stringOfList f l = 
let string str = sepConcat "; " (List.map (f) l )
in "[" ^str ^ "]"

bad:
let stringOfList f l = 
let string str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
let string str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"


fix:
let rec clone x n = 
if n < 1
then []
else x:: (clone x (n-1))

bad:
let rec clone x n = 
if n =< 0
then []
else h::t ->
x::clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n =< 0
then []
else h::t ->
x::clone x n-1


fix:
let rec clone x n = 
if n < 1
then []
else x:: (clone x (n-1))

bad:
let rec clone x n = match n with
|0 -> []
|h::t ->
x::clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
|0 -> []
|h::t ->
x::clone x n-1


fix:
let rec clone x n = 
if n < 1
then []
else x:: (clone x (n-1))

bad:
let rec clone x n = 
if n =< 0
then []
else x::clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n =< 0
then []
else x::clone x n-1


fix:
let rec clone x n = 
if n < 1
then []
else x:: (clone x (n-1))

bad:
let rec clone x n = 
if n < 1
then []
else x::clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n < 1
then []
else x::clone x n-1


fix:
let rec clone x n = 
if n < 1
then []
else x:: (clone x (n-1))

bad:
let rec clone x n = 
if n < 1
then []
else x:: (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n < 1
then []
else x:: (clone x n-1)


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then "hi"
else "bye"

bad:
let padZero l1 l2 = 
let int a = List.length(l1) - List.length(l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let int a = List.length(l1) - List.length(l2)


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then "hi"
else "bye"

bad:
let padZero l1 l2 = 
let int a = List.length(l1) - List.length(l2) in
if a > 0
then "hi"
else "bye"

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let int a = List.length(l1) - List.length(l2) in
if a > 0
then "hi"
else "bye"


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(clone 0 a))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then l1 * (clone 0 a)
else "bye"

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then l1 * (clone 0 a)
else "bye"


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(clone 0 a))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then l1 * (clone 0 a)
else l1 * l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then l1 * (clone 0 a)
else l1 * l2


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(clone 0 a))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1 * (clone 0 a))
else l1 * l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1 * (clone 0 a))
else l1 * l2


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(clone 0 a))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1 * (clone 0 a))
else (l1 * l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1 * (clone 0 a))
else (l1 * l2)


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.apend (clone 0 a) l2))
else (l1,l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.apend (clone 0 a) l2))
else (l1,l2)


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else ((List.append (clone 0 (0-a)) l1), l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (List.append ( clone 0 (0 -a)) l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (List.append ( clone 0 (0 -a)) l2)


fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else ((List.append (clone 0 (0-a)) l1), l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (List.append ( clone 0 (0 -a)), l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (List.append ( clone 0 (0 -a)), l2)


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let rec digitsOfInt n =
match n with
| < 0 0
| >= 0 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| < 0 0
| >= 0 1


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let rec digitsOfInt n =
match n with
| <0 0
| >=0 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| <0 0
| >=0 1


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let rec digitsOfInt n =
match n with
| 1
| _ 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| 1
| _ 1


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let rec digitsOfInt n =
match n with
| 1 0
| _ 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| 1 0
| _ 1


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let rec digitsOfInt n =
match n with
| < 1 -> 0
| >= 0 -> 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| < 1 -> 0
| >= 0 -> 1


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> []

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n <= 0 with
| true -> []
| false -> 1


fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> []

bad:
let _ = 100 >> 2

annotated:
let _ = 100 >> 2


fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n div 10 :: [n mod 10]

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> (digitsOfInt n/10) @ [n%10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n <= 0 with
| true -> []
| false -> (digitsOfInt n/10) @ [n%10]


fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n div 10 :: [n mod 10]

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> [digitsOfInt n/10] @ [n%10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n <= 0 with
| true -> []
| false -> [digitsOfInt n/10] @ [n%10]


fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n div 10 :: [n mod 10]

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n/10 @ [n%10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n <= 0 with
| true -> []
| false -> digitsOfInt n/10 @ [n%10]


fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n div 10 :: [n mod 10]

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> [n%10] @ digitsOfInt n/10

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n <= 0 with
| true -> []
| false -> [n%10] @ digitsOfInt n/10


fix:
let rec listReverse l =
match l with
| []	    -> []
| (_ :: h :: [])  -> h :: listReverse []

bad:
let rec listReverse l =
match l with
| []	    -> []
| (t :: h :: [])  -> h :: listReverse t::[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| []	    -> []
| (t :: h :: [])  -> h :: listReverse t::[]


fix:
let rec listReverse l =
match l with
| []	    -> []
| (_ :: h :: [])  -> h :: listReverse []

bad:
let rec listReverse l =
match l with
| []	    -> []
| (t :: h :: [])  -> h :: listReverse t

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| []	    -> []
| (t :: h :: [])  -> h :: listReverse t


fix:
let _ = digitsOfInt 2401

bad:
let _ = digitsOfInt -2401

annotated:
let _ = digitsOfInt -2401


fix:
let _ = digitsOfInt (-1)

bad:
let _ = digitsOfInt -2401

annotated:
let _ = digitsOfInt -2401


fix:
let _ = digitsOfInt (-1)

bad:
let _ = digitsOfInt -1

annotated:
let _ = digitsOfInt -1


fix:
let _ = digitsOfInt 0

bad:
let _ = digitsOfInt asr

(* digits : int -> int list
* (digits n) is the list of digits of n in the order in which they appear
* in n
* e.g. (digits 31243) is [3,1,2,4,3]
*      (digits (-23422) is [2,3,4,2,2]
*)

let digits n = digitsOfInt (abs n)

annotated:
let _ = digitsOfInt asr

(* digits : int -> int list
* (digits n) is the list of digits of n in the order in which they appear
* in n
* e.g. (digits 31243) is [3,1,2,4,3]
*      (digits (-23422) is [2,3,4,2,2]
*)

let digits n = digitsOfInt (abs n)


fix:
let _ = digitsOfInt ~-21041

bad:
let _ = digitsOfInt -21041

annotated:
let _ = digitsOfInt -21041


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
if (explode(w)) = (listReverse (explode(w)))
then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if (explode(w)) = (listReverse (explode(w)))
then true
else false


fix:
let rec wwhile (f,b) =
match f(b-1) with
| (_, false) -> b
| (bb, true) -> wwhile(f, bb)

bad:
xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) = f(b-1)) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b) = wwhile (fun ff b -> (f(b), f(b)  ->  f(b-1)) ,b)


fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b) = wwhile (fun ff b -> (f(b), f(b) ! ->  f(b-1)) ,b)


fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let ff (b) =
(f(b), f(b) != f(b-1)
in
let fixpoint (f, b) = wwhile (ff ,b)

annotated:
let ff (b) =
(f(b), f(b) != f(b-1)
in
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  wwhile (ff ,b)


fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let ff (b) =
(f(b), f(b) != f(b-1))
in
let fixpoint (f, b) = wwhile (ff ,b)

annotated:
let ff (b) =
(f(b), f(b) != f(b-1))
in
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  wwhile (ff ,b)


fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let ff (b) =
(f(b), f(b) != f(b-1))
in
let fixpoint (f, b) = wwhile (ff, b)

annotated:
let ff (b) =
(f(b), f(b) != f(b-1))
in
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  wwhile (ff, b)


fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f, b) = 
let ff (b) =
(f(b), f(b) != f(b-1))
in
wwhile (ff, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  
let ff (b) =
(f(b), f(b) != f(b-1))
in
wwhile (ff, b)


fix:
true || false

bad:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
true || false

bad:
let collatz n =

annotated:
let collatz n =


fix:
true || false

bad:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

annotated:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1


fix:
true || false

bad:
let _ = fixpoint (collatz, 1)

annotated:
let _ = fixpoint (collatz, 1)


fix:
true || false

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
true || false

bad:
let _ = fixpoint (collatz, 48)

annotated:
let _ = fixpoint (collatz, 48)


fix:
true || false

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
true || false

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
true || false

bad:
*

annotated:
*


fix:
true || false

bad:
)

annotated:
)


fix:
let _ = fixpoint (collatz, 3)

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || b ! ->  f(b-1))), b)


fix:
let _ = fixpoint (collatz, 3)

bad:
let g x = trunca

annotated:
let g x = trunca


fix:
let _ = fixpoint (collatz, 3)

bad:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let _ = fixpoint (collatz, 3)

bad:
let collatz n =

annotated:
let collatz n =


fix:
let _ = fixpoint (collatz, 3)

bad:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

annotated:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1


fix:
let _ = fixpoint (collatz, 3)

bad:
let _ = fixpoint (collatz, 1)

annotated:
let _ = fixpoint (collatz, 1)


fix:
let _ = fixpoint (collatz, 3)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)

bad:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)

bad:
let collatz n =

annotated:
let collatz n =


fix:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let collatz n =

annotated:
let collatz n =


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)

bad:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

annotated:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)

bad:
let _ = fixpoint (collatz, 1)

annotated:
let _ = fixpoint (collatz, 1)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) ! ->  f(f(b))), b)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let g x = trunca

annotated:
let g x = trunca


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) ! ->  f(f(b)))) , b)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let g x = trunca

annotated:
let g x = trunca


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let collatz n =

annotated:
let collatz n =


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

annotated:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let _ = fixpoint (collatz, 1)

annotated:
let _ = fixpoint (collatz, 1)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
 (collatz, 3)

annotated:
 (collatz, 3)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
 (collatz, 48)

annotated:
 (collatz, 48)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
*

annotated:
*


fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

bad:
)

annotated:
)


fix:
exp 2.

bad:
exp 2

annotated:
exp 2


fix:
exp 2.

bad:
let _ = fixpoint (

annotated:
let _ = fixpoint (


fix:
let _ = fixpoint (exp, -1)

bad:
let _ = fixpoint (exp, 1)

annotated:
let _ = fixpoint (exp, 1)


fix:
let _ = fixpoint (exp, -1)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let _ = fixpoint (exp, -1)

bad:
let _ = fixpoint (exp, 1.)

annotated:
let _ = fixpoint (exp, 1.)


fix:
let _ = fixpoint (exp, -1)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let _ = fixpoint ((fun b -> b ** 2), 0.)

bad:
let _ = fixpoint (exp, 0)

annotated:
let _ = fixpoint (exp, 0)


fix:
let _ = fixpoint ((fun b -> b ** 2), 0.)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let _ = fixpoint ((fun b -> b ** 2), 0.)

bad:
let _ = fixpoint (exp, 0.)

annotated:
let _ = fixpoint (exp, 0.)


fix:
let _ = fixpoint ((fun b -> b ** 2), 0.)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
0. ** 2

bad:
let _ = fixpoint ((fun b -> b ** 2.), 0.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 0.)


fix:
0. ** 2

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
1. != 1.

bad:
let _ = fixpoint ((fun b -> b ** 2.), 1.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 1.)


fix:
1. != 1.

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
(1. = 1.)

bad:
!(1. = 1.)

annotated:
!(1. = 1.)


fix:
(1. = 1.)

bad:
let _ = fixpoint (

annotated:
let _ = fixpoint (


fix:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) != f(f(b))))) , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) ! ->  f(f(b))))) , b)


fix:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = trunca

annotated:
let g x = trunca


fix:
 ((fun b -> b ** 4.), 0.)

bad:
let _ = fixpoint ((fun b -> b ** 2.), 1.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 1.)


fix:
 ((fun b -> b ** 4.), 0.)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
 ((fun b -> b ** 4.), 0.)

bad:
let _ = fixpoint ((fun b -> b ** 2.), 0.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 0.)


fix:
 ((fun b -> b ** 4.), 0.)

bad:
let _ = fixpoint ((fun b -> b ** 2.), 1.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 1.)


fix:
 ((fun b -> b ** 4.), 0.)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
 (sqrt, 12489124)

bad:
let _ = fixpoint ((fun b -> b ** 2.), 0.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 0.)


fix:
 (sqrt, 12489124)

bad:
let _ = fixpoint ((fun b -> b ** 2.), 1.)

annotated:
let _ = fixpoint ((fun b -> b ** 2.), 1.)


fix:
 (sqrt, 12489124)

bad:
let _ = fixpoint ((fun b -> b ** 4.), 0.)

annotated:
let _ = fixpoint ((fun b -> b ** 4.), 0.)


fix:
 (sqrt, 12489124)

bad:
let _ = fixpoint ((fun b -> b ** 4.), 1.)

annotated:
let _ = fixpoint ((fun b -> b ** 4.), 1.)


fix:
 (sqrt, 12489124)

bad:
let _ = fixpoint (sqrt, 10.)

annotated:
let _ = fixpoint (sqrt, 10.)


fix:
 (sqrt, 12489124)

bad:
let _ = fixpoint

annotated:
let _ = fixpoint


fix:
let rec exprToString e = 
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" exprToString(y) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

bad:
let rec exprToString e = 
match e with
| VarX _ -> "x"
| VarY _ -> "y"
| Sine x -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y) -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX _ -> "x"
| VarY _ -> "y"
| Sine x -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y) -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"


fix:
let rec exprToString e = 
match e with
| VarX		    -> "x"
| VarY		    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(b) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

bad:
let rec exprToString e = 
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(y) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(y) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)


fix:
let rec exprToString e = 
match e with
| VarX		    -> "x"
| VarY		    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(b) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

bad:
let rec exprToString e = 
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(b) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(b) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi * eval (a,x,y))
| Cosine a -> cos (pi * eval (a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi * eval (a,x,y))
| Cosine a -> cos (pi * eval (a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi *. eval (a,x,y))
| Cosine a -> cos (pi *. eval (a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi *. eval (a,x,y))
| Cosine a -> cos (pi *. eval (a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)


fix:
let _ = eval (mySampleExpr3, 1.,2.)

bad:
let _ = eval (mySampleExpr3, 1,2)

annotated:
let _ = eval (mySampleExpr3, 1,2)


fix:
let _ = eval (mySampleExpr3, 1.,2.)

bad:
let _ = eval (mySampleExpr3, 14,14)

annotated:
let _ = eval (mySampleExpr3, 14,14)


fix:
let _ = eval (mySampleExpr3, 1.,2.)

bad:
let _ = eval (mySampleExpr3, 1203,12)

annotated:
let _ = eval (mySampleExpr3, 1203,12)


fix:
let pipe fs = 
let f a x = x a in
let base = (fun a -> a) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun a -> a) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun a -> a) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = failwith "to be implemented" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs b = 
let f a x = x(a) in
let base = b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = rec x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = rec x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = x in
List.fold_left f base fs


fix:
let pipe fs b = 
let f a x = x(a) in
let base = b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs b = 
let f a x = x(a) in
let base = b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs b = 
let f a x = x(a) in
let base = b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let _ = pipe []

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x(a) in
let base = "" in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = (fun x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base = (fun x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x(a) in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function | a -> a in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = function | a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = int in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = int in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = function | a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = function in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = function in
List.fold_left f base fs


fix:
let pipe fs = fun x' ->
let f a x = x a in
let base = x' in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = fun x' ->
let f a x = x a in
let base = x' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = int a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = int a in
List.fold_left f base fs


fix:
let pipe fs = fun x' ->
let f a x = x a in
let base = x' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = b of int in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = b of int in
List.fold_left f base fs


fix:
let _ = stringOfList (fun x -> string_of_int(5*x)) [1;2;3;4;5;6]

bad:
let _ = stringOfList (string_of_int fun x -> 5*x) [1;2;3;4;5;6]

annotated:
let _ = stringOfList (string_of_int fun x -> 5*x) [1;2;3;4;5;6]


fix:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: clone x (n-1)

bad:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> [x] @ (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
match n > 0 with
| false -> []
| true  -> [x] @ (clone x n-1)


fix:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: clone x (n-1)

bad:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: (clone (x n-1))

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
match n > 0 with
| false -> []
| true  -> x :: (clone (x n-1))


fix:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: clone x (n-1)

bad:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
match n > 0 with
| false -> []
| true  -> x :: clone x n-1


fix:
let padZero l1 l2 = 
match List.length l1 = List.length l2 with
| true -> (l1, l2)
| false ->
let lendiff = List.length l1 - List.length l2 in
match lendiff > 0 with
| true  -> (l1, (clone 0 lendiff) @ l2)
| false -> ((clone 0 (-lendiff)) @ l1, l2)

bad:
let padZero l1 l2 = 
match List.length l1 = List.length l2 with
| true -> (l1, l2)
| false ->
let lendiff = List.length l1 - List.length l2 in
match lendiff > 0 with
| true  -> (l1, (clone 0 lendiff) @ l2)
| false -> ((clone 0 -lendiff) @ l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
match List.length l1 = List.length l2 with
| true -> (l1, l2)
| false ->
let lendiff = List.length l1 - List.length l2 in
match lendiff > 0 with
| true  -> (l1, (clone 0 lendiff) @ l2)
| false -> ((clone 0 -lendiff) @ l1, l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
List.fold_left f base args
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
List.fold_left f base args
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) mod 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) % 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = ((x + y) % 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) / 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) % 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = ((x + y) % 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
(add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h % 10] @ t
in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
(add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h % 10] @ t
in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
(add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZeros (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZeros (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
let f a x = 
match a with
| [] -> (i * x) :: a 
| h :: t -> [i * x + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(0 :: l) in
List.fold_left f base args

bad:
let rec mulByDigit i l = 
let f a x = 
match a with
| [] -> (i * x) :: a 
| h :: t -> [x * y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(0 :: l) in
List.fold_left f base args

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f a x = 
match a with
| [] -> (i * x) :: a 
| h :: t -> [x * y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(0 :: l) in
List.fold_left f base args


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match a with
| []      -> (mulByDigit x l2) :: a
| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t 
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
match a with
| []      -> (mulByDigit x l2) :: a
| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t 
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match a with
| []      -> (mulByDigit x l2) :: a
| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t 
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
match a with
| []      -> (mulByDigit x l2) :: a
| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t 
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res


fix:
let test = mulByDigit 1 [1;0]

bad:
let test = mulByDigit 1 [1;0]
List.rev test

annotated:
let test = mulByDigit 1 [1;0]
List.rev test


fix:
let test = mulByDigit 1 [1;0]

bad:
let test = mulByDigit 1 [1;0]
List.rev test

annotated:
let test = mulByDigit 1 [1;0]
List.rev test


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| x::y -> x + sumList y

bad:
let rec sumList xs = 
match xs with
| [] -> 0
| [x] -> x
| [x::y] -> x + sumList y

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> 0
| [x] -> x
| [x::y] -> x + sumList y


fix:
let rec sumList xs = 
match xs with
| [] -> 0
| x::y -> x + sumList y

bad:
let rec sumList xs = 
match xs with
| [] -> 0
| [x::y] -> x + sumList y

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> 0
| [x::y] -> x + sumList y


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
match n with
| n < 0 -> []
| n > 0 -> (n % 10)::digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| n < 0 -> []
| n > 0 -> (n % 10)::digitsOfInt (n / 10)


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
match n with
| n <= 0 -> []
| n > 0 -> (n % 10)::digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| n <= 0 -> []
| n > 0 -> (n % 10)::digitsOfInt (n / 10)


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
match n with
| n <= 0 -> []
| n < 10 -> [n]
| n > 0 -> (n % 10)::digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
| n <= 0 -> []
| n < 10 -> [n]
| n > 0 -> (n % 10)::digitsOfInt (n / 10)


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n < 0 then []
else match n with
| a -> [a]
| a^b -> a::digitsOfInt b

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match n with
| a -> [a]
| a^b -> a::digitsOfInt b


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n < 0 then []
else match n with
| a -> [a]
| ab -> a::digitsOfInt b

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else match n with
| a -> [a]
| ab -> a::digitsOfInt b


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n == 0 then 0
else digitsOfInt (n / 10) :: (n % 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n == 0 then 0
else digitsOfInt (n / 10) :: (n % 10)


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n == 0 then []
else digitsOfInt (n / 10) :: (n % 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n == 0 then []
else digitsOfInt (n / 10) :: (n % 10)


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n == 0 then 0
else  digitsOfInt (n / 10) @ [n % 10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n == 0 then 0
else  digitsOfInt (n / 10) @ [n % 10]


fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n % 10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else digitsOfInt (n / 10) @ [n % 10]


fix:
let rec additivePersistence n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else
1 + additivePersistence sum

bad:
let rec additivePersistence n =
let sum = sumList digitsOfInt n in
if (sum < 10) then 1
else
1 + additivePersistance sum

annotated:
let rec additivePersistence : int -> int = fun  n  -> 
let sum = sumList digitsOfInt n in
if (sum < 10) then 1
else
1 + additivePersistance sum


fix:
let rec additivePersistence n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else
1 + additivePersistence sum

bad:
let rec additivePersistence n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else
1 + additivePersistance sum

annotated:
let rec additivePersistence : int -> int = fun  n  -> 
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else
1 + additivePersistance sum


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> b :: listReverse a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> b :: listReverse a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> b :: listReverse [a]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> b :: listReverse [a]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b @ a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b :: a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b :: a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b @ a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: [b] -> listReverse [b] @ a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: [b] -> listReverse [b] @ a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse (b) @ a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse (b) @ a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b @ a


fix:
let _ = digitsOfInt 3124

bad:
let palindrome w =
let wList = explode (w) in
let wReverse = listReverse (explode (w)) in
if (true) then wList

annotated:
let palindrome : string -> bool = fun  w  -> 
let wList = explode (w) in
let wReverse = listReverse (explode (w)) in
if (true) then wList


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
(*| a :: b -> listReverse b @ [a] ;;*)
| [a] @ b -> b :: listReverse a

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
(*| a :: b -> listReverse b @ [a] ;;*)
| [a] @ b -> b :: listReverse a


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ [a]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b @ [a]


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n < 10 then [n]
else (n mod 10) :: digitsOfInt (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n < 10 then [n]
else (n mod 10) :: digitsOfInt (n/10)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n < 10 then [n]
else digitsOfInt (n/10) :: [n mod 10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n < 10 then [n]
else digitsOfInt (n/10) :: [n mod 10]


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n > 10 then digitsOfInt (n / 10) :: [n mod 10]
else n

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n > 10 then digitsOfInt (n / 10) :: [n mod 10]
else n


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else if n > 10 then digitsOfInt(n mod 10)
else
let a = n mod 10 in
let b = n / 10 in
if b = 0 then [n]
else a :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n = 0 then [0]
else if n > 10 then digitsOfInt(n mod 10)
else
let a = n mod 10 in
let b = n / 10 in
if b = 0 then [n]
else a :: []


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else if n > 99 then digitsOfInt(n mod 10)
else
let a = n mod 10 in
let b = n / 10 in
if b = 0 then [n]
else a :: digitsOfInt n

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n = 0 then [0]
else if n > 99 then digitsOfInt(n mod 10)
else
let a = n mod 10 in
let b = n / 10 in
if b = 0 then [n]
else a :: digitsOfInt n


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
let s = string_of_int n in
match s with
| a -> [a]
| a ^ b -> a :: digitsOfInt b

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let s = string_of_int n in
match s with
| a -> [a]
| a ^ b -> a :: digitsOfInt b


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
let s = string_of_int n in
match s with
| a -> [a]
| a ^ b -> a :: digitsOfInt b

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let s = string_of_int n in
match s with
| a -> [a]
| a ^ b -> a :: digitsOfInt b


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else if n < 10 then [n]
else (n mod 10) :: digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else if n = 0 then [0]
else if n < 10 then [n]
else (n mod 10) :: digitsOfInt (n / 10)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else
let a = n / 10 in
let b = n mod 10 in
let c = [a; b] in
c

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else
let a = n / 10 in
let b = n mod 10 in
let c = [a; b] in
c


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else
let a = n / 10 in
let b = n mod 10 in
let c = [a; b] in
if a < 10 then c
else digitsOfInt (a / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []
else
let a = n / 10 in
let b = n mod 10 in
let c = [a; b] in
if a < 10 then c
else digitsOfInt (a / 10)


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ [a]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b @ [a]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
match l with
| [] -> []
| a :: b -> let c = listReverse b in

annotated:
match l with
| [] -> []
| a :: b -> let c = listReverse b in


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> let c = listReverse b in
match c with
| [] -> []
| d :: e -> [d; a]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> let c = listReverse b in
match c with
| [] -> []
| d :: e -> [d; a]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> [listReverse b ; [a]]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> [listReverse b ; [a]]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| b :: [] -> b :: []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| b :: [] -> b :: []


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| [a;b] -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| [a;b] -> 0


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| [a;b] -> [a]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| [a;b] -> [a]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let last t =
match t with
| [] -> []
| [a] -> a
| a :: b -> last b
in
last t :: listReverse l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let last t =
match t with
| [] -> []
| [a] -> a
| a :: b -> last b
in
last t :: listReverse l


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse b


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse [a]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
match l with
| [] -> []
| a :: b -> listReverse [a]


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let last t = function
match t with
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let last t = function
match t with
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let last t = function
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let last t = function
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let rec last t =
match t with
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec last t =
match t with
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l


fix:
let rec listReverse l =
let a = [] in
let get b = function
| [] -> []
| x :: xs -> x :: a
in get l

bad:
let rec listReverse l =
let a = [] in
let getHead b = function
match b with
| [] -> []
| x :: xs ->
x :: a
getHead xs
in getHead l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let a = [] in
let getHead b = function
match b with
| [] -> []
| x :: xs ->
x :: a
getHead xs
in getHead l


fix:
let rec listReverse l =
let a = [] in
let get b = function
| [] -> []
| x :: xs -> x :: a
in get l

bad:
let rec listReverse l =
let a = [] in
let getHead b = function
| [] -> []
| x :: xs ->
x :: a
getHead xs
in getHead l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let a = [] in
let getHead b = function
| [] -> []
| x :: xs ->
x :: a
getHead xs
in getHead l


fix:
let rec listReverse l =
let a = [] in
let get b = function
| [] -> []
| x :: xs -> x :: a
in get l

bad:
let rec listReverse l =
let a = [] in
let rec get a =
match a with
| [] -> []
| x :: xs -> get xs :: [x]
in get l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let a = [] in
let rec get a =
match a with
| [] -> []
| x :: xs -> get xs :: [x]
in get l


fix:
let rec listReverse l =
let a = [] in
let get b = function
| [] -> []
| x :: xs -> x :: a
in get l

bad:
let rec listReverse l =
let a = [] in
let get a = function
| [] -> []
| x :: xs -> x :: a
in get l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let a = [] in
let get a = function
| [] -> []
| x :: xs -> x :: a
in get l


fix:
let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
let rec integers a b =
match a with
| [] -> b
| x :: xs -> integers xs ((a mod 10)::b)
in integers n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let rec integers a b =
match a with
| [] -> b
| x :: xs -> integers xs ((a mod 10)::b)
in integers n []


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []


fix:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []

bad:
et _ = digitsOfInt 3124

annotated:
et _ = digitsOfInt 3124


fix:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if d = s then l
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| s * l ->
if d = s then l
else assoc (d, k, t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| []      ->
d
| h :: t  ->
match h with
| s * l ->
if d = s then l
else assoc (d, k, t)


fix:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if d = s then l
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s * l) ->
if d = s then l
else assoc (d, k, t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| []      ->
d
| h :: t  ->
match h with
| (s * l) ->
if d = s then l
else assoc (d, k, t)


fix:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec wwhile (f,b) =
match (b',c')=(f b) in

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
match (b',c')=(f b) in


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec wwhile (f,b) =
match (f b) in
| (b',c') -> 0

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
match (f b) in
| (b',c') -> 0


fix:
let fixpoint (f,b) =
wwhile (f ? false : true,b)

bad:
let fixpoint (f,b) =
wwhile (f f b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (f f b,b)


fix:
let fixpoint (f,b) =
wwhile (f ? false : true,b)

bad:
let fixpoint (f,b) =
wwhile (,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (,b)


fix:
let fixpoint (f,b) =
wwhile ((f b) b,b)

bad:
let fixpoint (f,b) =
wwhile (f b = b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (f b = b,b)


fix:
let fixpoint (f,b) =
wwhile ((f b) b,b)

bad:
let fixpoint (f,b) =
wwhile (fun x -> f x = b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun x -> f x = b,b)


fix:
let fixpoint (f,b) =
wwhile ((f b) b,b)

bad:
let fixpoint (f,b) =
wwhile (fun x -> (f x = b,b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun x -> (f x = b,b),b)


fix:
let fixpoint (f,b) =0

bad:
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) =
wwhile ((f b) b,b)

bad:
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile (equ f b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (equ f b,b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile (if b=(f b) then true else false,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (if b=(f b) then true else false,b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile ((b,f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((b,f b = b),b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile (fun b -> (b,f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun b -> (b,f b = b),b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile (fun b -> (b,(f b) = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun b -> (b,(f b) = b),b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile ((f b <> b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((f b <> b),b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile (fun b -> (f b <> b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun b -> (f b <> b),b)


fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

bad:
let fixpoint (f,b) =
wwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile (not ((f b)=b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (not ((f b)=b),b)


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile ((not f),((f b)=b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((not f),((f b)=b),b)


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile (fun x -> not x,(f b)=b),b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun x -> not x,(f b)=b),b


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile (x -> not x,(f b)=b),b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (x -> not x,(f b)=b),b


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile ((x -> not x,(f b)=b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((x -> not x,(f b)=b),b)


fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile ((f,(f b)=b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((f,(f b)=b),b)


fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
let
wwhile (fun f -> (f,(f b)=b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let
wwhile (fun f -> (f,(f b)=b),b)


fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
wwhile (fun f -> (f,(f b)=b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun f -> (f,(f b)=b),b)


fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
wwhile ((f,(f b) = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile ((f,(f b) = b),b)


fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
wwhile (f -> (not f,(f b) = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (f -> (not f,(f b) = b),b)


fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
wwhile (let x -> not f in (x,(f b) = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let x -> not f in (x,(f b) = b),b)


fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
wwhile (let x = not f in (x,(f b) = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let x = not f in (x,(f b) = b),b)


fix:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (0,true) in func b,b)

bad:
let fixpoint (f,b) =
wwhile (fun x y -> (y,true) in func f b,b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun x y -> (y,true) in func f b,b


fix:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (0,true) in func b,b)

bad:
)

annotated:
)


fix:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (0,true) in func b,b)

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (0,true) in func f b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (0,true) in func f b,b)


fix:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) =
wwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)


fix:
let fixpoint (f,b) =
wwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)


fix:
let fixpoint (f,b) =
wwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (fun x -> (f b,not ((f b) = b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (fun x -> (f b,not ((f b) = b)),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,f b = b),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,f b = b) in func,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f b,f b = b) in func,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f x,f x = x),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f x,f x = x),b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f x,f x = x) in func,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func x = fun x -> (f x,f x = x) in func,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func = fun x -> (f x,f x = x) in func,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func = fun x -> (f x,f x = x) in func,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) =
wwhile (let func = fun x -> (f x,f x <> x) in func,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
wwhile (let func = fun x -> (f x,f x <> x) in func,b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of				->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
| Thresh  of expr * expr * expr * expr  ->

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of				->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
| Thresh  of expr * expr * expr * expr  ->


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
| Thresh  of expr * expr * expr * expr  ->

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
| Thresh  of expr * expr * expr * expr  ->


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			->
"cos(" ^ exprToString expr ^ ")"
| Average expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			->
"cos(" ^ exprToString expr ^ ")"
| Average expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr			    ->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			    ->
"cos(" ^ exprToString expr ^ ")"
| Average (expr * expr)	    ->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   expr * expr		    ->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  expr * expr * expr * expr ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr			    ->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			    ->
"cos(" ^ exprToString expr ^ ")"
| Average (expr * expr)	    ->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   expr * expr		    ->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  expr * expr * expr * expr ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr			    ->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			    ->
"cos(" ^ exprToString expr ^ ")"
| Average (expr,expr)		    ->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   (expr,expr)		    ->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  (expr,expr,expr,expr)     ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr			    ->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			    ->
"cos(" ^ exprToString expr ^ ")"
| Average (expr,expr)		    ->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   (expr,expr)		    ->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  (expr,expr,expr,expr)     ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "*" ^ exprToString expr1 ^ ")"
| Thresh  (expr0,expr1,expr2,expr3)     ->
"(" ^ expr0 ^ "<" ^ expr1 ^ "?" ^ expr2 ^ ":" ^ expr3 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "*" ^ exprToString expr1 ^ ")"
| Thresh  (expr0,expr1,expr2,expr3)     ->
"(" ^ expr0 ^ "<" ^ expr1 ^ "?" ^ expr2 ^ ":" ^ expr3 ^ ")"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "*" ^ exprToString expr1 ^ ")"
| Thresh  (expr0,expr1,expr2,expr3)     ->
"(" ^ exprToString expr0 ^ "<" ^ exprToString expr1 ^ "?" ^ exprToString expr2 ^ ":" ^ exprToString expr3 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  -> 
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "*" ^ exprToString expr1 ^ ")"
| Thresh  (expr0,expr1,expr2,expr3)     ->
"(" ^ exprToString expr0 ^ "<" ^ exprToString expr1 ^ "?" ^ exprToString expr2 ^ ":" ^ exprToString expr3 ^ ")"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) =
match e with
VarX				  ->
x
| VarY				    ->
y
| Sine    expr0			    ->
sin (eval (expr0,x,y))
| Cosine  expr0			    ->
cos (eval (expr0,x,y))
| Average (expr0,expr1)		    ->
(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.
| Times (expr0,expr1)		    ->
eval (expr0,x,y) *. eval (expr1,x,y)
| Thresh  (expr0,expr1,expr2,expr3) ->
match (eval (expr0,x,y) < eval (expr1,x,y)) with
true  ->
eval (expr2,x,y)
| false ->
eval (expr3,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
VarX				  ->
x
| VarY				    ->
y
| Sine    expr0			    ->
sin (eval (expr0,x,y))
| Cosine  expr0			    ->
cos (eval (expr0,x,y))
| Average (expr0,expr1)		    ->
(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.
| Times (expr0,expr1)		    ->
eval (expr0,x,y) *. eval (expr1,x,y)
| Thresh  (expr0,expr1,expr2,expr3) ->
match (eval (expr0,x,y) < eval (expr1,x,y)) with
true  ->
eval (expr2,x,y)
| false ->
eval (expr3,x,y)


fix:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 -> buildX()
| 1 -> buildY()
)
| _ ->
(match rand (0,3) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 -> buildX()
| 1 -> buildY()
)
| _ ->
(match rand (0,4) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match depth with
0 ->
(match rand (0,1) with
0 -> buildX()
| 1 -> buildY()
)
| _ ->
(match rand (0,4) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
)


fix:
type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Maximum  of expr * expr * expr
| Absolute of expr

bad:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(ran,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(ran,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
)


fix:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| _ ->
buildAbsolute(build(rand,depth-1))
)

bad:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
buildAbsolute(build(rand,depth-1))
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
buildAbsolute(build(rand,depth-1))
)


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f a x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = "" in
let l =  in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = "" in
let l =  in
List.fold_left f base l


fix:
let stringOfList f l = "[ " ^ sepConcat "; " l ^ " ]"

bad:
let stringOfList f l = "[ " ^ sepConCat "; " l ^ " ]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[ " ^ sepConCat "; " l ^ " ]"


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, a + x) in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (0, a + x) in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (_, l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = (_, l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (0, l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = (0, l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = in
let base = in
let args = in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = in
let base = in
let args = in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (a, a+x) in
let base = 0 in
let args = 1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (a, a+x) in
let base = 0 in
let args = 1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (a, a+x) in
let base = 0 in
let args = [1] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (a, a+x) in
let base = 0 in
let args = [1] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match a with 
ah::at  ->
match x with
xh::xt  ->
ah+at
in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
match a with 
ah::at  ->
match x with
xh::xt  ->
ah+at
in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match a with 
ah::at  ->
match x with
xh::xt  ->
ah+xh
in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
match a with 
ah::at  ->
match x with
xh::xt  ->
ah+xh
in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match x with 
(ah::at, bh::bt)  ->
(1,(ah+bh)::a)
in
let base = [] in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
match x with 
(ah::at, bh::bt)  ->
(1,(ah+bh)::a)
in
let base = [] in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match x with 
(ah::at, bh::bt)  ->
(1,(ah+bh)::a)
in
let base = (0, []) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
match x with 
(ah::at, bh::bt)  ->
(1,(ah+bh)::a)
in
let base = (0, []) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append zeroes l2)

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append zeroes l1, l2)

bad:
let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append (zeroes l2))

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append (zeroes l1, l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append (zeroes l2))

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append (zeroes l1, l2))


fix:
let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append zeroes l2)

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append zeroes l1, l2)

bad:
let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append (zeroes l2))

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append (zeroes l1), l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append (zeroes l2))

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append (zeroes l1), l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
(*
let f a x = (0,[]) in
let base = (l1, []) in
let args = l2 in*)
let (_, res) = (0,[0;0;0;0])(*List.fold_left f base args*) in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
(*
let f a x = (0,[]) in
let base = (l1, []) in
let args = l2 in*)
let (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
(*
let f a x = (0,[]) in
let base = (l1, []) in
let args = l2 in*)
let (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[0;0;0;0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[0;0;0;0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[0;0;0;0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[]) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[]) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =(*
match a with
[]  ->
([],[])
| h1::t1  ->*)
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = function  ->
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = function  ->
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =(*
match a with
[]  ->
([],[])
| h1::t1  ->*)
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = function
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = function
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =(*
match a with
[]  ->
([],[])
| h1::t1  ->*)
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = fun
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = fun
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =(*
match a with
[]  ->
([],[])
| h1::t1  ->*)
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1,_)  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
[]  ->
(l1,[0;0;0;0])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
[]  ->
(l1,[0;0;0;0])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1,_)  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
Printf.printf(%d, a)
match a with
(h1::t1, rh::rt)  ->
(t1,((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
Printf.printf(%d, a)
match a with
(h1::t1, rh::rt)  ->
(t1,((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,(h1+x+rh)/10)::((h1+x+rh) mod 10)::rt

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,(h1+x+rh)/10)::((h1+x+rh) mod 10)::rt


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
(List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
(List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev (h1::t1) in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev (h1::t1) in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev (h1::t1) in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev (h1::t1) in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, rh::rt)  ->
(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)
in
let base = (List.rev l1, [0]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, rh::rt)  ->
(t1, bigAdd (mulByDigit h1 rh::rt) rt)
in
let base = (List.rev l1, [0]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(h1::t1, rh::rt)  ->
(t1, bigAdd (mulByDigit h1 rh::rt) rt)
in
let base = (List.rev l1, [0]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, rh::rt)  ->
(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)
in
let base = (List.rev l1, [0]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, r) ->
(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)
| _	      ->
(* Should not get here *) ([], [])
in
let base = (List.rev l1, [1]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, r) ->
(h1::t1, bigAdd (mulByDigit x h1::t1) r)
| _	      ->
(* Should not get here *) ([], [])
in
let base = (List.rev l1, [1]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(h1::t1, r) ->
(h1::t1, bigAdd (mulByDigit x h1::t1) r)
| _	      ->
(* Should not get here *) ([], [])
in
let base = (List.rev l1, [1]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, r) ->
(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)
| _	      ->
(* Should not get here *) ([], [])
in
let base = (List.rev l1, [1]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [2] [1]

annotated:
let _ = bigMul [2] [1]


fix:
let pipe fs n =
let f a x = x a in
let base = n in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = n in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = n in
List.fold_left f base fs


fix:
let pipe fs n =
let f a x = x a in
let base = n in
List.fold_left f base fs

bad:
let pipe fs = fun
let f a x = x a in
let base = n in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  fun
let f a x = x a in
let base = n in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
match x with
[]  ->

| _   ->
x a
in
let base = n in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
match x with
[]  ->
1
| _   ->
0

in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
let g b y n =
match n with
[]  ->
n
| _   ->
y b
in g a x
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
let g b y n =
match n with
[]  ->
n
| _   ->
y b
in g a x
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
match a with
[]  ->
[]
| _   ->
x a
in
let base = f [] (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
1
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
match x with
[]  ->
1
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
match a with
[]  ->
[]
| _   ->
x a
in
let base = f [] (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
[]
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
match x with
[]  ->
[]
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
[]
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
match x with
[]  ->
[]
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[] ->
a
| _  ->
x a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
match x with
[] ->
a
| _  ->
x a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
fun g b y z ->
match y with
[] ->
z
| _  ->
b a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
fun g b y z ->
match y with
[] ->
z
| _  ->
b a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
fun a x ->
match x with
x' y  ->
match x' with
[]  ->
y
| _   ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
fun a x ->
match x with
x' y  ->
match x' with
[]  ->
y
| _   ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
match x' with
[]  ->
y
| _   ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
fun a x ->
match x with
x',y  ->
match x' with
[]  ->
y
| _   ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =
x a
in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
a
| _   ->
x a
in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
match x with
[]  ->
a
| _   ->
x a
in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs n = 
let f a x = x a in
let base = n in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
x
in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
x
in
let base = a in
List.fold_left f base fs


fix:
let pipe fs n = 
let f a x = x a in
let base = n in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
x
in
let base = f x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =
x
in
let base = f x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =match fs with
(fn,n)  -> n in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =match fs with
(fn,n)  -> n in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun fn -> fun x a -> fn in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let fn = fun x a in fn in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = let fn = fun x a in fn in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> x base in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> x base in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> fun z -> y z in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = match x with
fun y -> y a in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = match x with
fun y -> y a in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> fun z -> y z in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = match x with
(fun y) -> y a in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = match x with
(fun y) -> y a in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> fun z -> y z in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = match x with
(function y) -> y a in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = match x with
(function y) -> y a in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> x a in
let base = b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> x a in
let base = b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> x a in
let base = fun b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> fun b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> x a in
let base = fun b -> fun b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let an = a in x an in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> fun z -> z (fun r -> y) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> fun z -> z (fun r -> y) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let an = a in x an in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> fun z -> z (fun r -> y) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> fun z -> z (fun r -> y) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let an = a in x an in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> fun z -> z y in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y -> fun z -> z y in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let y = a in x y in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let fun y z = fun xn -> fun an -> xn an in y in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = let fun y z = fun xn -> fun an -> xn an in y in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let y = a in x y in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let y z = fun xn -> xn a in y in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = let y z = fun xn -> xn a in y in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let y = a in x y in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let y z = fun xn -> xn a in y in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = let y z = fun xn -> xn a in y in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = let y = pipe x a in y in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let y = pipe x a in x y in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = let y = pipe x a in x y in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = x(a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = f x(a) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = f x(a) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y z -> z (x (a)) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun c y z -> z (a (c)) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun c y z -> z (a (c)) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun y z -> z (x (a)) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y z -> z (a (c)) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun y z -> z (a (c)) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun c -> x (a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun c -> c (x (a)) in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun c -> c (x (a)) in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun c -> x c in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun c -> fun d -> x c in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs =
let f a x = fun c -> fun d -> x c in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun c -> fun d -> x c in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun c -> fun d -> d c in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun c -> fun d -> d c in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun c -> a in
let base = fun b -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = fun c -> a in
let base = fun b -> b in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs =
let f a x = fun c -> x in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs =
let f a x = fun c -> x in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs =
let f a x = fun c -> x in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

bad:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| (s,i):xs -> if k = s then i else assoc (d,k,xs)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| [] -> k
| (s,i):xs -> if k = s then i else assoc (d,k,xs)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

bad:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| x:xs -> let x = (s,i) in
if k = s then i else assoc (d,k,xs)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| [] -> k
| x:xs -> let x = (s,i) in
if k = s then i else assoc (d,k,xs)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

bad:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| x::xs -> let x = (s,i) in
if k = s then i else assoc (d,k,xs)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
match l with
| [] -> k
| x::xs -> let x = (s,i) in
if k = s then i else assoc (d,k,xs)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then wwhile (f,b') else b'

bad:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then f b' else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let calc = f b in
let (b',c') = calc in
if c' then f b' else b'


fix:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then wwhile (f,b') else b'

bad:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then f (b') else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let calc = f b in
let (b',c') = calc in
if c' then f (b') else b'


fix:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then wwhile (f,b') else b'

bad:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then (f b') else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let calc = f b in
let (b',c') = calc in
if c' then (f b') else b'


fix:
let fixpoint (f,b) = wwhile ((f),b)

bad:
 fixpoint (f,b) = wwhile ((f b),b)

annotated:
 fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)


fix:
let fixpoint (f,b) = wwhile ((f),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((fun x -> f b),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((fun x -> f b),b)

bad:
let fixpoint (f,b) = wwhile ((let f x = wwhile(f,x) in f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x  ->  wwhile(f,x) in f b),b)


fix:
let fixpoint (f,b) = wwhile ((let f x = f b in f),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)

bad:
let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> (f x,f x! -> b)),b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*%s)" x
| Cosine x -> "cos(pi*%s)" x
| Average x y -> "((%s+%s)/2)" x y
| Times x y -> "%s*%s" x y
| Thresh x y z a -> "%s<%s?%s:%s" x y z a

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*%s)" x
| Cosine x -> "cos(pi*%s)" x
| Average (x,y) -> "((%s+%s)/2)" x y
| Times (x,y) -> "%s*%s" x y
| Thresh (x,y,z,a) -> "%s<%s?%s:%s" x y z a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*%s)" x
| Cosine x -> "cos(pi*%s)" x
| Average (x,y) -> "((%s+%s)/2)" x y
| Times (x,y) -> "%s*%s" x y
| Thresh (x,y,z,a) -> "%s<%s?%s:%s" x y z a


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> sprintf "sin(pi*%s)" x
| Cosine x -> sprintf "cos(pi*%s)" x
| Average (x,y) -> sprintf "((%s+%s)/2)" x y
| Times (x,y) -> sprintf "%s*%s" x y
| Thresh (x,y,z,a) -> sprintf "%s<%s?%s:%s" x y z a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> sprintf "sin(pi*%s)" x
| Cosine x -> sprintf "cos(pi*%s)" x
| Average (x,y) -> sprintf "((%s+%s)/2)" x y
| Times (x,y) -> sprintf "%s*%s" x y
| Thresh (x,y,z,a) -> sprintf "%s<%s?%s:%s" x y z a


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX -> Printf.sprintf "x"
| VarY -> Printf.sprintf "y"
| Sine x -> Printf.sprintf "sin(pi*%s)" x
| Cosine x -> Printf.sprintf "cos(pi*%s)" x
| Average (x,y) -> Printf.sprintf "((%s+%s)/2)" x y
| Times (x,y) -> Printf.sprintf "%s*%s" x y
| Thresh (x,y,z,a) -> Printf.sprintf "%s<%s?%s:%s" x y z a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> Printf.sprintf "x"
| VarY -> Printf.sprintf "y"
| Sine x -> Printf.sprintf "sin(pi*%s)" x
| Cosine x -> Printf.sprintf "cos(pi*%s)" x
| Average (x,y) -> Printf.sprintf "((%s+%s)/2)" x y
| Times (x,y) -> Printf.sprintf "%s*%s" x y
| Thresh (x,y,z,a) -> Printf.sprintf "%s<%s?%s:%s" x y z a


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "((" ^ exprToString x ^ "+" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (x,y,z,a) -> exprToString x ^ "<" ^ expToString y ^ "?" ^ exprToString z ^ ":" ^ exprToString a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "((" ^ exprToString x ^ "+" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (x,y,z,a) -> exprToString x ^ "<" ^ expToString y ^ "?" ^ exprToString z ^ ":" ^ exprToString a


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "((" ^ exprToString x ^ "+" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (x,y,z,a) -> exprToString x ^ "<" ^ exprToString y ^ "?" ^ exprToString z ^ ":" ^ exprToString a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "((" ^ exprToString x ^ "+" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (x,y,z,a) -> exprToString x ^ "<" ^ exprToString y ^ "?" ^ exprToString z ^ ":" ^ exprToString a


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi * eval(a,x,y))
| Cosine a -> cos(pi * eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2
| Times (a,b) -> eval(a,x,y) * eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi * eval(a,x,y))
| Cosine a -> cos(pi * eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2
| Times (a,b) -> eval(a,x,y) * eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi * eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2
| Times (a,b) -> eval(a,x,y) * eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi * eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2
| Times (a,b) -> eval(a,x,y) * eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi *. eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi *. eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi *. eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi *. eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)


fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| []   -> a
| h::t -> List.fold_left f (a + (h*h)) t in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = match x with
| []   -> a
| h::t -> List.fold_left f (a + (h*h)) t in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []

annotated:
let _ = sqsum []


fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]

annotated:
let _ = sqsum [1;2;3;4]


fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 (abs diff)) @ l1, l2)

bad:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 -diff) @ l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 -diff) @ l1, l2)


fix:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 (abs diff)) @ l1, l2)

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 (abs diff)) @ l1, l2)

bad:
let _ = padZero [1;0;0;2] [9;9]

annotated:
let _ = padZero [1;0;0;2] [9;9]


fix:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 (abs diff)) @ l1, l2)

bad:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 abs diff) @ l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 abs diff) @ l1, l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| []   -> 
if ((arg1 + arg2) > 9)
then [1] @ [(arg1 + arg2) mod 10] @ a
else ((arg1 + arg2)::a)
| h::t -> 
if ((arg1 + arg2 + h) > 9)
then [1] @ [(arg1 + arg2 + h) mod 10] @ a
else ((arg1 + arg2 + h)::a)
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| []   -> 
if ((arg1 + arg2) > 9)
then [1] @ [(arg1 + arg2) mod 10] @ a
else ((arg1 + arg2)::a)
| h::t -> 
if ((arg1 + arg2 + h) > 9)
then [1] @ [(arg1 + arg2 + h) mod 10] @ a
else ((arg1 + arg2 + h)::a)
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| []   -> 
if ((arg1 + arg2) > 9)
then [1] @ [(arg1 + arg2) mod 10] @ a
else ((arg1 + arg2)::a)
| h::t -> 
if ((arg1 + arg2 + h) > 9)
then [1] @ [(arg1 + arg2 + h) mod 10] @ a
else ((arg1 + arg2 + h)::a)
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1,_::t) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1,_::t) -> 
if ((arg1 + arg2 + h) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1,_::t) -> 
if ((arg1 + arg2 + h) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, h::t) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, _) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, _) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, h::t) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, [h] @ [t]) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, [h] @ [t]) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0, acc) -> 
if ((arg1 + arg2) > 9)
then (1, ((arg1 + arg2) mod 10)::acc)
else (0,(arg1 + arg2)::acc)
| (0, [])  ->
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0, [arg1 + arg2])
| (_, acc) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, ((arg1 + arg2 + 1) mod 10)::acc)
else (0, ((arg1 + arg2 + 1)::acc))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,_)   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (_, _) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ a)
else (0, ((arg1 + arg2 + 1)::a))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,_)   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (_, _) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ a)
else (0, ((arg1 + arg2 + 1)::a))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
let (carry, acc) = a in 
if ((arg1 + arg2 + carry) > 9)
then (1, ((arg1 + arg2 + carry) mod 10)::acc)
else (0, ((arg1 + arg2 + carry)::acc))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (fin,res) = List.fold_left f base args in
fin::res
in 
removeZero (add (padZero l1 l2))

bad:
let mulByDigit i l = 
let rec helper i' l' = 
match i' with
| 1 -> l'
| _ -> mulByDigit (i'-1) (bigAdd l l')

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper i' l' = 
match i' with
| 1 -> l'
| _ -> mulByDigit (i'-1) (bigAdd l l')


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
let (carry, acc) = a in 
if ((arg1 + arg2 + carry) > 9)
then (1, ((arg1 + arg2 + carry) mod 10)::acc)
else (0, ((arg1 + arg2 + carry)::acc))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (fin,res) = List.fold_left f base args in
fin::res
in 
removeZero (add (padZero l1 l2))

bad:
let mulByDigit i l = 
let rec helper i' l' = 
match i' with
| 1 -> l'
| _ -> helper (i'-1) (bigAdd l l')

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper i' l' = 
match i' with
| 1 -> l'
| _ -> helper (i'-1) (bigAdd l l')


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
let (carry, acc) = a in 
if ((arg1 + arg2 + carry) > 9)
then (1, ((arg1 + arg2 + carry) mod 10)::acc)
else (0, ((arg1 + arg2 + carry)::acc))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (fin,res) = List.fold_left f base args in
fin::res
in 
removeZero (add (padZero l1 l2))

bad:
let mulByDigit i l = 
let rec helper i l' = 
match i with
| 1 -> l'
| _ -> helper (i-1) (bigAdd l l')

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper i l' = 
match i with
| 1 -> l'
| _ -> helper (i-1) (bigAdd l l')


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (acc, l) = a in
match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, (mulByDigit x f_rev))

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (acc, l) = a in
match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, (mulByDigit x f_rev))


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (acc, l) = a in
match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, [](*mulByDigit x f_rev*))

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (acc, l) = a in
match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, [](*mulByDigit x f_rev*))


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =
let (acc, l) = a in
let h::t = l in
([],[])

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =
let (acc, l) = a in
let h::t = l in
([],[])


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = ([], [])

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = ([], [])


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (0, [])

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (0, [])


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = a


fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 n-1) in
let padded_x = x * pow10 ((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10^((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10^((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 n-1) in
let padded_x = x * pow10 ((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10**((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10**((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 n-1) in
let padded_x = x * pow10 ((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10.**((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10.**((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], l, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], l, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
let this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
let this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], l, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], l, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], l, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =
let (padding, acc) = a in
(padding+1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =
let (padding, acc) = a in
(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =
let (padding, acc) = a in
(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = if n > 0
then
(n mod 10) :: (digitsOfInt (n/10))
else
[]

bad:
let rec digitsOfInt n = if n > 0
then
(digitsOfInt (n/10)) :: n mod 10
else
0

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  if n > 0
then
(digitsOfInt (n/10)) :: n mod 10
else
0


fix:
let rec digitsOfInt n = if n > 0
then
(n mod 10) :: (digitsOfInt (n/10))
else
[]

bad:
let rec digitsOfInt n = if n > 0
then
(digitsOfInt (n/10)) :: n mod 10
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  if n > 0
then
(digitsOfInt (n/10)) :: n mod 10
else
[]


fix:
let rec listReverse l = function
| [] -> l
| (h::t) -> listReverse (h::l) t

bad:
let rec listReverse l = function
| [] -> l
| (h::t) -> listReverse (h::l) t

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  function
| [] -> l
| (h::t) -> listReverse (h::l) t


fix:
let rec listReverse l = match l with
| [] -> l
| [other::tail::[]] -> tail :: other

bad:
let rec listReverse l = function
| [] -> l
| (h::t) -> listReverse (h::l) t in
listReverse [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  function
| [] -> l
| (h::t) -> listReverse (h::l) t in
listReverse [] l


fix:
let rec listReverse l = match l with
| [] -> l
| [other::tail::[]] -> tail :: other

bad:
let rec listReverse l = match l with
| [] -> l
| [_::tail::[]] -> l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> l
| [_::tail::[]] -> l


fix:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

bad:
let rec listReverseHelper l ans = 
[] -> [];
(h::t) -> ans :: listReverseHelper t ans

annotated:
let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  
[] -> [];
(h::t) -> ans :: listReverseHelper t ans


fix:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

bad:
let rec listReverse l =
listReverseHelper l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
listReverseHelper l []


fix:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

bad:
let rec listReverseHelper l ans = 
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

annotated:
let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans


fix:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

bad:
let rec listReverseHelper l ans = match l with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

annotated:
let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  match l with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| h::t -> listReverseHelper t (h::ans)

listReverseHelper l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with
| [] -> []
| h::t -> listReverseHelper t (h::ans)

listReverseHelper l []


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| h::t -> listReverseHelper t (h::ans) in 

listReverseHelper l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with
| [] -> []
| h::t -> listReverseHelper t (h::ans) in 

listReverseHelper l []


fix:
let _ = additivePersistence 9876

bad:
let rec additivePersistence n = 
let rec sumDigits n1 = 
if n < 10 then 
n 
else
n1 mod 10 + sumDigits (n1 / 10) in 
if (n < 10) then
0
else
1 + additivePersistence (sumDigits n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let rec sumDigits n1 = 
if n < 10 then 
n 
else
n1 mod 10 + sumDigits (n1 / 10) in 
if (n < 10) then
0
else
1 + additivePersistence (sumDigits n)


fix:
let _ = digitalRoot 9873

bad:
let rec digitalRoot n = 
if (n > 10) then 
digitalRoot (sumDigits n)
else
n

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
if (n > 10) then 
digitalRoot (sumDigits n)
else
n


fix:
let palindrome w = (explode w) = (listReverse (explode w))

bad:
let palindrome w = (explode w) = (listReverse (explode w))

annotated:
let palindrome : string -> bool = fun  w = (explode w)  ->  (listReverse (explode w))


fix:
let rec fixpoint (f,x) = 
let x' = f x in
if x' = x then x else fixpoint (f, x')

bad:
let rec fixpoint (f,x) = 
let x' = f x in
if x' = x then x else fixpoint f x'

annotated:
let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,x)  ->  
let x' = f x in
if x' = x then x else fixpoint f x'


fix:
let rec fixpoint (f,x) = 
let x' = f x in
let g x = (x', x' = x) in 
wwhile (g,x)

bad:
let rec fixpoint (f,x) = 
let x' = f x in
let g x = (f, x' = x) in 
wwhile (g,x)

annotated:
let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,x)  ->  
let x' = f x in
let g x = (f, x' = x) in 
wwhile (g,x)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 2)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, .2)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, .2)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (exprToString e1))
| Cosine   (e1) -> cos(pi *. (exprToString e1))
| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.
| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)
| Thresh   (e1, e2, e3, e4) 
-> if (exprToString e1) < (exprToString e2) then
(exprToString e3) else
(exprToString e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (exprToString e1))
| Cosine   (e1) -> cos(pi *. (exprToString e1))
| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.
| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)
| Thresh   (e1, e2, e3, e4) 
-> if (exprToString e1) < (exprToString e2) then
(exprToString e3) else
(exprToString e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval e1))
| Cosine   (e1) -> cos(pi *. (eval e1))
| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.
| Times    (e1, e2) -> (eval e1) *. (eval e2)
| Thresh   (e1, e2, e3, e4) 
-> if (eval e1) < (eval e2) then
(eval e3) else
(eval e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval e1))
| Cosine   (e1) -> cos(pi *. (eval e1))
| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.
| Times    (e1, e2) -> (eval e1) *. (eval e2)
| Thresh   (e1, e2, e3, e4) 
-> if (eval e1) < (eval e2) then
(eval e3) else
(eval e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))
| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in
if abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then
s else
abs_float s
| ModThresh (e1, e2, e3) -> 
if (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then
(eval (e2, x, y)) else
(eval (e3, x, y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))
| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in
if abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then
s else
abs_float s
| ModThresh (e1, e2, e3) -> 
if (truncate (100 *. (eval (e1, x, y)))) mod 5 = 0 then
(eval (e2, x, y)) else
(eval (e3, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))
| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in
if abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then
s else
abs_float s
| ModThresh (e1, e2, e3) -> 
if (truncate (100 *. (eval : expr * float * float -> float = fun  (e,x,y)  ->  0 then
(eval (e2, x, y)) else
(eval (e3, x, y))


fix:
let _ = buildY()

bad:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX
else
buildY
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX
else
buildY
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))


fix:
let _ = buildY()

bad:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX()
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX()
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))


fix:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX()
else
buildY()
else
buildY()

bad:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX() : expr
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX() : expr
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))


fix:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX()
else
buildY()
else
buildY()

bad:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX() :: expr
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX() :: expr
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))


fix:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-dif)) @ l1, l2)
else
(l1, ((clone 0 dif) @ l2))

bad:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-diff)) @ l1, l2)
else
(l1, ((clone 0 diff) @ l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-diff)) @ l1, l2)
else
(l1, ((clone 0 diff) @ l2))


fix:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-dif)) @ l1, l2)
else
(l1, ((clone 0 dif) @ l2))

bad:
let _ = padZero [9;9] [1;0;0;2]

annotated:
let _ = padZero [9;9] [1;0;0;2]


fix:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-dif)) @ l1, l2)
else
(l1, ((clone 0 dif) @ l2))

bad:
let _ = padZero [1;0;0;2] [9;9]

annotated:
let _ = padZero [1;0;0;2] [9;9]


fix:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-dif)) @ l1, l2)
else
(l1, ((clone 0 dif) @ l2))

bad:
let _ = padZero [1;0;0;2] [9;9;9;9]

annotated:
let _ = padZero [1;0;0;2] [9;9;9;9]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, rest) = a in
let (d1, d2) = x in
let sum = d1 + d2 + carry in
if (sum > 9) then
(1, (sum - 10)::rest)
else
(0, sum::rest) in
let base = (0, []) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, rest) = a in
let (d1, d2) = x in
let sum = d1 + d2 + carry in
if (sum > 9) then
(1, (sum - 10)::rest)
else
(0, sum::rest) in
let base = (0, []) in
let args = List.combine (list.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (carry, rest) = a in
let (d1, d2) = x in
let sum = d1 + d2 + carry in
if (sum > 9) then
(1, (sum - 10)::rest)
else
(0, sum::rest) in
let base = (0, []) in
let args = List.combine (list.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigMul [0;99] []

bad:
let _ = bigMul [0,99] []

annotated:
let _ = bigMul [0,99] []


fix:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n :: []

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
|

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n <= 0) 
then []
else 
|


fix:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n :: []

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n <= 0) 
then []
else 
n mod 10


fix:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n :: []

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n mod 10
n::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n <= 0) 
then []
else 
n mod 10
n::[]


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
(n mod 10) :: [digitsOfInt n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n <= 0) 
then []
else 
(n mod 10) :: [digitsOfInt n]


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
(n mod 10) :: digitsOfInt n :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if (n <= 0) 
then []
else 
(n mod 10) :: digitsOfInt n :: []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@[]


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
hi

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
hi


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
toAdd@myList

annotated:
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
let toAdd = (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else (
let toAdd = (n mod 10)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
toAdd@myList

annotated:
toAdd@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
(n mod 10)@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else (
(n mod 10)@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
)

annotated:
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
(n mod 10)@myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else (
(n mod 10)@myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
)

annotated:
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
n mod 10 @myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else (
n mod 10 @myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
)

annotated:
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
n mod 10 @myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else (
n mod 10 @myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
)

annotated:
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 @myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 @myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

bad:
let _ = 1;l
n mod 10 :: myList

annotated:
let _ = 1;l
n mod 10 :: myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

n mod 10 :: myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []

n mod 10 :: myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then ->[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then ->[]


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) 
then -> []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []

n mod 10 :: myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []

n mod 10 :: myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
n mod 10 :: myList

annotated:
n mod 10 :: myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList
n mod 100 :: myList

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList
n mod 100 :: myList


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n = n - (n mod 10);
(n :: myList) :: digitsOfInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else
n = n - (n mod 10);
(n :: myList) :: digitsOfInt


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
)

annotated:
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
(n mod 10 :: myList) :: digitsOfInt
)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else (
(n mod 10 :: myList) :: digitsOfInt
)


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt


fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10)


fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
List.rev (n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
rev (n mod 10 :: digitsOfInt (n / 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if (n <= 0) then []
else 
rev (n mod 10 :: digitsOfInt (n / 10))


fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev digitsOfInt (n / 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if (n <= 0) then []
else 
(n mod 10 :: List.rev digitsOfInt (n / 10))


fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
let _ = (n mod 10 :: digitsOfInt (n / 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if (n <= 0) then []
else 
let _ = (n mod 10 :: digitsOfInt (n / 10))


fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))
List.rev

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))
List.rev


fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev (digitsOfInt (n / 10)))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev digitsOfInt (n / 10))

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if (n <= 0) then []
else 
(n mod 10 :: List.rev digitsOfInt (n / 10))


fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev (digitsOfInt (n / 10)))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: (List.rev digitsOfInt (n / 10)))

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if (n <= 0) then []
else 
(n mod 10 :: (List.rev digitsOfInt (n / 10)))


fix:
let rec additivePersistence n = 
(digitsOfInt n)

bad:
let rec additivePersistence n = 
- = digitsOfInt n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
- = digitsOfInt n


fix:
let rec additivePersistence n = 
(digitsOfInt n)

bad:
let rec additivePersistence n = 
let a = (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let a = (digitsOfInt n)


fix:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList (digitsOfInt n)

bad:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| (h::t) -> h + t

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match (digitsOfInt n) with
| [] -> 0
| (h::t) -> h + t


fix:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList (digitsOfInt n)

bad:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList digitsOfInt n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList digitsOfInt n


fix:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList (digitsOfInt n)

bad:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0;
| _ -> sumList digitsOfInt n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match (digitsOfInt n) with
| [] -> 0;
| _ -> sumList digitsOfInt n


fix:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList (digitsOfInt n)

bad:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList digitsOfInt n;

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList digitsOfInt n;


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
let _ = sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let _ = sumList (digitsOfInt n)


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
let _ = sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let _ = sumList (digitsOfInt n)


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
let _ = 2

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let _ = 2


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
let _ = 2

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let _ = 2


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count++
else
sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count++
else
sumList (digitsOfInt n)


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count++

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count++


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count = count + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count = count + 1


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let count = count + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let count = count + 1


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let count = 9

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let count = 9


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let co = 9

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let co = 9


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = [] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))


fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then (
1::count
additivePersistence (sumList (digitsOfInt n)))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then (
1::count
additivePersistence (sumList (digitsOfInt n)))
else sumList count


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count & additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count & additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count && additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count && additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count &&& additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count &&& additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then 
x + 1
additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then 
x + 1
additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let x = 1 in
x = x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in
x = x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let x = 1 in x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count


fix:
let rec additivePersistence n = 
let x = 1 in x + 1

bad:
let rec additivePersistence n = 
let x = 1 in x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x


fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then begin
let x = x + 1;
additivePersistence (sumList (digitsOfInt n))
end
else x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then begin
let x = x + 1;
additivePersistence (sumList (digitsOfInt n))
end
else x


fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then begin
let x = x + 1;
additivePersistence (sumList (digitsOfInt n))
end;
else x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then begin
let x = x + 1;
additivePersistence (sumList (digitsOfInt n))
end;
else x


fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) then begin
let x = x + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 1 in
if (sumList (digitsOfInt n) > 9) then begin
let x = x + 1


fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
additivePersistence (sumList (digitsOfInt n))
end;
else x

annotated:
additivePersistence (sumList (digitsOfInt n))
end;
else x


fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end;
else sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end;
else sumList x


fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1 :: x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else sumList x


fix:
let rec additivePersistence n = 
let x = [1] in
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

bad:
let rec additivePersistence n = 
let x = [1]
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = [1]
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x


fix:
let rec additivePersistence n = 
let x = [1] in
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

bad:
let rec additivePersistence n = 
let x = [1]
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = [1]
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x


fix:
let rec additivePersistence n = 
let x = [1] in
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

bad:
let rec additivePersistence n = 
let x = [1]
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = [1]
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x


fix:
let x = [1]

bad:
let x = [1] in
let rec additivePersistence n = 
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

annotated:
let x = [1] in
let rec additivePersistence : int -> int = fun  n  ->  
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x


fix:
let rec additivePersistence n = 
1::x

bad:
let rec additivePersistence n = 
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x


fix:
let rec additivePersistence n = 
1::x

bad:
let rec additivePersistence n = 
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end;
else begin
1:x;
sumList x
end;

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end;
else begin
1:x;
sumList x
end;


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
end

annotated:
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
end

annotated:
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
end

annotated:
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
1:x;
sumList x;

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
1:x;
sumList x;


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
1::x;
sumList x;

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
1::x;
sumList x;


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList [1;2];
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList [1:2];
end

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList [1:2];
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

bad:
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x

annotated:
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

bad:
sumList x
end

annotated:
sumList x
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

bad:
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x
sumList x
end

annotated:
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x
sumList x
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
(1::x);
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
(1::x);
sumList x
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
(1::x);
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
(1::x);
sumList x
end

bad:
sumList x
end

annotated:
sumList x
end


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
(1::x);
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
(1::x);
sumList x
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x


fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
(1::x);
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
(1::x);
sumList x
end

bad:
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

annotated:
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end


fix:
let rec listReverse l = 
let explosion = explode l;

bad:
let rec listReverse l = 
explode l

listReverse "nikhil"

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
explode l

listReverse "nikhil"


fix:
let rec listReverse l = 
explode l

bad:
let rec listReverse l = 
let explosion = explode l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let explosion = explode l


fix:
let rec listReverse l = match l with 
[] -> []

bad:
let rec listReverse l = 
explode l match l with
| [] -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
explode l match l with
| [] -> 0


fix:
let rec listReverse l = match l with 
[] -> []

bad:
let rec listReverse l = 
let p = explode l match p with
| [] -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let p = explode l match p with
| [] -> 0


fix:
let rec listReverse l = match l with 
[] -> []

bad:
let rec listReverse l = 
let p = (explode l) match p with
| [] -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let p = (explode l) match p with
| [] -> 0


fix:
let rec listReverse l = match l with 
[] -> []

bad:
let rec listReverse l = 
let p -> (explode l) match p with
| [] -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let p -> (explode l) match p with
| [] -> 0


fix:
let rec listReverse l = match l with 
[] -> []

bad:
let rec listReverse l = 
let explosion = 
(explode l) match p with
| [] -> 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let explosion = 
(explode l) match p with
| [] -> 0


fix:
let rec listReverse l = match l with 
|[] -> []
|[h1] -> h1::[]
|(h::t) -> h::(listReverse t)

bad:
let rec listReverse l = match l with 
|[] -> []
|(h1) -> h1::[]
|(h::t) -> h::(listReverse t)

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
|[] -> []
|(h1) -> h1::[]
|(h::t) -> h::(listReverse t)


fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> h::(listReverse t)

bad:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> (listReverse t)::h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
|[] -> []
|(h::t) -> (listReverse t)::h


fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> begin
(listReverse t);
h::[]
end

bad:
let rec listReverse l = match l with 
|[] -> h::[]
|(h::t) -> listReverse t

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
|[] -> h::[]
|(h::t) -> listReverse t


fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> begin
(listReverse t);
h::[]
end

bad:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> listReverse t
|_ -> h::[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
|[] -> []
|(h::t) -> listReverse t
|_ -> h::[]


fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> begin
(listReverse t);
h::[]
end

bad:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> listReverse t
h::[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
|[] -> []
|(h::t) -> listReverse t
h::[]


fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> begin
(listReverse t);
h::[]
end

bad:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> (listReverse t)
h::[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with 
|[] -> []
|(h::t) -> (listReverse t)
h::[]


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end

annotated:
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = fun
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = fun
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = 
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = 
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = 
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
in

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = 
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
in


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = in
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count = in
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end


fix:
let additivePersistence n = 
let count = 1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let additivePersistence n = 
let count = 1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let additivePersistence n = 
let count = 1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else sumList count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else sumList count


fix:
let additivePersistence n = 
let count = 1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let additivePersistence n = 
let count = 1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count in

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count in


fix:
let additivePersistence n = 
let count = 1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
in

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
in


fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1;
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1;
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1;
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1;
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1 in
begin 
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
end

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
begin 
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
end


fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count


fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else poum

annotated:
let additivePersistence : int -> int = fun  n  ->  
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else poum


fix:
let additivePersistence n = n + 1

bad:
let additivePersistence n =

annotated:
let additivePersistence : int -> int = fun  n  -> 


fix:
let additivePersistence n a = n + a

bad:
let additivePersistence n a = n + a + b

annotated:
let additivePersistence : int -> int = fun  n a  ->  n + a + b


fix:
let additivePersistence n a = 
if (sumList (digitsOfInt n) > 9)
then additivePersistence (sumList (digitsOfInt n)) (a + 1)
else 9

bad:
let additivePersistence n a = 
if (sumList (digitsOfInt n) > 9)
then additivePersistence (sumList (digitsOfInt n)) (a + 1)

annotated:
let additivePersistence : int -> int = fun  n a  ->  
if (sumList (digitsOfInt n) > 9)
then additivePersistence (sumList (digitsOfInt n)) (a + 1)


fix:
let _ = additivePersistence 9876

bad:
let _ = additivePersistence 9876 1

annotated:
let _ = additivePersistence 9876 1


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if ((extract1 h) = k) then (extract2)
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t - > if ((extract1 h) = k) then (extract2)
else assoc (d, k, t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t - > if ((extract1 h) = k) then (extract2)
else assoc (d, k, t)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> d

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
|

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
|


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> d

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (mem h l) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (mem h l) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if not (l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if not (l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!(List.mem h seen)) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!(List.mem h seen)) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::[]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::[]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then ([]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then ([]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then ([2]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then ([2]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not (List.mem h seen)) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)


fix:
let fixpoint (f,b) = b

bad:
let fixpoint (f,b) = wwhile (b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)


fix:
let fixpoint (f,b) = wwhile ((f),b)

bad:
let fixpoint (f,b) = wwhile (f,f b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,f b)


fix:
let fixpoint (f,b) = wwhile ((f ),b)

bad:
let fixpoint (f,b) = wwhile ((f a),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f a),b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fixpoint (f,b)),b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else fixpoint (f b, b),b))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else fixpoint (f,f b),b))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,f b),b)))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,b))))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,b),b)))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,b),b)))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if ((f b)  ->  b) then b else (fixpoint (f,b),b))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if ((f b)  ->  b) then b else wwhile (f,f b))


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if ((f b)  ->  b) then b, b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if ((f b)  ->  b) then b), b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b), b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), a)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), b)


fix:
let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then 1 else 0), b)


fix:
let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

bad:
let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x = (f x) in (x, x  ->  b), b)


fix:
let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

bad:
let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x = (f x) in (x, x  ->  b), b))


fix:
let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

bad:
let fixpoint (f,b) = wwhile ((fun x -> x ), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun x -> x ), b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX -> sprintf "%s" VarX

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> sprintf "%s" VarX


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX -> sprintf "%s"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> sprintf "%s"


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX -> printf "%s"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> printf "%s"


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX a -> sprintf "%s" a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX a -> sprintf "%s" a


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX v a -> sprintf "%s" a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX v a -> sprintf "%s" a


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX a b -> sprintf "%s" a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX a b -> sprintf "%s" a


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| VarX a -> sprintf "%s" a

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX a -> sprintf "%s" a


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| Sine s -> sprintf "%s" s

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> sprintf "%s" s


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec exprToString e = match e with
| Sine s -> printf "%s" s

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> printf "%s" s


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3.142 * e))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%d" (sin (3.142 * e))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * e))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%d" (sin (3 * e))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3.0 * 2.0))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%d" (sin (3.0 * 2.0))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2.0))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2.0))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%i" (sin (3 * 2))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%i" (sin (3 * 2))


fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%i" (sin (3.0 * 2.0))

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Sine s -> Format.sprintf "%i" (sin (3.0 * 2.0))


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%expr" 1.0 ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ s ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ s ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%expr" 1.0 ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%expr" s ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%expr" s ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%_" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%_" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%f" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%f" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%i" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%i" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%expr" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%expr" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%e" s  ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%e" s  ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times (t1,t2) -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average a1 a2 -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average a1 a2 -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times (t1,t2) -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average a1 a2 -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average a1 a2 -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times (t1,t2) -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"


fix:
let mine = buildAverage(VarX, VarY)

bad:
let mine = buildAverage(2.0, 4.0)

annotated:
let mine = buildAverage(2.0, 4.0)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in
| VarY -> let vy = y in 
| Average -> buildAverage (vx, vy)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in
| VarY -> let vy = y in 
| Average -> buildAverage (vx, vy)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in 
| VarY -> let vy = y in
| Sine -> 
| Average -> buildAverage(vx,vy)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in 
| VarY -> let vy = y in
| Sine -> 
| Average -> buildAverage(vx,vy)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y in
| Sine -> 
| Average -> buildAverage(vx,vy)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y in
| Sine -> 
| Average -> buildAverage(vx,vy)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y 
| Sine -> 
| Average -> buildAverage(vx,vy)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y 
| Sine -> 
| Average -> buildAverage(vx,vy)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y 
| Average -> buildAverage(vx,vy)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y 
| Average -> buildAverage(vx,vy)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in vx 
| VarY -> let vy = y in vy
| Average -> buildAverage(vx,vy)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in vx 
| VarY -> let vy = y in vy
| Average -> buildAverage(vx,vy)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> buildAverage(a1,a2)

annotated:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> buildAverage(a1,a2)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval (VarX,a1,a2))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval (VarX,a1,a2))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (a1 + a2)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (a1 + a2)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin(s1)
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin(s1)
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2


fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (pi *. eval(s1,x,y))
| Cosine (c1) -> cos (pi *. eval(c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)
| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))
| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (pi *. eval(s1,x,y))
| Cosine (c1) -> cos (pi *. eval(c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)
| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))
| Thresh (h1,h2,h3,h4) ->

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (pi *. eval(s1,x,y))
| Cosine (c1) -> cos (pi *. eval(c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)
| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))
| Thresh (h1,h2,h3,h4) ->


fix:
let _ = eval (Sine(Average(VarX,VarY)), 0.5, -0.5)

bad:
let _ = eval (Sine(Average(Varx,VarY)), 0.5, -0.5)

annotated:
let _ = eval (Sine(Average(Varx,VarY)), 0.5, -0.5)


fix:
build (makeRand (10,39), 4)

bad:
build (rand, 4)

annotated:
build (rand, 4)


fix:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> VarX
| 2 -> 22
| 3 -> 33
| 4 -> 44
| 5 -> 55
| 6 -> 66
| 7 -> 77

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| 1 -> VarX
| 2 -> 22
| 3 -> 33
| 4 -> 44
| 5 -> 55
| 6 -> 66
| 7 -> 77


fix:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildSine(buildX())
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX(buildY())
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| 1 -> buildX(buildY())
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()


fix:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine(build(rand, depth))
| 4 -> buildCosine(build(rand, depth))
| 5 -> buildAverage(build(rand, depth), build(rand, depth))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine(buildX())
| 4 -> buildSine(buildX())
| 5 -> buildSine(buildX())
| 6 -> buildSine(buildX())
| 7 -> buildSine(buildX())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine(buildX())
| 4 -> buildSine(buildX())
| 5 -> buildSine(buildX())
| 6 -> buildSine(buildX())
| 7 -> buildSine(buildX())


fix:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))
| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))
| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))


fix:
let _ = build (makeRand(1,2), 0)

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> rand(1,7)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| _ -> rand(1,7)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))
| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))
| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))


fix:
let _ = build (makeRand(1,2), 0)

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> rand(1,7)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| _ -> rand(1,7)


fix:
let _ = build (makeRand(1, 7), 0)

bad:
let _ = build (makeRand(1, 78), 0)

annotated:
let _ = build (makeRand(1, 78), 0)


fix:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildThresh(VarX,VarX,VarX,VarX)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildTimes (VarX)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with
| _ -> buildTimes (VarX)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))
| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))
| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))


fix:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildThresh(VarX,VarX,VarX,VarX)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))

bad:
let _ = build (makeRand(1,2), 0)

annotated:
let _ = build (makeRand(1,2), 0)


fix:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))

bad:
f 2

annotated:
f 2


fix:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))

bad:
let fixpoint (f,b) = wwhile ((f,b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f,b), b)


fix:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))

bad:
let fixpoint (f,b) = wwhile ((f,b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f,b), b)


fix:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))

bad:
let fixpoint (f,b) = wwhile ((f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f, b)


fix:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))

bad:
let fixpoint (f,b) = wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f, b)


fix:
let fixpoint (f,b) = wwhile ( (let f x =  in f), b)

bad:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, (f b)))


fix:
let fixpoint (f,b) = wwhile ( (let f x =  in f), b)

bad:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, wwhile (f,b)))


fix:
let fixpoint (f,b) = 
let h x = let x = b in (x, x != f x)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
let h x = (b, b != f b)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
let h b = (b, b != f b)  in
wwhile (h, b)

bad:
let fixpoint (f,b) = 
let h x = (b, b != f b)  in
wwhile (h, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let h x = (b, b != f b)  in
wwhile (h, b)


fix:
let fixpoint (f,b) = 
let h b = (b, b != f b)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
let f x = (x, x != f x)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, b)

bad:
let fixpoint (f,b) = 
let f x = (x, x != f x)  in
wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = (x, x != f x)  in
wwhile (f, b)


fix:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, x)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, x)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != x)  in
wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx != x)  in
wwhile (f, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != x)  in
wwhile (g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = let xx = (f x) in (xx, xx != x)  in
wwhile (g, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let f x = let xx = (f x) in (xx, xx != x)  in
wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = let xx = (f x) in (xx, xx != x)  in
wwhile (f, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let a x = let xx = (f x) in (xx, xx != x)  in
wwhile (a, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let a x = let xx = (f x) in (xx, xx != x)  in
wwhile (a, b)


fix:
let sqsum xs = 
let f a x = (x *. x) in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a -> (x *. x) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a -> (x *. x) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (x *. x) in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = fun a x -> (x *. x) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = fun a x -> (x *. x) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (x *. x) in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = fun a x -> (x *. x) in
let base = 0.0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = fun a x -> (x *. x) in
let base = 0.0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x =  x in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe[] 3

annotated:
let _ = pipe[] 3


fix:
let pipe fs = 
let f a x = x + a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a -> a in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a -> a in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  "" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x + a in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x + a in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  "" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x + a in
let base = "" in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x + a in
let base = "" in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =   in
List.fold_left f base fs
E

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =   in
List.fold_left f base fs
E


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe[] 3

annotated:
let _ = pipe[] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x + 1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x + 1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = h::t -> h in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = h::t -> h in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x -> a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x -> a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (()) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (_) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (_) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (+) x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (+) x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  fun x b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base =  fun x b -> 0 + b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  fun x b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  fun x b in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (+) x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (+) x in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let _ = pipe []

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 0 (+)   in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 0 (+)   in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x a) a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (+) 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (+) 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (+) 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (x a) a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) a in
let base = (+) 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) a in
let base = (+) 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) x in
let base = (+) 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) x in
let base = (+) 0 in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = [] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ t in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ t in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = h in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = h in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = a in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = a in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = h ^ t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = h ^ t in
List.fold_left f base l


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = List.head fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = List.head fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = -> _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = -> _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = :: 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = :: 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (::) 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (::) 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (::) 0 2 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (::) 0 2 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (::)  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (::)  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 0 (::) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 0 (::) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (-) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = * 1 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = * 1 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x a in
let base = 0 + in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = 0 + in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> (+) y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun y -> (+) x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun y -> (+) x  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun _ -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x -> 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x -> 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun _ -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun _ ->  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun _ ->  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun _ -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun _ -> _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun _ -> _ in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x a in
let base = x -> x + 1 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x -> x + 1 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs = 
let f a x = x a in
let base = x + 1 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x + 1 in
List.fold_left f base fs


fix:
let rec clone x n = 
if n > 0 then clone (x) (n - 1) else []

bad:
let rec clone x n = 
if n > 0 then clone (x::[]) (n - 1) else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n > 0 then clone (x::[]) (n - 1) else []


fix:
let rec clone x n = 
let acc = [] in
if n > 0 then clone (x@acc) (n - 1) else []

bad:
let rec clone x n = 
let acc = [] in
if n > 0 then clone (x::acc) (n - 1) else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let acc = [] in
if n > 0 then clone (x::acc) (n - 1) else []


fix:
let rec clone x n = 
let acc = [x] in
if n > 0 then clone (x) (n - 1) else []

bad:
let _ = clone 3 5

annotated:
let _ = clone 3 5


fix:
let rec clone x n = 
let acc = [x] in
if n > 0 then clone (x) (n - 1) else []

bad:
let rec clone x n = 
let acc = [] in
if n > 0 then clone (x::x) (n - 1) else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let acc = [] in
if n > 0 then clone (x::x) (n - 1) else []


fix:
let rec clone x n = 
let acc = [0] in
if n > 0 then clone (x) (n - 1) else []

bad:
let rec clone x n = 
let acc = [x] in
if n > 0 then clone (x::acc) (n - 1) else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let acc = [x] in
if n > 0 then clone (x::acc) (n - 1) else []


fix:
let rec clone x n = 
let acc = [0] in
if n > 0 then clone (x) (n - 1) else []

bad:
let rec clone x n = 
let acc = [0] in
if n > 0 then clone (x::acc) (n - 1) else []

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let acc = [0] in
if n > 0 then clone (x::acc) (n - 1) else []


fix:
let _ = clone 3 (-4)

bad:
let _ = clone 3 -4

annotated:
let _ = clone 3 -4


fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))

bad:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then (to_append @ l1), l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then (to_append @ l1), l2


fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))

bad:
) else (l1, (to_append @ l2))

annotated:
) else (l1, (to_append @ l2))


fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))

bad:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then (to_append @ l1), l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then (to_append @ l1), l2


fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))

bad:
)

annotated:
)


fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))

bad:
) else (l1, (to_append @ l2))

annotated:
) else (l1, (to_append @ l2))


fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
if (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))

bad:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
if (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
if (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = (l1, l2) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = (l1, l2) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ([a+1],[b+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ([a+1],[b+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([(List.hd x)+1],[(List.hd x)+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([(List.hd x)+1],[(List.hd x)+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ((List.hd a)+1

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ((List.hd a)+1


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
],(List.hd b)+2

annotated:
],(List.hd b)+2


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+1])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+a],[x+a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x+a],[x+a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+1])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+a],[x+a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x+a],[x+a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+1])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x::a],[x::a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x::a],[x::a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
let (one,two) = a in (x::one,y::two)
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = l2 in
let (one,two) = a in (x::one,y::two)
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let y = l2 in
let (one,two) = a in (x::one,y::two)
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.split  ((let (one,two) = a in (x::one,y::two)))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.combine (let (one,two) = a in (x::one,y::two))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.combine (let (one,two) = a in (x::one,y::two))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.split  ((let (one,two) = a in (x::one,y::two)))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.split (List.combine (let (one,two) = a in (x::one,y::two)))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.split (List.combine (let (one,two) = a in (x::one,y::two)))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
(let (one,two) = a in (x::one,y::two))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.combine (List.split  ((let (one,two) = a in (x::one,y::two))))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.combine (List.split  ((let (one,two) = a in (x::one,y::two))))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match x with
| (a, b) -> (a + b) mod 10
in
let base = (_,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match x with
| (a, b) -> (a + b) mod 10
in
let base = (_,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match x with
| (a, b) -> (a + b) mod 10
in
let base = ((_),[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = match x with
| (a, b) -> (a + b) mod 10
in
let base = ((_),[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = base in 
match x with
| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = base in 
match x with
| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = ("",[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = ("",[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) then (0, b1::b2) else (0, (fir + sec + b1)::b2)  
else 
if (List.length b2 = List.length l1) then (0, b1::b2) else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then (0, (fir + sec + b1)::b2)  
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
if (List.length b2 = List.length l1) then (0,b1::b2) else (0,b1::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then (0, (fir + sec + b1)::b2)  
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
if (List.length b2 = List.length l1) then (0,b1::b2) else (0,b1::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (0, (fir + sec + b1)::b2)  
else 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (0, (fir + sec + b1)::b2)  
else if 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (0, (fir + sec + b1)::b2)  
else if 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
let rec helper a b acc = 
if (a > 0) 
then helper (a - 1) b (bigAdd b b)
else acc
in
helper i l []

bad:
let rec mulByDigit i l = 
let rec helper a b acc = 
if (a > 0) 
then helper (a - 1) b (bigAdd b b)
else acc
in
helper i l 0

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper a b acc = 
if (a > 0) 
then helper (a - 1) b (bigAdd b b)
else acc
in
helper i l 0


fix:
let _ = mulByDigit 3 [1;7]

bad:
let _ = mulByDigit 3 [1;7]
kjlk

annotated:
let _ = mulByDigit 3 [1;7]
kjlk


fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let _ = mulByDigit 3 [1;7]

sdf

annotated:
let _ = mulByDigit 3 [1;7]

sdf


fix:
let bigMul l1 l2 = 
let f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))
in
let base = (0, [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match x with
| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))
in
let base = (0, [0]) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
match x with
| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))
in
let base = (0, [0]) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))
in
let base = (0, [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))
in
let base = (0, [0]) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))
in
let base = (0, [0]) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = let r = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = let r = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = let r = makeRand(0,2) in in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = let r = makeRand(0,2) in in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = r = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = r = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))


fix:
let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let rdm = rand in
match rdm with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))


fix:
let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
let rdm = rand in
match rdm with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))


fix:
let rec build (rand, depth) =
let rdm = rand(0,7) in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with 
| (a,b) -> 
let rdm = rand(a,b) in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
match rand with 
| (a,b) -> 
let rdm = rand(a,b) in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))


fix:
let b = build(r,5)

bad:
let b = build(rnd,5)

annotated:
let b = build(rnd,5)


fix:
let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

bad:
let rec digitsOfInt n = match n with
| n < 0 -> []
| h::t -> h

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| n < 0 -> []
| h::t -> h


fix:
let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]

annotated:
let _ = listReverse ["a"; "b"; "c"; "d"]


fix:
let rec digitsOfInt n =
if n <= 0 then []
else let n2 = [n mod 10] @ digitsOfInt (n/10) in
listReverse n2

bad:
let rec digitsOfInt n =
if n <= 0 then []
else let n2 = [n mod 10] @ digitsOfInt (n/10) in
listReverse n2

annotated:
let rec digitsOfInt n =
if n <= 0 then []
else let n2 = [n mod 10] @ digitsOfInt (n/10) in
listReverse n2


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n <= 0 then []
else (n mod 10) :: digitsOfInt (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 then []
else (n mod 10) :: digitsOfInt (n/10)


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> []
| h::t -> h :: listReverse l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| h::t -> h :: listReverse l


fix:
let rec myAppend l n = match l with
| [] -> [i]
| h::t -> h :: myAppend t i

bad:
let rec listReverse l = match l with
| [] -> []
| h::t -> listReverse t :: [h]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
| [] -> []
| h::t -> listReverse t :: [h]


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w =
listReverse (explode w) = explode w

annotated:
let palindrome : string -> bool = fun  w  -> 
listReverse (explode w) = explode w


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s

bad:
let rec assoc (d,k,l) = let l match with
| [] -> d
| h::t -> let h match with
| (s*i) -> s
| d

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  let l match with
| [] -> d
| h::t -> let h match with
| (s*i) -> s
| d


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s

bad:
let rec assoc (d,k,l) = l match with
| [] -> d
| h::t -> h match with
| (s*i) -> s
| d

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  l match with
| [] -> d
| h::t -> h match with
| (s*i) -> s
| d


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (s*i) -> s
| d

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| (s*i) -> s
| d


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s
| d

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| h::t -> match h with
| s,i -> s
| d


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> i

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let _ = removeDuplicates []

bad:
let _ = removeDuplicates [];
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
let _ = removeDuplicates [];
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let rec wwhile (f,b) = match (f b) with
| (f', x') -> if x' then wwhile (f, f')
else f'

bad:
let rec wwhile (f,b) = match b with
| (f', b') -> if b' then wwhile (f, f')
else f'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with
| (f', b') -> if b' then wwhile (f, f')
else f'


fix:
let rec wwhile (f,b) = match f,b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'

bad:
let rec wwhile (f,b) = match me b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match me b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'


fix:
let rec wwhile (f,b) = match f b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'

bad:
let me x = let xx = x*x*x in (xx, xx < 100) in
wwhile (me, 2)

annotated:
let me x = let xx = x*x*x in (xx, xx < 100) in
wwhile (me, 2)


fix:
let rec wwhile (f,b) = match f b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
(s,i) -> if s = k then i
else assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile ((let helper = (f b,f b != helper)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let helper = (f b,f b ! ->  helper)),b)


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
(s,i) -> if s = k then i
else assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile (let helper = (f b,f b != helper),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = (f b,f b ! ->  helper),b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true) else (f b, false) in helper,b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true) else (f b, false) in helper, b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)
else (f b, false)
in helper,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true)
else (f b, false)
in helper,b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let b = (f x) in (b, b ! ->  x)),b)


fix:
let fixpoint (f,b) = wwhile ((let helper b =
if b = f b then (f b, false)
else (f b, true)
in helper),b)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
fixpoint (f, 1)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
fixpoint (f, 1)


fix:
let fixpoint (f,b) = wwhile ((let helper b =
if b = f b then (f b, false)
else (f b, true)
in helper),b)

bad:
let _ = fixpoint (collatz, 9001)

annotated:
let _ = fixpoint (collatz, 9001)


fix:
let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,6) with
|0 -> build(rand,(depth - 1))
|1 -> buildSine(build(rand,(depth - 1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))
|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))
|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),
build(rand, (depth - 1)),build(rand, (depth - 1)))

bad:
let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,7) with
|0 -> build(rand, (depth-1))
|1 -> buildSine(build(rand, (depth-1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))
|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))
|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))
|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))
|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,7) with
|0 -> build(rand, (depth-1))
|1 -> buildSine(build(rand, (depth-1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))
|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))
|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))
|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))
|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))


fix:
let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,6) with
|0 -> build(rand,(depth - 1))
|1 -> buildSine(build(rand,(depth - 1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))
|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))
|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),
build(rand, (depth - 1)),build(rand, (depth - 1)))

bad:
let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,5) with
|0 -> build(rand,(depth - 1))
|1 -> buildSine(build(rand,(depth - 1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))
|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))
|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),
build(rand, (depth - 1)),build(rand, (depth - 1)))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,5) with
|0 -> build(rand,(depth - 1))
|1 -> buildSine(build(rand,(depth - 1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))
|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))
|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),
build(rand, (depth - 1)),build(rand, (depth - 1)))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = (fst x + snd x) in
match a with
| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t
| _ -> (carry/10)::[carry mod 10]
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = (fst x + snd x) in
match a with
| h::t -> ((h+carry)/10)::((h+c) mod 10)::t
| _ -> (carry/10)::[carry mod 10]
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let carry = (fst x + snd x) in
match a with
| h::t -> ((h+carry)/10)::((h+c) mod 10)::t
| _ -> (carry/10)::[carry mod 10]
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((o,sum),[])	      -> (0,sum)
| ((o,sum),(b,c)::l') -> let d = (b + c + o) in
if d

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((o,sum),[])	      -> (0,sum)
| ((o,sum),(b,c)::l') -> let d = (b + c + o) in
if d < 10 then (0, d::sum)
else (1, (d-10)::sum)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match (a,x) with
| ((o,sum),[])	      -> (0,sum)
| ((o,sum),(b,c)::l') -> let d = (b + c + o) in
if d < 10 then (0, d::sum)
else (1, (d-10)::sum)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = match a with (x,y) -> x in
match x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in
let digit = (carry + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (*let carry = match a with (x,y) -> x in*)
match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in
let digit = (a + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (*let carry = match a with (x,y) -> x in*)
match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in
let digit = (a + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = match a with (x,y) -> x in
match x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in
let digit = (carry + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = match a with (x,y) -> x in
match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in
let digit = (a + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let carry = match a with (x,y) -> x in
match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in
let digit = (a + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match x with (d1,d2) -> let c' = (c + d1 + d2)/10 in
let digit = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match x with (d1,d2) -> let c' = (c + d1 + d2)/10 in
let digit = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in
let digit = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in
let digit = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
if i = 1 then l
else if i = 0 then []
else if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with
| h::t -> (h*(-1))::t
| _ -> []
else bigAdd (bigAdd l l) (mulByDigit (i-2) l)

bad:
let rec mulByDigit i l = 
if i = 1 then l
else if i = 0 then []
else if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with
| h::t -> (h*(-1))::t
| _ -> 0
else bigAdd (bigAdd l l) (mulByDigit (i-2) l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i = 1 then l
else if i = 0 then []
else if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with
| h::t -> (h*(-1))::t
| _ -> 0
else bigAdd (bigAdd l l) (mulByDigit (i-2) l)


fix:
let bigMul l1 l2 = 
let f a x = match a with
(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in
let base = failwith (0, []) in
let args = failwith l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in
let base = failwith (0, []) in
let args = failwith l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then -> 4

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then -> 4


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let _ = digitsOfInt -3124

annotated:
let _ = digitsOfInt -3124


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then 4

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then 4


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then 0

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then 0


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then _

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then _


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then 'a

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then 'a


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then '

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then '


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then n


fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else n


fix:
let _ = digitsOfInt 3124

bad:
let _ = digitsOfInt -3124

annotated:
let _ = digitsOfInt -3124


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let f elem =

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let f elem = 
Printf.printf "Element is %d\n" elem in
List.iter f n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let f elem = 
Printf.printf "Element is %d\n" elem in
List.iter f n


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| _ -> loop n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let f elem = 
Printf.printf "Element is %d\n" elem in
List.iter f n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let f elem = 
Printf.printf "Element is %d\n" elem in
List.iter f n


fix:
let rec additivePersistence n = 
if n mod 10  != 0 then 
x = x + 1

bad:
let rec additivePersistence n =
let x = 0
if n mod 10  != 0 then 
x = x + 1

annotated:
let rec additivePersistence : int -> int = fun  n  -> 
let x = 0
if n mod 10  != 0 then 
x = x + 1


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let rec additivePersistence n = 
let x = 0
if n mod 10  != 0 then 
x = x + 1

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let x = 0
if n mod 10  != 0 then 
x = x + 1


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let total += sumList (digitsOfInt (abs n) )
else x

annotated:
let total += sumList (digitsOfInt (abs n) )
else x


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n mod 10  != 0 then 
let x = 0


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let total += sumList (digitsOfInt (abs n) )
x = x + 1
else x

annotated:
let total += sumList (digitsOfInt (abs n) )
x = x + 1
else x


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n mod 10  != 0 then 
let x = 0


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0 in
let total += sumList (digitsOfInt (abs n) )
x = x + 1
else x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n mod 10  != 0 then 
let x = 0 in
let total += sumList (digitsOfInt (abs n) )
x = x + 1
else x


fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

bad:
let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0 in
let total = sumList (digitsOfInt (abs n) )
x = x + 1
else x

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n mod 10  != 0 then 
let x = 0 in
let total = sumList (digitsOfInt (abs n) )
x = x + 1
else x


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let rec addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let rec addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
incr addP
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
incr addP
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let rec addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
| addP

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
| addP


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP -> addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP -> addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal addP = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) addP in match n with
| 0 -> 0
| _ -> recursive_loop n addP

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal addP = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) addP in match n with
| 0 -> 0
| _ -> recursive_loop n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let addP = 0 in
let rec recursive_loop retVal addP = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) addP in match n with
| 0 -> 0
| _ -> recursive_loop n


fix:
let rec listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

bad:
let rec listReverse l = 
let rev l =
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rev l =
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l


fix:
let rec listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

bad:
let rec listReverse l = 
let rev l =
let rec aux acc = 
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rev l =
let rec aux acc = 
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l


fix:
let palindrome w =
let reverse = listReverse w in
if reverse = w then true
else false

bad:
let _ = palindrome "malayalam"

annotated:
let _ = palindrome "malayalam"


fix:
let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = pk then true
else false

bad:
let _ = palindrome "malayalam"

annotated:
let _ = palindrome "malayalam"


fix:
let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = pk then true
else false

bad:
let palindrome w =
let reverse = explode (listReverse w) in
if reverse = w then true
else false

annotated:
let palindrome : string -> bool = fun  w  -> 
let reverse = explode (listReverse w) in
if reverse = w then true
else false


fix:
let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = pk then true
else false

bad:
let palindrome w =
let reverse = listReverse (explode w) in
if reverse = w then true
else false

annotated:
let palindrome : string -> bool = fun  w  -> 
let reverse = listReverse (explode w) in
if reverse = w then true
else false


fix:
let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = pk then true
else false

bad:
let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = w then true
else false

annotated:
let palindrome : string -> bool = fun  w  -> 
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = w then true
else false


fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (num,name)::tail ->
if num = k then name
else assoc(d, k, tail)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h seen then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h seen then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in 
if List.mem h seen then h::seen'

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in 
if List.mem h seen then h::seen'


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = 
if List.mem h seen then h::seen'

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = 
if List.mem h seen then h::seen'


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen'

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen'


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
else seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
else seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
else h::seen

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
else h::seen


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else param
| _ -> b

bad:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else num
| _ -> 0

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with
| (func, param) ->
if param = true then func param 
else num
| _ -> 0


fix:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else param
| _ -> b

bad:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else num
| _ -> b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with
| (func, param) ->
if param = true then func param 
else num
| _ -> b


fix:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then f param 
else 0

bad:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then f param 
else 0
| _ -> b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with
| (func, param) ->
if param = true then f param 
else 0
| _ -> b


fix:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e

bad:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile f e

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with
| (e, boo) ->
if boo = true then e
else wwhile f e


fix:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e

bad:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile e b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with
| (e, boo) ->
if boo = true then e
else wwhile e b


fix:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e

bad:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with
| (e, boo) ->
if boo = true then e
else wwhile b


fix:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e

bad:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with
| (e, boo) ->
if boo = true then e
else wwhile f b


fix:
let rec wwhile (f,b) = 
let ans = f b in
match ans with
| (num, boo) ->
if boo = true then wwhile(f, num)
else num

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let fixpoint (f,b) = 
wwhile 
((let func p = 
let cal = f p in 
if p == cal then (cal, false)
else (cal, true) in func
),b)

bad:
let fixpoint (f,b) = 
wwhile 
((let func p = 
let cal = f p in 
if p == cal then (cal, false)
else (cal, true) in xx
),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile 
((let func p = 
let cal = f p in 
if p == cal then (cal, false)
else (cal, true) in xx
),b)


fix:
let rec exprToString e = match e with
| VarX -> "X"
| VarY -> "Y"
| Sine sin  -> "( sin "
| Cosine cos -> "cos"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(t1 * t2)"
| Thresh (th1, th2, th3, th4) -> "bullshit"

bad:
let rec exprToString e = match e with
| VarX -> "X"
| VarY -> "Y"
| Sine sin  -> "( sin "
| Cosine cos -> "cos"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(t1 * t2)"
| Thresh (th1, th2, th3, th4) ->

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "X"
| VarY -> "Y"
| Sine sin  -> "( sin "
| Cosine cos -> "cos"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(t1 * t2)"
| Thresh (th1, th2, th3, th4) ->


fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "(sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "(cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"
| Thresh (th1, th2, th3, th4) -> "bullshit"

bad:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "(sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "(cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(" ^ (exprToString t1) ^ "*" (exprToString t2) ^ ")"
| Thresh (th1, th2, th3, th4) -> "bullshit"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "(sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "(cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(" ^ (exprToString t1) ^ "*" (exprToString t2) ^ ")"
| Thresh (th1, th2, th3, th4) -> "bullshit"


fix:
let rec assoc (d,k,l) = match l with
(* If list is empty, then return the first int *)
| [] -> d
(* If it is of this pattern, check if the number is equal to the tuple's number *)
| (name,num)::tail ->
(* If it is, return the number; else recursively call with remainder *)
if name = k then num
else assoc(d, k, tail)

bad:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "((" ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2)"
| Times (t1, t2) -> (exprToString t1) ^ "*" ^ (exprToString t2) 
| Thresh (th1, th2, th3, th4) -> "(" ^ (exprToString th1) ^ "<" ^ 
(exprToString th2) ^ "?" ^ (exprToString th3) ^ 
":" ^ (exprToString th4) ^ ")"
| DivAdd (ds1, ds2, ds3, ds4) -> "((" ^ (exprToString ds1) ^ "+" ^
(exprToString ds2) ^ ") / (" ^ (exprToString ds3) ^
"+" ^ (exprToString ds4) "))"
| TriMult (tm1, tm2, tm3) -> "(" ^ (exprToString tm1) ^ "*" ^ (exprToString tm2) ^
"*" (exprToString tm3) ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "((" ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2)"
| Times (t1, t2) -> (exprToString t1) ^ "*" ^ (exprToString t2) 
| Thresh (th1, th2, th3, th4) -> "(" ^ (exprToString th1) ^ "<" ^ 
(exprToString th2) ^ "?" ^ (exprToString th3) ^ 
":" ^ (exprToString th4) ^ ")"
| DivAdd (ds1, ds2, ds3, ds4) -> "((" ^ (exprToString ds1) ^ "+" ^
(exprToString ds2) ^ ") / (" ^ (exprToString ds3) ^
"+" ^ (exprToString ds4) "))"
| TriMult (tm1, tm2, tm3) -> "(" ^ (exprToString tm1) ^ "*" ^ (exprToString tm2) ^
"*" (exprToString tm3) ^ ")"


fix:
let pipe fs = 
let f a x = x a  in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = f x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = f a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base =  3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = a  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base = a  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a  in
let base =  f 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base =  x 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base =  x 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base =  fs 3 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a  in
let base =  fs 3 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base =  f (x a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base =  f (x a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base =  f ((f a x) a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base =  f ((f a x) a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base =  f base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x in
let base =  f base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f x in
let base = 3  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = f x in
let base = 3  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fs x in
let base = 3  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fs x in
let base = 3  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = f  in
List.fold_left f base fs


fix:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
match fs with 
| [] -> base
| f::fs' -> 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> base
| f::fs' -> 
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f 0 in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f x in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = fs' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = fs' in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = fs' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = fs' in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = x a in
let base = f(x,a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = x a in
let base = f(x,a) in
List.fold_left f base fs


fix:
let pipe fs =
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = x a in
let base = f a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = x a in
let base = f a in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs =
let f a x = x a in
let base = f (x a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = x a in
let base = f (x a) in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let pipe fs =
let f a x = x a in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> 
let f a x = x a in
let base = _ in
List.fold_left f base fs


fix:
let stringOfList f l = 
List.map sepConcat l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = 
List.map sepConcat l

bad:
let stringOfList f l = 
List.map (sepConcat f l) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat f l) l


fix:
let stringOfList f l = 
List.map (sepConcat "") l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = 
List.map (sepConcat (f "")) l

bad:
let stringOfList f l = 
List.map (sepConcat fun y -> f "") l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat fun y -> f "") l


fix:
let stringOfList f l = 
List.map ( sepConcat (f l) ) l

bad:
let stringOfList f l = 
List.map (( sepConcat "" ) l) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (( sepConcat "" ) l) l


fix:
let stringOfList f l = 
List.map ( sepConcat (f l) ) l

bad:
let stringOfList f l = 
List.map f (( sepConcat "" ) l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map f (( sepConcat "" ) l)


fix:
let stringOfList f l = 
List.map ( sepConcat (f) ) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat f) (f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat f) (f l)


fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat f) (f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat f) (f l)


fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat ("" l)) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat ("" l)) l


fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat "" l) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat "" l) l


fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat f l) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map (sepConcat f l) l


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
List.map f (sepConcat f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map f (sepConcat f l)


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
List.map f (sepConcat l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map f (sepConcat l)


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
(sepConcat "" l) List.map (f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
(sepConcat "" l) List.map (f l)


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
(sepConcat List.map (f l) l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
(sepConcat List.map (f l) l)


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
(sepConcat (List.map (f l)) l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
(sepConcat (List.map (f l)) l)


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ sepConcat ";" ^ List.map(f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ sepConcat ";" ^ List.map(f l) ^ "]"


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ sepConcat ";" List.map(f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ sepConcat ";" List.map(f l) ^ "]"


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ sepConcat ";" List.map(f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
"[" ^ sepConcat ";" List.map(f l) ^ "]"


fix:
let rec clone x n = match n with 
| 0 -> []
| n -> x@clone x (n-1)

bad:
let rec clone x n = match n with 
| 0 -> []
| _ -> clone x::[] (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with 
| 0 -> []
| _ -> clone x::[] (n-1)


fix:
let rec clone x n = 
if n <= 0 then []
else [x]@clone x (n-1)

bad:
let rec clone x n = match n with 
if n <= 0 then []
else [x]@clone x (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with 
if n <= 0 then []
else [x]@clone x (n-1)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then List.combine (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then List.combine (l1, l2)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then List.combine l1 l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then List.combine l1 l2


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then l1 l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then l1 l2


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero(0::l1 l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero(0::l1 l2)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero((0::l1) l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero((0::l1) l2)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let rec padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero((0::l1) l2)

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero((0::l1) l2)


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then 0::l1

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then 0::l1


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (List.append [0] l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (List.append [0] l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then (l1, 0::l2)
else if List.length l1 < List.length l2 then (0::l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, 0::l2)
else (l1::[], l2::[])

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, 0::l2)
else (l1::[], l2::[])


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then (l1, 0::l2)
else if List.length l1 < List.length l2 then (0::l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then (l1, l2::0)
else if List.length l1 < List.length l2 then (0::l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then (l1, l2::0)
else if List.length l1 < List.length l2 then (0::l1, l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then clone (l1, 0::l2)
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then clone (l1, 0::l2)
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then clone (l1, 0::l2) ,
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then clone (l1, 0::l2) ,
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) 
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) 
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then List.append(l1, clone(0::l2) 
else if List.length l1 < List.length l2 then List.append (0::l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then List.append(l1, clone(0::l2) 
else if List.length l1 < List.length l2 then List.append (0::l1, l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0 l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
then List.append (0::l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0 l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
then List.append (0::l1, l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(l1, l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
then List.append (clone (l1 l2G), l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(l1, l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
then List.append (clone (l1 l2G), l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(l1, l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (l1 l2G), l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(l1, l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (l1 l2G), l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0, l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G), l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0, l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G), l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0  l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G), l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0  l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G), l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1 clone(0  l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G) l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1 clone(0  l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G) l2)
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0  l1G) l2 )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
List.append (clone (0 l2G) l1) l2
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0  l1G) l2 )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
List.append (clone (0 l2G) l1) l2
else (l1, l2)


fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, (clone 0  l1G) l2 )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
List.append ((clone 0 l2G) l1, l2)
else (l1, l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, (clone 0  l1G) l2 )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
List.append ((clone 0 l2G) l1, l2)
else (l1, l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1) ( 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| [] -> []
| h::t -> h in
match x with
| [] -> [] 
| h2::t2 -> in 
let base = h in
let args = h2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| [] -> []
| h::t -> h in
match x with
| [] -> [] 
| h2::t2 -> in 
let base = h in
let args = h2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1) ( 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (sum mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (sum mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1) ( 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (sum mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (sum mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1) ( 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10))
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10))
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> 0
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> 0
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t


fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else (prod mod 10)::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else (prod mod 10)::t


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t
else (prod mod 10)::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t
else (prod mod 10)::t


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )
else (prod mod 10)::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )
else (prod mod 10)::t


fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )
else (prod mod 10)::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )
else (prod mod 10)::t


fix:
let rec mulByDigit i l = 
let mult i l = 
let f a x = 
let (carryOver, rest) = a in
let num = carryOver + (x * i) in
let secondDigit = num mod 10 in
let carryOver = num / 10 in
let result = secondDigit::rest in (carryOver, rest) in
let base = (0, []) in
let (carryOver, rest) = List.fold_left f base (List.rev l) in
carryOver::rest in
removeZero(mult i l)

bad:
let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
if prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]
else firstDigit::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
if prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]
else firstDigit::t


fix:
let rec mulByDigit i l = 
let mult i l = 
let f a x = 
let (carryOver, rest) = a in
let num = carryOver + (x * i) in
let secondDigit = num mod 10 in
let carryOver = num / 10 in
let result = secondDigit::rest in (carryOver, rest) in
let base = (0, []) in
let (carryOver, rest) = List.fold_left f base (List.rev l) in
carryOver::rest in
removeZero(mult i l)

bad:
let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 
else let temp = h2 mod 10 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 
else let temp = h2 mod 10 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t


fix:
let rec mulByDigit i l = 
let mult i l = 
let f a x = 
let (carryOver, rest) = a in
let num = carryOver + (x * i) in
let secondDigit = num mod 10 in
let carryOver = num / 10 in
let result = secondDigit::rest in (carryOver, rest) in
let base = (0, []) in
let (carryOver, rest) = List.fold_left f base (List.rev l) in
carryOver::rest in
removeZero(mult i l)

bad:
let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 
else temp = h2 mod 10 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 
else temp = h2 mod 10 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t


fix:
let rec mulByDigit i l = 
let mult i l = 
let f a x = 
let (carryOver, rest) = a in
let num = carryOver + (x * i) in
let secondDigit = num mod 10 in
let carryOver = num / 10 in
let result = secondDigit::rest in (carryOver, rest) in
let base = (0, []) in
let (carryOver, rest) = List.fold_left f base (List.rev l) in
carryOver::rest in
removeZero(mult i l)

bad:
let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t


fix:
let bigMul l1 l2 = 
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
List.fold_left f base args

bad:
let bigMul l1 l2 = 
let f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
List.fold_left f base args

bad:
let bigMul l1 l2 = 
let f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
List.fold_left f base args

bad:
let bigMul l1 l2 = 
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
xs.(0) + hd xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
xs.(0) + hd xs


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
if xs.length != 0 then xs.(0) + sumList(hd xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if xs.length != 0 then xs.(0) + sumList(hd xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
if List.length xs != 0 then xs.(0) + sumList(hd xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if List.length xs != 0 then xs.(0) + sumList(hd xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
if List.length xs != 0 then xs.(0) + sumList(List.hd xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if List.length xs != 0 then xs.(0) + sumList(List.hd xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
if List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
let rec int q =
q + if List.length xs != 0 then List.nth xs 0 
| sumList(List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let rec int q =
q + if List.length xs != 0 then List.nth xs 0 
| sumList(List.tl xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
let rec int q =
q + if List.length xs != 0 then List.nth xs 0 
sumList(List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let rec int q =
q + if List.length xs != 0 then List.nth xs 0 
sumList(List.tl xs)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
let int q =
q + x :: xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let int q =
q + x :: xs


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
let int q =
q + x :: xs

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let int q =
q + x :: xs


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
let x :: t = xs in
let int q = q + x + sumList(t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let x :: t = xs in
let int q = q + x + sumList(t)


fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
let x :: t = xs in
let int q = q + x + sumList (t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let x :: t = xs in
let int q = q + x + sumList (t)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec sumList xs = 
let x :: t = xs in
if t != [] then x + sumList (t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let x :: t = xs in
if t != [] then x + sumList (t)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec sumList xs = 
let x :: t = xs in
if x != [] then x + sumList (t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let x :: t = xs in
if x != [] then x + sumList (t)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec sumList xs = 
let x :: t = xs in
x + if t != [] then sumList (t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
let x :: t = xs in
x + if t != [] then sumList (t)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec digitsOfInt n = 
n mod 10 :: if n <> [] then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
n mod 10 :: if n <> [] then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else []

bad:
let rec digitsOfInt n = 
let int list xs = 
n mod 10 :: if n > 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list xs = 
n mod 10 :: if n > 0 then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else []

bad:
let rec digitsOfInt n = 
let digInt =
n mod 10 :: if n > 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let digInt =
n mod 10 :: if n > 0 then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else []

bad:
let rec digitsOfInt n = 
let int list digInt =
n mod 10 :: if n > 0 then digitsOfInt (n / 10) else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt =
n mod 10 :: if n > 0 then digitsOfInt (n / 10) else []


fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else digInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else digInt


fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else digInt

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else digInt


fix:
let rec digitsOfInt n = 
let list digInt = (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let int list digInt :: n mod 10 in
if n > 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt :: n mod 10 in
if n > 0 then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let list digInt = (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let list digInt :: n mod 10 in
if n > 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let list digInt :: n mod 10 in
if n > 0 then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let list digInt = (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let list digInt :: (n mod 10) in
if n > 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let list digInt :: (n mod 10) in
if n > 0 then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let list digInt = (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let list digInt :: (n mod 10)
if n > 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let list digInt :: (n mod 10)
if n > 0 then digitsOfInt (n / 10)


fix:
let rec digitsOfInt n = 
let list digInt = (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let list digInt :: (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let list digInt :: (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)


fix:
let int list digInt = []

bad:
let rec digitsOfInt n = 
let int list digInt :: (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt :: (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)


fix:
let int list digInt = []

bad:
let rec digitsOfInt n = 
let int list digInt =
n mod 10 :: if n / 10 <> 0 then digitsOfInt (n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt =
n mod 10 :: if n / 10 <> 0 then digitsOfInt (n / 10)


fix:
let int list digInt = []

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 :: digitsOfInt( n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt = n mod 10 :: digitsOfInt( n / 10)


fix:
let int list digInt = []

bad:
let rec digitsOfInt n = 
digInt = n mod 10 :: digitsOfInt( n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
digInt = n mod 10 :: digitsOfInt( n / 10)


fix:
let int list digInt = []

bad:
let rec digitsOfInt n = 
int list digInt = n mod 10 :: digitsOfInt( n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
int list digInt = n mod 10 :: digitsOfInt( n / 10)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 :: digInt 
if (n / 10) <> 0 then digitsOfInt ( n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt = n mod 10 :: digInt 
if (n / 10) <> 0 then digitsOfInt ( n / 10)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 :: digInt in
if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt = n mod 10 :: digInt in
if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)


fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec digitsOfInt n = 
let int list digInt = [] in
if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let int list digInt = [] in
if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)


fix:
let l = []

bad:
let rec digitsOfInt n = 
let digInt =
if (n / 10) <> 0 
then digInt :: digitsOfInt ( n / 10) 
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let digInt =
if (n / 10) <> 0 
then digInt :: digitsOfInt ( n / 10) 
else []


fix:
let l = []

bad:
let rec digitsOfInt n = 
let digInt =
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let digInt =
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []


fix:
let l = []

bad:
let rec digitsOfInt n = 
let digInt = n mod 10
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let digInt = n mod 10
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []


fix:
let l = []

bad:
let rec digitsOfInt n = 
let digInt =
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let digInt =
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []


fix:
let rec digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

bad:
let digitsOfInt n =
let l = [] in
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let l = [] in
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)


fix:
let rec digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

bad:
let digitsOfInt n =
let l = [] 
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let l = [] 
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)


fix:
let rec digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

bad:
let digitsOfInt n =
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)


fix:
let rec digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

bad:
let digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)


fix:
let rec digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

bad:
let digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)


fix:
let rec listReverse l = 
match l with 
| []   -> []
| x::l -> x :: listReverse(l)

bad:
let rec listReverse l = 
match l with 
| []   -> []
| x::l -> listReverse(l) :: x

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with 
| []   -> []
| x::l -> listReverse(l) :: x


fix:
let rec listReverse l = 
match l with 
| []   -> []
| x::l -> x :: listReverse(l)

bad:
let rec listReverse l = 
match l with 
| []   -> []
| x::l -> x :: listReverse(l) x

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with 
| []   -> []
| x::l -> x :: listReverse(l) x


fix:
let rec append x y =
match y with
| []   -> x
| h::t -> append (h::x) t

bad:
let rec listReverse l = 
match l with 
| [] -> []
| h::t -> listReverse(t) :: h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with 
| [] -> []
| h::t -> listReverse(t) :: h


fix:
let rec listReverse l = 
let h::t = l in
match l with 
| []   -> []
| h::t -> listReverse t

bad:
let rec listReverse l = 
match l with 
| [] -> []
| h::t -> listReverse t :: h :: []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with 
| [] -> []
| h::t -> listReverse t :: h :: []


fix:
let rec sumList xs =
match xs with
| [] -> 0
| h::t -> h + sumList(t)

bad:
let rec sumList xs = 
match xs with
| [] -> x + 0
| h::t -> x + sumList(t)

annotated:
let rec sumList : int list -> int = fun  xs  ->  
match xs with
| [] -> x + 0
| h::t -> x + sumList(t)


fix:
let rec sumList xs =
match xs with
| [] -> 0
| h::t -> h + sumList(t)

bad:
let rec sumList xs =
let x =
match xs with
| [] -> x + 0
| h::t -> x + sumList(t)

annotated:
let rec sumList : int list -> int = fun  xs  -> 
let x =
match xs with
| [] -> x + 0
| h::t -> x + sumList(t)


fix:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> (listReverse t)

bad:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> (listReverse t) :: h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| h::t -> (listReverse t) :: h


fix:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> (listReverse t)

bad:
let rec listReverse l = 
if l <> [] then let
match l with 
| []   -> l
| h::t -> (listReverse t) :: h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
if l <> [] then let
match l with 
| []   -> l
| h::t -> (listReverse t) :: h


fix:
let rec listReverse2 l dest = 
match l with
| [] -> []
| h::t -> listReverse2 t (h::dest)

bad:
let rec listReverse l = 
if l <> [] then let
match l with 
| []   -> l
| h::t -> (listReverse t) :: h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
if l <> [] then let
match l with 
| []   -> l
| h::t -> (listReverse t) :: h


fix:
let rec listReverse2 l dest = 
match l with
| [] -> []
| h::t -> listReverse2 t (h::dest)

bad:
let rec listReverse l = 
if l <> [] then 
match l with 
| []   -> l
| h::t -> (listReverse t) :: h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
if l <> [] then 
match l with 
| []   -> l
| h::t -> (listReverse t) :: h


fix:
let rec digitalRoot n = digitalRoot(sumList(digits(n)))

bad:
let rec digitalRoot n = digitalRoot(sumList(n))

annotated:
let rec digitalRoot : int -> int = fun  n  ->  digitalRoot(sumList(n))


fix:
let listReverse l = listReverse2 l []

bad:
let listReverse l = listReverse2 l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  listReverse2 l []


fix:
let listReverse l = listReverse2 l []

bad:
let rec listReverse2 l dest = 

annotated:
let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  


fix:
let listReverse l = listReverse2 l []

bad:
let rec listReverse2 l dest = 
match l with
| [] -> dest
| h::t -> listReverse2 t (h::dest)

annotated:
let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  
match l with
| [] -> dest
| h::t -> listReverse2 t (h::dest)


fix:
let _ = additivePersistence 9876

bad:
let additivePersistence n = additivePersistence2 n 0

annotated:
let additivePersistence : int -> int = fun  n  ->  additivePersistence2 n 0


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen' then seen' else h :: seen' in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen' then seen' else h :: seen' in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let fixpoint (f,b) = wwhile (f ,b)

bad:
let fixpoint (f,b) = wwhile (f b <> b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f b <> b,b)


fix:
let fixpoint (f,b) = wwhile (f b ,b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ( f, b)

bad:
let fixpoint (f,b) = wwhile (wwhile (f, b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (wwhile (f, b),b)


fix:
let fixpoint (f,b) = wwhile ( f, b)

bad:
let fixpoint (f,b) = wwhile (wwhile (f , b) , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (wwhile (f , b) , b)


fix:
let fixpoint (f,b) = wwhile ( f, b)

bad:
let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( if f b  ->  b then b else f b , b)


fix:
let fixpoint (f,b) = wwhile ( f, b)

bad:
let fixpoint (f,b) = wwhile ( fixpoint (f , b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( fixpoint (f , b), b)


fix:
let fixpoint (f,b) = wwhile ( f, b)

bad:
let fixpoint (f,b) = wwhile ( fixpoint , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( fixpoint , b)


fix:
let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')

bad:
let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( let b' = f b in if b'  ->  b then f b else f b', b)


fix:
let rec assoc (d,k,l) = 
match l with  
| [] -> d
| h::t -> 
let (p , q) = h in
if k = p then q
else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ( , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( , b)


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"^exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)^")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)")"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"^exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)^")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"^exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"^exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)")"


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) ./ 2) + (eval(e2, x ,y) ./ 2))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) ./ 2) + (eval(e2, x ,y) ./ 2))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

bad:
et rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

annotated:
et rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)


fix:
uildX()                       = VarX

bad:
let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

annotated:
let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))


fix:
let rec build (rand, depth) = 
if depth = 0 then 
match rand(0, 2) with
| 0 -> buildX()
| 1 -> buildY()
else
match rand(2, 7) with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))

bad:
let rec build (rand, depth) = 
let f = makeRand(rand) in
if depth = 0 then buildX()
else
match f with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let f = makeRand(rand) in
if depth = 0 then buildX()
else
match f with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))


fix:
let rec build (rand, depth) = 
if depth = 0 then 
match rand(0, 2) with
| 0 -> buildX()
| 1 -> buildY()
else
match rand(2, 7) with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
match rand(0, 2)
| 0 -> buildX()
| 1 -> buildY()
else
match rand(2, 7) with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
match rand(0, 2)
| 0 -> buildX()
| 1 -> buildY()
else
match rand(2, 7) with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))


fix:
let fixpoint (f,b) = wwhile (f, b)

bad:
let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let xx = f(b) in (xx, xx  ->  b) in wwhile (f, b)


fix:
let rec assoc (d,k,l) = 
match l with  
| [] -> d
| h::t -> 
let (p , q) = h in
if k = p then q
else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile ( wwhile(f, b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( wwhile(f, b), b)


fix:
let rec assoc (d,k,l) = 
match l with  
| [] -> d
| h::t -> 
let (p , q) = h in
if k = p then q
else assoc (d, k, t)

bad:
let fixpoint (f,b) = wwhile (if f b = b then b else f b , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if f b  ->  b then b else f b , b)


fix:
let fixpoint (f,b) = 
let (b', c') = f b in
if b = b' then b else wwhile (f , b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else wwhile (f , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = f b in
if b = b' then b else wwhile (f , b)


fix:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else wwhile (f , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = f b in
if b = b' then b else wwhile (f , b)


fix:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else f b in wwhile (f , b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = f b in
if b = b' then b else f b in wwhile (f , b)


fix:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else f b in wwhile (f b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let b' = f b in
if b = b' then b else f b in wwhile (f b, b)


fix:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)

bad:
let fixpoint (f,b) = 
let f b = b' in
if b = b' then b else f b in wwhile (f b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f b = b' in
if b = b' then b else f b in wwhile (f b, b)


fix:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)

bad:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = 
let f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let sqsum xs = 
let f a x = a + x in
let base =  0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) x in
let base = [] in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) x in
let base = [] in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + x in
let base =  0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (+) x in
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x a in
let base =  [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a' in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  a' in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = f g in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = f g in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun f in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = fun f in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = f base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = f base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let rec base = base in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (base) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (base) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let rec base = base in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (_) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (_) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let rec base = base in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a + x in
let base =  0 in
List.fold_left f base xs

bad:
let stringOfList f l = sepConcat("" List.map(f l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat("" List.map(f l))


fix:
let stringOfList f l = 
let x = List.map f l  in
sepConcat ";" x

bad:
let stringOfList f l = sepConcat"" List.map(f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat"" List.map(f l)


fix:
let stringOfList f l = 
let x = List.map f l  in
sepConcat ";" x

bad:
let stringOfList f l = sepConcat "" List.map(f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat "" List.map(f l)


fix:
let stringOfList f l = 
let x = List.map f l  in
sepConcat ";" x

bad:
let stringOfList f l = let x = List.map(f l) in
sepConcat ";" x

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l = let x  ->  List.map(f l) in
sepConcat ";" x


fix:
let stringOfList f l = 
let x = List.map f l  in
sepConcat ";" x

bad:
let stringOfList f l = sepConcat ";" List.map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat ";" List.map f l


fix:
let rec clone x n = 
if n <= 0 then []
else n :: (clone x (n-1))

bad:
let rec clone x n = 
if n <= 0 then []
else n :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else n :: clone x n-1


fix:
let rec clone x n = 
if n <= 0 then []
else n :: (clone x (n-1))

bad:
let rec clone x n = 
if n <= 0 then []
else n :: (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else n :: (clone x n-1)


fix:
let padZero l1 l2 = 
let x1 = List.length(l1) in
let x2 = List.length(l2) in
if x1 < x2 then l1 @ clone 0 (x2-x1)
else l2 @ clone 0 (x1-x2)

bad:
let padZero l1 l2 = 
let x1 = List.length(l1) in
let x2 = List.length(l2) in
if x1 < x2 then x1 @ clone 0 (x2-x1)
else x2 @ clone 0 (x1-x2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let x1 = List.length(l1) in
let x2 = List.length(l2) in
if x1 < x2 then x1 @ clone 0 (x2-x1)
else x2 @ clone 0 (x1-x2)


fix:
let sqsum xs = 
let f a x = a +. x**2.0 in
let base =  0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x**2 in
let base =  0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x**2 in
let base =  0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a +. x**2.0 in
let base =  0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x**2.0 in
let base =  0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x**2.0 in
let base =  0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a +. x**2.0 in
let base =  0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a +. x**2.0 in
let base =  0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a +. x**2.0 in
let base =  0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + int_of_float(float_of_int(x)**2.0) in
let base =  0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x**2 in
let base =  0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + x**2 in
let base =  0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a + int_of_float(float_of_int(x)**2.0) in
let base =  0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + (pow x 2) in
let base =  0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a + (pow x 2) in
let base =  0 in
List.fold_left f base xs


fix:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match x with
| h :: t -> a
(*
let (x1, x2) = h in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a *)
| [] -> a
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
match x with
| h :: t -> a
(*
let (x1, x2) = h in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a *)
| [] -> a
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x
(*
match x with
| h :: t -> a

let (x1, x2) = h in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
| [] -> a *)
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x
(*
match x with
| h :: t -> a

let (x1, x2) = h in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
| [] -> a *)
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = [(0 , 0)] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = [(0 , 0)] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones)
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones)
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a
in
let base = [(0 , 0)] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a
in
let base = [(0 , 0)] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match carry with
| h :: t -> 
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: carry, ones :: res)
| [] ->
let tens = x1 + x2 / 10 in
let ones = x1 + x2 mod 10 in
(tens :: carry, ones :: res)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match carry with
| h :: t -> 
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: carry, ones :: res)
| [] ->
let tens = x1 + x2 / 10 in
let ones = x1 + x2 mod 10 in
(carry :: a1, ones :: res)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match carry with
| h :: t -> 
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: carry, ones :: res)
| [] ->
let tens = x1 + x2 / 10 in
let ones = x1 + x2 mod 10 in
(carry :: a1, ones :: res)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
match x2 with
| h :: t ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: carry, ones :: res)
| [] ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: ones :: res)

in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
match x2 with
| h :: t ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: carry, ones :: res)
| [] ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: ones :: res)

in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
match x with
| h :: t ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: carry, ones :: res)
| [] ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: ones :: res)

in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
match x with
| h :: t ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: carry, ones :: res)
| [] ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: ones :: res)

in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h :: t -> 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
if t = [] then (0 ,tens :: ones :: res)
else (tens :: carry, ones :: res)
| [] -> a


in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h :: t -> 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
if t = [] then (0 ,tens :: ones :: res)
else (tens :: carry, ones :: res)
| [] -> a


in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens ,tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens ,tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens , tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens , tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens , tens :: ones :: res)
in
let base = ([0], [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens , tens :: ones :: res)
in
let base = ([0], [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
([tens] , tens :: ones :: res)
in
let base = ([0], [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
([tens] , tens :: ones :: res)
in
let base = ([0], [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let tens = (x1 + x2 + carry) / 10 in
let ones = (x1 + x2 + carry) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let tens = (x1 + x2 + carry) / 10 in
let ones = (x1 + x2 + carry) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if res <> [] then
let lastTens :: rest = res in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: rest)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: rest)

else 
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if res <> [] then
let lastTens :: rest = res in
else let rest = res in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: rest)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: rest)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if res <> [] then
let lastTens :: rest = res in
else let rest = res in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: rest)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: rest)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
if i <> 0 then mulByDigit (i-1) (bigAdd l l)
else l

bad:
let rec mulByDigit i l = 
if i <> 0 then mulByDigit (i-1) bigAdd l l
else l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i <> 0 then mulByDigit (i-1) bigAdd l l
else l


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match res with
| h :: t -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: t)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: t)
)
| [] -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)
)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match res with
| h :: t -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: t)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: t)
)
| [] -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
| [] ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match res with
| h :: t -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: t)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: t)
)
| [] -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
| [] ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = helper [0] i l

bad:
let rec mulByDigit i l = helper 0 i l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  helper 0 i l


fix:
let fixpoint (f,b) = 
let h x = (f x, if f x = x then false else true) in
wwhile (h ,b)

bad:
let fixpoint (f,b) = 
let h x = (f x, if f x = x then false else true)
wwhile (h ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let h x = (f x, if f x = x then false else true)
wwhile (h ,b)


fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = 
string x = e

annotated:
let rec exprToString : expr -> string = fun  e  ->  
string x = e


fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = 
String x = e

annotated:
let rec exprToString : expr -> string = fun  e  ->  
String x = e


fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX -> x
| VarY -> y
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d


fix:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)


fix:
let rec build (rand, depth) = 
if depth = 0 then 
let result = rand 0 1 in
if result = 0 then 
buildX() else
buildY()
else
let result = rand 0 6 in
match result with
|0 -> buildX()
|1 -> buildY()
|2 -> buildSine(build(rand,depth-1))
|3 -> buildCosine(build(rand,depth-1))
|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
|_ -> buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let result = rand 0 1 in
if result = 0 then 
buildX() else
buildY()
else
let result = rand 0 6 in
match result with
|0 -> buildX()
|1 -> buildY()
|2 -> buildSine(build(rand,depth-1))
|3 -> buildCosine(build(rand,depth-1))
|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
|_ -> build()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then 
let result = rand 0 1 in
if result = 0 then 
buildX() else
buildY()
else
let result = rand 0 6 in
match result with
|0 -> buildX()
|1 -> buildY()
|2 -> buildSine(build(rand,depth-1))
|3 -> buildCosine(build(rand,depth-1))
|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
|_ -> build()


fix:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
|Inverse a -> let result  = eval(a,x,y) in
if result = 0. then 0.
else
1. /. result
|Max (a,b) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
if aResult > bResult then aResult
else bResult
|Range (a,b,c) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
let cResult = eval(c,x,y) in
if aResult < bResult then bResult else
if aResult < cResult then cResult else
aResult

bad:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
|Inverse a -> let result  = eval(a,x,y) in
if result = 0. then 0.
else
1 /. result
|Max (a,b) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
if aResult > bResult then aResult
else bResult
|Range (a,b,c) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
let cResult = eval(c,x,y) in
if aResult < bResult then bResult else
if aResult < cResult then cResult else
aResult

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
|Inverse a -> let result  = eval(a,x,y) in
if result = 0. then 0.
else
1 /. result
|Max (a,b) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
if aResult > bResult then aResult
else bResult
|Range (a,b,c) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
let cResult = eval(c,x,y) in
if aResult < bResult then bResult else
if aResult < cResult then cResult else
aResult


fix:
let padZero l1 l2 = 
let num1 = List.length l2 - List.length l1 in
let num2 = List.length l1 - List.length l2 in
(clone 0 num1 @l1,clone 0 num2 @ l2)

bad:
let padZero l1 l2 = 
let num1 = List.length l2 - List.length l1 in
let num2 = List.length l1 - list.length l2 in
(clone 0 num1 @l1,clone 0 num2 @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let num1 = List.length l2 - List.length l1 in
let num2 = List.length l1 - list.length l2 in
(clone 0 num1 @l1,clone 0 num2 @ l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = a @ sum mod 10 in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = a @ sum mod 10 in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = a @ (sum mod 10) in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = a @ (sum mod 10) in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = (a @ (sum mod 10)) in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = (a @ (sum mod 10)) in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then x 
else (intlist (x / 10))::[x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum)::t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then x 
else (intlist (x / 10))::[x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum)::t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10))::[x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum)::t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10))::[x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum)::t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
result = (intlist sum) @ t in
if sum < 10 then 0::result else result

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
result = (intlist sum) @ t) in
if sum < 10 then 0::result else result in 

let base = [0] in
let args = List.rev (List.combine l1 l2) in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
result = (intlist sum) @ t) in
if sum < 10 then 0::result else result in 

let base = [0] in
let args = List.rev (List.combine l1 l2) in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> let (_,zeroList') = padZero(t',[]) in zeroList') in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)

bad:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> (match t with 
|[] -> let zeroList = []
|h'::t' -> let (_,zeroList) = padZero(t',[])) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  -> 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> (match t with 
|[] -> let zeroList = []
|h'::t' -> let (_,zeroList) = padZero(t',[])) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)


fix:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> (match padZero(t' [0]) with 
|(a,b) -> b)) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)

bad:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> (match padZero((t',[0])) with 
|(a,b) -> b)) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  -> 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> (match padZero((t',[0])) with 
|(a,b) -> b)) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)


fix:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper n::[n mod 10] 
| false -> []

bad:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper::[n mod 10] 
| false -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| true  -> digOfIntHelper::[n mod 10] 
| false -> []


fix:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper n::[n mod 10] 
| false -> []

bad:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper::[n % 10] 
| false -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| true  -> digOfIntHelper::[n % 10] 
| false -> []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec digitsOfInt n = 
match n with
| 0    -> []
| [0]   -> []
| 1     -> []
| true  -> digOfIntHelper n::[]::[n mod 10] 
| false -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n with
| 0    -> []
| [0]   -> []
| 1     -> []
| true  -> digOfIntHelper n::[]::[n mod 10] 
| false -> []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper n::[]::[n mod 10] 
| false -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| true  -> digOfIntHelper n::[]::[n mod 10] 
| false -> []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt n
| true  -> digitsOfInt n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt n
| true  -> digitsOfInt n mod 10


fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> (n / 10) :: digitsOfInt (n mod 10)

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)


fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> n / 10 :: digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> digitsOfInt (n / 10) ::  (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> digitsOfInt (n / 10) ::  (n mod 10)


fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1 :: 1

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1


fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1 :: 2

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1 :: 2


fix:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t (h::revd )
in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t (h::revd )
in
reverseHelper [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse[] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse[] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse l []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse [] l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper l


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
in

listReverse l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
in

listReverse l []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse l []


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse [] l


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
reverseHelper [] l

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
reverseHelper [] l


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let rec reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
in
listReverse l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
in
listReverse l []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
in
listReverse l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
in
listReverse l []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r ) 
in
listReverse l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r ) 
in
listReverse l []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r ) 
in
listReverse [] []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r ) 
in
listReverse [] []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
listReverse [] []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
listReverse [] []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper l []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper l []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
r

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
r


fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in


let _ = listReverse [1; 2; 3; 4]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in


let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l =
let rec reverseHelper l r = 
match l with
| []    -> l
| h::t  -> reverseHelper t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> reverseHelper t ( h::r ) 
in
reverseHelper []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> reverseHelper t ( h::r ) 
in
reverseHelper []


fix:
let rec digOfInt = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
let digOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n

annotated:
let rec digitsOfInt n = 
let digOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n


fix:
let rec digOfInt = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n r

annotated:
let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n r


fix:
let rec digOfInt = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n r

annotated:
let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n r


fix:
let rec digOfInt = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n

annotated:
let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n


fix:
let rec digOfInt = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
let digOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n

annotated:
let rec digitsOfInt n = 
let digOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n


fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

bad:
let digitsOfInt n =  
let rec digOfIntHelper n l = 
if n > 0 
then (
match n > 9 with
| false -> n :: l
| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))
else ( 
[] )
in
digOfIntHelper n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->   
let rec digOfIntHelper n l = 
if n > 0 
then (
match n > 9 with
| false -> n :: l
| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))
else ( 
[] )
in
digOfIntHelper n []


fix:
let rec palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )

bad:
let palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )

annotated:
let palindrome : string -> bool = fun  w  ->  
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )


fix:
let rec palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )

bad:
let rec palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )

annotated:
let rec palindrome : string -> bool = fun  w  ->  
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )


fix:
let rec palind w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palind t )
else (
false ) )

bad:
let palindrome w = palind (explode w)

annotated:
let palindrome : string -> bool = fun  w  ->  palind (explode w)


fix:
let rec palind w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palind t )
else (
false ) )

bad:
let rec palind w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palind t )
else (
false ) )

annotated:
let rec palind w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palind t )
else (
false ) )


fix:
let listReverse l = lReverse (l, [])

bad:
let listReverse l =
let rec reverseHelper l rl = 
match l with
| []    -> rl
| h::t  -> reverseHelper t ( h::rl ) 
in
reverseHelper l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  -> 
let rec reverseHelper l rl = 
match l with
| []    -> rl
| h::t  -> reverseHelper t ( h::rl ) 
in
reverseHelper l []


fix:
let rec assoc (d,k,l) = match l with
| []        -> d
| (n,v)::t  -> if k = n 
then v
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match (d,k,l with
| []        -> d
| (n,v)::t  -> if k = n 
then v
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match (d,k,l with
| []        -> d
| (n,v)::t  -> if k = n 
then v
else assoc (d,k,t)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let (b', c) =  (f(b), f(b)<>b)
in
wwhile ((b', c) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let (b', c)  ->   (f(b), f(b)<>b)
in
wwhile ((b', c) ,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (f ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f ,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ( (b, b<>f(b)) ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( (b, b<>f(b)) ,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let b'  ->  f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let b'  ->  f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let b'  ->  f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let f b = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile (f ,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let f b = let b'  ->  f(b) 
in
(b', f(b)<>b)
in
wwhile (f ,b)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = 
VarX		      -> "x"
| VarY			-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
VarX		      -> "x"
| VarY			-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = 
VarX _ 		      -> "x"
| VarY _		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)

annotated:
let rec exprToString : expr -> string = fun  e  ->  
VarX _ 		      -> "x"
| VarY _		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)


fix:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x)		-> sin (eval (pi *. x) )
| Cosine(x)		-> cos (pi *. (eval x) )
| Average(x1,x2)	-> ( (eval x1) +. (eval x2) ) /. 2.

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x)		-> sin (eval (pi *. x) )
| Cosine(x)		-> cos (pi *. (eval x) )
| Average(x1,x2)	-> ( (eval x1) +. (eval x2) ) /. 2.


fix:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.

bad:
) 


annotated:
) 



fix:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y ) ) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y ) ) )
| Average(x1,x2)	-> ( (eval x1) +. (eval x2) ) /. 2.

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y ) ) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y ) ) )
| Average(x1,x2)	-> ( (eval x1) +. (eval x2) ) /. 2.


fix:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.

bad:
) 


annotated:
) 



fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"

annotated:
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y ))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y ))


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) ? (eval (x3,x,y )) : (eval (x4,x,y ))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) ? (eval (x3,x,y )) : (eval (x4,x,y ))


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> ((eval (x1,x,y )) < (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y )))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> ((eval (x1,x,y )) < (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y )))


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) <. (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y ))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) <. (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y ))


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : (eval (x4,x,y ))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : (eval (x4,x,y ))


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : eval (x4,x,y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : eval (x4,x,y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : eval (x4,x,y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : eval (x4,x,y )


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> if (eval (x1,x,y )) < (eval (x2,x,y )) 
then eval (x3,x,y ) 
else eval (x4,x,y )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> if (eval (x1,x,y )) < (eval (x2,x,y )) 
then eval (x3,x,y ) 
else eval (x4,x,y )


fix:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 5 ) with
| 1 -> buildSine(build(rand,depth-1))
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 4 ) with
| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCos(build(rand,depth-1))
| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 4 ) with
| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCos(build(rand,depth-1))
| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
)


fix:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 5 ) with
| 1 -> buildSine(build(rand,depth-1))
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 4 ) with
| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 4 ) with
| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
)


fix:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY() 
)
| _   -> ( match (rand (1,5) ) with
| 1 -> buildSine(build (rand,depth-1) )
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| _ -> buildY() 
)
| _   -> ( match (rand 1 5 ) with
| 1 -> buildSine(build (rand,depth-1) )
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| _ -> buildY() 
)
| _   -> ( match (rand 1 5 ) with
| 1 -> buildSine(build (rand,depth-1) )
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)


fix:
let rec exprToString e = match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
| CosE(x1,x2,x3)	-> "cos(pi*" ^ (exprToString x1) ^ "*" ^ (exprToString x2) ^ ")e^(-pi*" 
^ (exprToString x3) ^ "^2)"

bad:
let rec exprToString e = match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
| CosE(x1,x2,x3)	-> "cos(pi*" ^ (exprToString x1) ^ "*" ^ (exprToString x1) ^ ")e^(-pi*" 
^ (exprToString x1) ^ "^2)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
| CosE(x1,x2,x3)	-> "cos(pi*" ^ (exprToString x1) ^ "*" ^ (exprToString x1) ^ ")e^(-pi*" 
^ (exprToString x1) ^ "^2)"


fix:
let rec build (rand, depth) = match depth with
| 0 -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY()
)
| _ -> ( match (rand (5,8) ) with
| 1 -> buildSine( build (rand, depth-1) )
| 2 -> buildCosine(  build (rand, depth-1) )
| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )
| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )
| 5 -> buildSine( build (rand, depth-1) )
| 6 -> buildCosine(  build (rand, depth-1) )
| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )
)

bad:
let rec build (rand, depth) = match depth with
| 0 -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY()
)
| _ -> ( match (rand (5,8) ) with
| 1 -> buildSine( build (rand, depth-1) )
| 2 -> buildCosine(  build (rand, depth-1) )
| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )
| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )
| 5 -> buildSine( build (rand, depth-1) )
| 6 -> buildCosine(  build (rand, depth-1) )
| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )
)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with
| 0 -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY()
)
| _ -> ( match (rand (5,8) ) with
| 1 -> buildSine( build (rand, depth-1) )
| 2 -> buildCosine(  build (rand, depth-1) )
| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )
| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )
| 5 -> buildSine( build (rand, depth-1) )
| 6 -> buildCosine(  build (rand, depth-1) )
| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )
)


fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a * a + in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a * a + in
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = + in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = + in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = _ in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (_) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = (_) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a) in
let base = () in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x (a) in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a) in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a) in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = f in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a) in
let base = f in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x (a) in
let base = f in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x (a) in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a) in
let base = + in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x (a) in
let base = + in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a ) in
let base = fun x->x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a) in
let base = 0(+) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x (a) in
let base = 0(+) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a ) in
let base = fun x->x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a) in
let base = 0(+) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x (a) in
let base = 0(+) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a ) in
let base = fun x->x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a p) in
let base = p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x (a p) in
let base = p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x (a ) in
let base = fun x->x in
List.fold_left f base fs

bad:
let pipe fs p = 
let f a x = x (a p) in
let base = p in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs p  ->  
let f a x = x (a p) in
let base = p in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun p -> x (a p) in
let base = fun x->x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun p -> x (a p) in
let base = fun x->x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sepConcat sep t  in
let base = h in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep  in
let base = h in
let l =  sepConcat sep t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep  in
let base = h in
let l =  sepConcat sep t in
List.fold_left f base l


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l) ) ^ "]"

bad:
let stringOfList f l = "[" ^ sepConcat "; " List.map f l ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ sepConcat "; " List.map f l ^ "]"


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l) ) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat "; " List.map f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sepConcat "; " List.map f l) ^ "]"


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x n-1


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x n-1
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x n-1
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x (n-1)
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x (n-1)
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: helper n-1
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let helper = 
match n with
| 0 -> []
| _ -> x :: helper n-1
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let rec helper = 
match n with
| 0 -> []
| _ -> x :: helper n-1
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper = 
match n with
| 0 -> []
| _ -> x :: helper n-1
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let rec helper = 
match n with
| 0 -> []
| _ -> x :: (helper n-1)
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper = 
match n with
| 0 -> []
| _ -> x :: (helper n-1)
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let rec helper = 
match n with
| 0 -> []
| _ -> helper n-1
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper = 
match n with
| 0 -> []
| _ -> helper n-1
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let rec helper n = 
match n with
| 0 -> []
| _ -> helper n-1
in 
helper n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper n = 
match n with
| 0 -> []
| _ -> helper n-1
in 
helper n


fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
match n with 
| 0 -> []
| _ -> x :: (clone x n-1)


fix:
let rec sumList xs = match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec sumList xs = match sumList with
| h::t -> h + sumList t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match sumList with
| h::t -> h + sumList t


fix:
let rec sumList xs = match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec sumList xs = match sumList with
[] -> 0 
| h::t -> h + sumList t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match sumList with
[] -> 0 
| h::t -> h + sumList t


fix:
let rec sumList xs = match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec sumList xs = match sumList with
[] -> 0 
| h::t -> h + sumList t

annotated:
let rec sumList : int list -> int = fun  xs  ->  match sumList with
[] -> 0 
| h::t -> h + sumList t


fix:
let _ = digitsOfInt (-2)

bad:
let _ = digitsOfInt -2

annotated:
let _ = digitsOfInt -2


fix:
let rec digitsOfInt n =
if n < 0 then []
else
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let rec digitsOfInt n = 
if n < 0 then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []


fix:
let rec digitsOfInt n =
if n < 0 then []
else
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let rec digitsOfInt n = 
if n < 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 -> []


fix:
let rec digitsOfInt n =
if n < 0 then []
else
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let rec digitsOfInt n = 
if n < 0 then -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then -> []


fix:
let rec digitsOfInt n =
if n < 0 then []
else
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let rec digitsOfInt n = 
when n < 0 -> []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
when n < 0 -> []


fix:
let rec digitsOfInt n =
if n < 0 then []
else
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let rec digitsOfInt n =
if n < 0 then []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n < 0 then []


fix:
let additivePersistence n = 
digits n

bad:
let additivePersistence n = 
let digits n = x in
sumList x

annotated:
let additivePersistence : int -> int = fun  n  ->  
let digits n = x in
sumList x


fix:
let additivePersistence n = 
digits n

bad:
let additivePersistence n = 
digits n
sumList n

annotated:
let additivePersistence : int -> int = fun  n  ->  
digits n
sumList n


fix:
let additivePersistence n = 
sumList (digits n)

bad:
let additivePersistence n = 
digits n = n

annotated:
let additivePersistence : int -> int = fun  n  ->  
digits n = n


fix:
let rec digitalRoot n = 
if sumList (digits n) > 9
then digitalRoot (sumList (digits n))
else sumList (digits n)

bad:
let digitalRoot n = 
let x = sumList (digits n) in
if x > 9
then digitalRoot x
else sumList x

annotated:
let digitalRoot : int -> int = fun  n  ->  
let x = sumList (digits n) in
if x > 9
then digitalRoot x
else sumList x


fix:
let rec digitalRoot n = 
if sumList (digits n) > 9
then digitalRoot (sumList (digits n))
else sumList (digits n)

bad:
let rec digitalRoot n = 
let x = sumList (digits n) in
if x > 9
then digitalRoot x
else sumList x

annotated:
let rec digitalRoot : int -> int = fun  n  ->  
let x = sumList (digits n) in
if x > 9
then digitalRoot x
else sumList x


fix:
let listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

bad:
let listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] list

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] list


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = function
digitalRoot n

annotated:
let additivePersistence n = 
let rec helper n count = function
digitalRoot n


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
digitalRoot n

annotated:
let additivePersistence n = 
let rec helper n count = 
digitalRoot n


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)

annotated:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0

annotated:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0

annotated:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0

annotated:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0

annotated:
let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = 
digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0

annotated:
let additivePersistence n = 
let rec helper n count = 
digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0


fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = function
digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0

annotated:
let additivePersistence n = 
let rec helper n count = function
digitalRoot : int -> int = fun  n  -> 
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0


fix:
let listReverse l = 
let rec helper xs = function
| [] -> []
| hd::tl -> helper (hd::xs) tl
in helper [] l

bad:
let listReverse l = 
let rec helper xs = match xs with
| [] -> []
| hd::tl -> helper (hd::xs) tl
in helper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs = match xs with
| [] -> []
| hd::tl -> helper (hd::xs) tl
in helper [] l


fix:
let listReverse l = 
let rec helper xs = function
| [] -> xs
| hd::tl -> helper (hd::xs) tl
in helper [] l

bad:
let listReverse l = 
let rec helper xs = function
| [] -> xs
| hd::tl -> helper (hd::xs) 
in helper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs = function
| [] -> xs
| hd::tl -> helper (hd::xs) 
in helper [] l


fix:
let listReverse l = 
let rec helper xs l  = match l with
| [] -> []
| hd::tl -> helper (hd::xs) l
in helper [] l

bad:
let listReverse l = 
let rec helper xs n  = function
| [] -> xs
| hd::tl -> helper (hd::xs) tl
in helper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs n  = function
| [] -> xs
| hd::tl -> helper (hd::xs) tl
in helper [] l


fix:
let listReverse l = 
let rec helper xs l  = match l with
| [] -> []
| hd::tl -> helper (hd::xs) l
in helper [] l

bad:
let listReverse l = 
let rec helper xs l  = match n with
| [] -> []
| hd::tl -> helper (hd::xs) l
in helper [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec helper xs l  = match n with
| [] -> []
| hd::tl -> helper (hd::xs) l
in helper [] l


fix:
let rec reverse res list = match list with
| [] -> []
| hd::tl -> reverse (hd::res) list

bad:
let rec reverse res list = match list with
| [] -> []
| hd:tl -> reverse (hd::res) list

annotated:
let rec reverse res list = match list with
| [] -> []
| hd:tl -> reverse (hd::res) list


fix:
let rec reverse res list = match list with
| [] -> []
| hd::tl -> reverse (hd::res) list

bad:
let listReverse l = reverse [] list

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  reverse [] list


fix:
let rec helper xs list  = match list with
| [] -> []
| hd::tl -> helper (hd::xs) 
in helper [] l

bad:
let listReverse l = reverse [] l

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  reverse [] l


fix:
let rec mylength xs = match xs with
| [] -> 0
| hd::tl -> 1 + mylength tl

bad:
let digitsOfInt n =
let rec digits n x list =
if n < 10 then n :: list
else digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list
in digits n (mylength n) []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits n x list =
if n < 10 then n :: list
else digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list
in digits n (mylength n) []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(10** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(10** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(int_of_float 10 ** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(int_of_float 10 ** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(float_of_int 10 ** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(float_of_int 10 ** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: 1
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: 1
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: 1
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: 1
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: l
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: l
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: 
(digits (x/10) l)
else numdig :: l
in digits n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: 
(digits (x/10) l)
else numdig :: l
in digits n []


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else
(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else
(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]


fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]


fix:
let _ = digitsOfInt 122

bad:
let digitsOfInt n =
if n < 10 then n :: []
else (digitsOfInt (n/10))
match n with
| hd::tl -> hd
:: [n mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else (digitsOfInt (n/10))
match n with
| hd::tl -> hd
:: [n mod 10]


fix:
let _ = digitsOfInt 122

bad:
let digitsOfInt n =
if n < 10 then n :: []
else match n with
| hd::tl -> hd
(digitsOfInt (n/10)) :: [n mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else match n with
| hd::tl -> hd
(digitsOfInt (n/10)) :: [n mod 10]


fix:
let _ = digitsOfInt 122

bad:
let digitsOfInt n =
if n < 10 then n :: []
else match n with
| (digitsOfInt (n/10)) :: [n mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else match n with
| (digitsOfInt (n/10)) :: [n mod 10]


fix:
let _ = digitsOfInt 122

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) :: [n mod 10]

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
if n < 10 then n :: []
else
(digitsOfInt (n/10)) :: [n mod 10]


fix:
let _ = digitsOfInt 122

bad:
let digitsOfInt n =
let rec recurse x l =
if x < 10 then x :: l
else
recurse (x/10) [n mod 10]
in recurse n []

annotated:
let digitsOfInt : int -> int list = fun  n  -> 
let rec recurse x l =
if x < 10 then x :: l
else
recurse (x/10) [n mod 10]
in recurse n []


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec recurse x xs = match x with
| [] -> []
| hd::tl -> recurse tl (hd::xs)
in recurse l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec recurse x xs = match x with
| [] -> []
| hd::tl -> recurse tl (hd::xs)
in recurse l []


fix:
let _ = removeDuplicates [1]

bad:
let _ = removeDuplicates [1];

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
let _ = removeDuplicates [1];

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen)
then (h :: seen)
else seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen)
then seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen)
then seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let buildX()                       = VarX

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
| None -> 0

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
| None -> 0


fix:
let buildX()                       = VarX

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString buildY
| VarX -> exprToString buildX

annotated:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString buildY
| VarX -> exprToString buildX


fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d ^ ")"
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Average (a,b) -> "((" ^ exprToString a ^ "+" ^ exprToString b ^ ")/20"
| Cosine (a) -> "cos(pi*" ^ exprToString a ^ ")"
| Sine (a) -> "sin(pi*" ^ exprToString a ^ ")"
| VarY -> "x"
| VarX -> "y"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d ^ ")"
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Average (a,b) -> "((" ^ exprToString a ^ "+" ^ exprToString b ^ ")/20"
| Cosine (a) -> "cos(pi*" ^ exprToString a ^ ")"
| Sine (a) -> "sin(pi*" ^ exprToString a ^ ")"
| VarY -> "x"
| VarX -> "y"


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> x
| VarX -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> x
| VarX -> y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> x
| VarX -> y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> x
| VarX -> y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> float_of_int x
| VarX -> float_of_int y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> float_of_int x
| VarX -> float_of_int y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos( pi * pi)
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos( pi * pi)
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos( pi )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos( pi )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi * (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi * (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi ** (eval (a,x,y)))
| Sine (a) -> sin (pi ** eval (a,x,y) )
| VarY ->  x
| VarX ->  y

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi ** (eval (a,x,y)))
| Sine (a) -> sin (pi ** eval (a,x,y) )
| VarY ->  x
| VarX ->  y


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.0)

bad:
let _ = eval (Sine(0.0))

annotated:
let _ = eval (Sine(0.0))


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.0)

bad:
let _ = eval (Sine(VarX ** VarY), 0.0, 0.0)

annotated:
let _ = eval (Sine(VarX ** VarY), 0.0, 0.0)


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.0)

bad:
let _ = eval (Average(VarX,VarY)), 0.0, 0.0

annotated:
let _ = eval (Average(VarX,VarY)), 0.0, 0.0


fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.0)

bad:
let _ = eval (Average(VarX,VarY), 0.0, 0.0)

annotated:
let _ = eval (Average(VarX,VarY), 0.0, 0.0)


fix:
let _ = eval (Times(VarX,VarY), 3.0, 2.0)

bad:
let _ = eval (Times(VarX,VarY), 1.0, 2.0)

annotated:
let _ = eval (Times(VarX,VarY), 1.0, 2.0)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) = 
let f b -> (b',c')
if f b = (b',c')
then wwhile(f,b)
else wwhile(f,b)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let f b -> (b',c')
if f b = (b',c')
then wwhile(f,b)
else wwhile(f,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) = 
let x = f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let x = f b


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) = 
let (b',c') = f b in

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let (b',c') = f b in


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) = 
let (b',c') = f b in
if c'
then wwhile (f, b')
else b'

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let (b',c') = f b in
if c'
then wwhile (f, b')
else b'


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(0,1) in match x with
| 0 -> buildX()
| 1 -> buildY()
else
let x = rand(5,10) in match x with
| 5 -> buildSine( build (rand, depth - 1) )
| 6 -> buildCosine( build (rand, depth - 1) )
| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(0,1) in match x with
| 0 -> buildX()
| 1 -> buildY()
else
let x = rand(5,10) in match x with
| 5 -> buildSine( build (rand, depth - 1) )
| 6 -> buildCosine( build (rand, depth - 1) )
| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,3) in match x with
| 1 -> buildX()
| 2 -> buildY()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,3) in match x with
| 1 -> buildX()
| 2 -> buildY()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,3) in match x with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,3) in match x with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 2 | 3 -> buildY()
| 1 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 2 | 3 -> buildY()
| 1 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 .. 5 -> buildY()
| 6 .. 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in match x with
| 1 .. 5 -> buildY()
| 6 .. 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let g1 () = failwith "to be implemented"

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in 
if x < 5 then buildY()
else buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in 
if x < 5 then buildY()
else buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

bad:
let _ = 
let g = makeRand (19,25) in
let e1 = build (g, 3) in Format.printf "red   = %s \n" (exprToString e1)

annotated:
let _ = 
let g = makeRand (19,25) in
let e1 = build: ((int * int -> int) * int) -> expr = fun  (g, 3) in Format.printf "red    ->  %s \n" (exprToString e1)


fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in 
if x < 5 then buildY()
else buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0
then let x = rand(1,10) in 
if x < 5 then buildY()
else buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
let rec helper (a,b,c) = match c with
| [] -> a
| (n,v)::t -> 
if n = b then v
else helper (a,b,t)
in helper (d,k,l)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper (a,b,c) = match c with
| [] -> a
| (n,v)::t -> 
if n = b then v
else helper (a,b,t)
in helper (d,k,l)


fix:
let _ = assoc (0, "hi", [("hi",3)])

bad:
let _ = assoc (0, "hi", [])

annotated:
let _ = assoc (0, "hi", [])


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (n,v)::t -> 
if n = k then v
else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| [] -> d
| (n,v)::t -> 
if n = k then v
else assoc (d,k,t)


fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = [] in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a*a + x in
let base = [] in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2 + x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a**2 + x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a^2 + x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a^2 + x in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a^^2 + x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = a^^2 + x in
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = match x with
| x::xs' -> x a
in
let base = (fun _ x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match x with
| [] -> (fun b -> b)
in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = match x with
| [] -> (fun b -> b)
in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = match x with
| x::xs' -> ( fun z d -> x d)
in
let base = (fun _ y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (fun b a -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (fun y -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = (fun y -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun b c -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun b c -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> a x) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = ( fun c -> x ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun y -> y) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun y -> y) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = ( fun c -> x ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun c -> y ) in
let base = (fun b -> b) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = ( fun c -> y ) in
let base = (fun b -> b) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = ( fun c -> x ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let (o) f g = fun x -> f (g x)

annotated:
let (o) f g = fun x -> f (g x)


fix:
let pipe fs = 
let f a x = ( fun c -> x ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let foo   = (fun x -> x + 1) o (fun y -> 2 * y)

annotated:
let foo   = (fun x -> x + 1) o (fun y -> 2 * y)


fix:
let pipe fs = 
let f a x = ( fun c -> x ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let ans  = foo 10

annotated:
let ans  = foo 10


fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun c -> f a x ) in
let base = (fun b -> b) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = ( fun c -> f a x ) in
let base = (fun b -> b) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun c -> f (a x) ) in
let base = (fun b -> b) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = ( fun c -> f (a x) ) in
let base = (fun b -> b) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun c -> fun d -> (a x) ) in
let base = (fun b -> b) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = ( fun c -> fun d -> (a x) ) in
let base = (fun b -> b) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun x -> f (g x) ) in
let base = (fun b -> b) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = ( fun x -> f (g x) ) in
let base = (fun b -> b) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun y -> a (y x) ) in
let base = (fun b -> b) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = ( fun y -> a (y x) ) in
let base = (fun b -> b) in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ cc) in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ cc) in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = h in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = h in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" ^ h ^ "" in
let l = t in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]

annotated:
let _ = sepConcat ", " ["foo";"bar";"baz"]


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
List.map f (sepConcat ";") l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  
List.map f (sepConcat ";") l


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) @ [x]

bad:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) :: [h]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| _ -> clone x (n-1) :: [h]


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) @ [x]

bad:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) :: [x]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| _ -> clone x (n-1) :: [x]


fix:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) @ [x]

bad:
let rec clone x n = match n with
| 0 -> []
| 1 -> clone x (n-1) :: [x]

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
| 0 -> []
| 1 -> clone x (n-1) :: [x]


fix:
let rec removeZero l = match l with
| [] -> l
| h::t ->
if h = 0 
then removeZero t
else l

bad:
let rec removeZero l = match l with
| [] -> l
| h::t -> if h = 0 then removeZero t

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| [] -> l
| h::t -> if h = 0 then removeZero t


fix:
let rec removeZero l = match l with
| [] -> l
| h::t ->
if h = 0 
then removeZero t
else l

bad:
let rec removeZero l = match l with
| [] -> []
| h::t -> if h = 0 then removeZero t

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
| [] -> []
| h::t -> if h = 0 then removeZero t


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let a = h::t in 
match x with
| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let a = h::t in 
match x with
| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t -> a * x
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t -> a * x
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x,y) -> a * x
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x,y) -> a * x
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> 9
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> 9
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1 -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h1 -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| h -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| h -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h1) -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1,h1) -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> (h2,h1)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> (h2,h1)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> [h2]
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> [h2]
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> [h2]
in
let base =  [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> [h2]
in
let base =  [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,[g])-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,[g])-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newcarry, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newcarry, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
| []   -> carry
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
| []   -> carry
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g) -> f
| (f',g'::h)-> g'
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g) ->
| (f',g'::h)-> g
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g) ->
| (f',g'::h)-> g
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = 
if i = 0 then l
else
let a = i :: [] in
bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)

bad:
let rec mulByDigit i l = 
if i = 0 then l
else
let a = i :: [] in
bigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i = 0 then l
else
let a = i :: [] in
bigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd y x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = match x with in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = failwith "to be implemented" in
let base = [] in
let args = match x with in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd y x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = match l2 with
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = failwith "to be implemented" in
let base = [] in
let args = match l2 with
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd y x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = bigAdd a x in
let base = [] in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = bigAdd a x in
let base = [] in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd y x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd a x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (_,y) -> (0, bigAdd a x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res


fix:
let unzeroed = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h a) :: acc) a t
in
constructargs [] [1;2;3] (List.rev [4;5;6])
in 
let rec addZeroes num somelist = match num with
| 0 -> somelist 
| _ -> addZeroes (num-1) (List.append somelist [0])
in
let rec addZeroesWhole acc a = match a with
| [] -> acc
| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t
in
addZeroesWhole [] unzeroed

bad:
let unzeroed = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h a) :: acc) a t
in
constructargs [] [1;2;3] (List.rev [4;5;6])
in 
let rec addZeroes num somelist = match num with
| 0 -> somelist 
| _ -> addZeroes (num-1) (List.append somelist 0)
in
let rec addZeroesWhole acc a = match a with
| [] -> acc
| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t
in
addZeroesWhole [] unzeroed

annotated:
let unzeroed = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h a) :: acc) a t
in
constructargs [] [1;2;3] (List.rev [4;5;6])
in 
let rec addZeroes num somelist = match num with
| 0 -> somelist 
| _ -> addZeroes (num-1) (List.append somelist 0)
in
let rec addZeroesWhole acc a = match a with
| [] -> acc
| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t
in
addZeroesWhole [] unzeroed


fix:
let rec mulByDigit i l = 
if i <= 0 then [0] else
if i = 1 then l
else
bigAdd (mulByDigit (i-1) l)  l

bad:
let rec mulByDigit i l = 
if i <= 0 then 0 else
if i = 1 then l
else
bigAdd (mulByDigit (i-1) l)  l

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i <= 0 then 0 else
if i = 1 then l
else
bigAdd (mulByDigit (i-1) l)  l


fix:
let rec digitsOfInt n = 
if n < 0 then []
else let x = n/10 and y = n mod 10
in digitsOfInt x @ y

bad:
let rec digitsOfInt n = 
let x = n/10 
and y = n mod 10
and if y = 0 && x = 0 then []::resultList
else y::resultList -> digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let x = n/10 
and y = n mod 10
and if y = 0 && x = 0 then []::resultList
else y::resultList -> digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else let x = n/10 and y = n mod 10
in digitsOfInt x @ y

bad:
let rec digitsOfInt n = 
let x = n/10 
and y = n mod 10 in
if y = 0 && x = 0 then []::resultList
else y::resultList -> digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let x = n/10 
and y = n mod 10 in
if y = 0 && x = 0 then []::resultList
else y::resultList -> digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else let x = n/10 and y = n mod 10
in digitsOfInt x @ y

bad:
let rec digitsOfInt n = 
let x = n/10 
and y = n mod 10 in
if y = 0 && x = 0 then []::resultList
else y::resultList -> y :: digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let x = n/10 
and y = n mod 10 in
if y = 0 && x = 0 then []::resultList
else y::resultList -> y :: digitsOfInt x


fix:
let _ = digitsOfInt (-300)

bad:
let _ = digitsOfInt (digits -300)

annotated:
let _ = digitsOfInt (digits -300)


fix:
let _ = digitsOfInt (-300)

bad:
let _ = digitsOfInt (digits (-300))

annotated:
let _ = digitsOfInt (digits (-300))


fix:
let x = sumList (digitsOfInt 10)

bad:
let x = sumList digitsOfInt 10

annotated:
let x = sumList digitsOfInt 10


fix:
let x = sumList (digitsOfInt 10)

bad:
let x = sumList digitsOfInt 10

annotated:
let x = sumList digitsOfInt 10


fix:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'

bad:
let rec listReverse l = 
| [] -> 0
| x :: l' -> listReverse l' @ [x]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
| [] -> 0
| x :: l' -> listReverse l' @ [x]


fix:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l' @ [x]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: l' -> listReverse l' @ [x]


fix:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse [l'] @ [x]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: l' -> listReverse [l'] @ [x]


fix:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse [l'] @ [x]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: l' -> listReverse [l'] @ [x]


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'::x

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: l' -> listReverse l'::x


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'::[x]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: l' -> listReverse l'::[x]


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> 

(* uncomment and run AFTER you have implemented listReverse

let _ = listReverse [1; 2; 3; 4]
let _ = listReverse ["a"; "b"; "c"; "d"]

*)

(* explode : string -> char list 
* (explode s) is the list of characters in the string s in the order in 
*   which they appear
* e.g.  (explode "Hello") is ['H';'e';'l';'l';'o']
*)
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: l' -> 

(* uncomment and run AFTER you have implemented listReverse

let _ = listReverse [1; 2; 3; 4]
let _ = listReverse ["a"; "b"; "c"; "d"]

*)

(* explode : string -> char list 
* (explode s) is the list of characters in the string s in the order in 
*   which they appear
* e.g.  (explode "Hello") is ['H';'e';'l';'l';'o']
*)
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: xl -> listReverse x :: []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: xl -> listReverse x :: []


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: xl -> listReverse xl :: []

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| x :: xl -> listReverse xl :: []


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| head::tail -> tail

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| head::tail -> tail


fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| head :: tail -> tail

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> 0
| head :: tail -> tail


fix:
let palindrome w = 
(listReverse (explode w))

bad:
let palindrome w = 
if listReverse explode w = w then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if listReverse explode w = w then true
else false


fix:
let palindrome w = 
(listReverse (explode w))

bad:
let palindrome w = 
if (listReverse (explode w)) = w then true
else false

annotated:
let palindrome : string -> bool = fun  w  ->  
if (listReverse (explode w)) = w then true
else false


fix:
let palindrome w = 
if (listReverse (explode w)) = explode w then true
else false

bad:
let palindrome w = 
if (listReverse (explode w)) = w then 1
else 0

annotated:
let palindrome : string -> bool = fun  w  ->  
if (listReverse (explode w)) = w then 1
else 0


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::[tail]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s -> s::t::tail::head

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s -> s::t::tail::head


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::[tail]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s -> s::t::tail::head

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s -> s::t::tail::head


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::[tail]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s = l -> s::t::tail::head

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s = l -> s::t::tail::head


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::[tail]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s::l -> s::t::tail::head

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s::l -> s::t::tail::head


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::[tail]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::tail

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::tail


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third::fourth::fifth -> fourth::third::tail::[head]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third::fourth -> fourth::third::tail::[head]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail::third::fourth -> fourth::third::tail::[head]


fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail -> head::listReverse tail

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail -> head::listReverse tail::tail

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
| [] -> []
| [x] -> [x]
| head::tail -> head::listReverse tail::tail


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let m = n


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = reverseInt n
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let m = reverseInt n
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = reverseInt n
in let x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let m = reverseInt n
in let x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n/10 
and y = reverseInt n mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = reverseInt n/10 
and y = reverseInt n mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = int_of_string reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let x = int_of_string reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let s = reverse (string_of_int n) 
and n2 = int_of_string s  
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let s = reverse (string_of_int n) 
and n2 = int_of_string s  
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let s = reverse (string_of_int n) in
let n2 = int_of_string s  
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let s = reverse (string_of_int n) in
let n2 = int_of_string s  
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let s = reverse (string_of_int n) in
let n2 = int_of_string s  in
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else 
let s = reverse (string_of_int n) in
let n2 = int_of_string s  in
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 and let n2 = reverse n in z = z+1

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 and let n2 = reverse n in z = z+1


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0


fix:
let _ = digitsOfInt 3124

bad:
let n2 = reverse n in z = z+1

annotated:
let n2 = reverse n in z = z+1


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse n in z = z+1

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then let n2 = reverse n in z = z+1


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n) in z = z+1

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n) in z = z+1


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n) in z+1

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n) in z+1


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n)


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitOfInt n2

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitOfInt n2


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2


fix:
let _ = digitsOfInt 3124

bad:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2


fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2


fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2


fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec reverse s2 = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x

annotated:
let rec reverse s2 = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x


fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2


fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec reverse s2 = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x

annotated:
let rec reverse s2 = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x


fix:
let z = 0

bad:
let z = 0;

let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let z = 0;

let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt (-42313)

annotated:
let _ = digitsOfInt (-42313)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n z ->  
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2 0;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n z ->  
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2 0;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2 0;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x 0

annotated:
let rec digitsOfInt : int -> int list = fun  n z ->  
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2 0;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x 0


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt 352663

annotated:
let _ = digitsOfInt 352663


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt (-42313)

annotated:
let _ = digitsOfInt (-42313)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let _ = digitsOfInt (-42313)

annotated:
let _ = digitsOfInt (-42313)


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n. - 1.*(10.**s.) in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n. - 1.*(10.**s.) in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = float_of_int n - 1.*(10.** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = float_of_int n - 1.*(10.** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = (float_of_int n) - 1.*(10.** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = (float_of_int n) - 1.*(10.** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n - 1* int_of_float (10 ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n - 1* int_of_float (10 ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n - 1* int_of_float (10. ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n - 1* int_of_float (10. ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = n - 1* int_of_float (10. ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = n - 1* int_of_float (10. ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = n - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = n - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest


fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest


fix:
let rec rev s =
let n = String.length s in
for i=0 to (n - 1) / 2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s);
head::digitsOfInt rest

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s);
head::digitsOfInt rest


fix:
let rec rev s =
let n = String.length s in
for i=0 to (n - 1) / 2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (a,i)::t -> 
if a = k then i 
else 
assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (f b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f b,b)


fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sine(pi*" ^ exprToString e1 ^ ")"

bad:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> "sine(pi*" ^ exprToString e ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> "sine(pi*" ^ exprToString e ^ ")"


fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sine(pi*" ^ exprToString e1 ^ ")"

bad:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sine(pi*" ^ exprToString e1 ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sine(pi*" ^ exprToString e1 ^ ")"


fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ exprToString e1 ^ ")"
| Cosine e2 -> "cos(pi*" ^ exprToString e2 ^ ")"
| Average (e3,e4) -> "((" ^ exprToString e3 ^ "+" ^ exprToString e4 ^ ")/2)"
| Times (e5,e6) -> exprToString e5 ^ "*" ^ exprToString e6
| Thresh (e7,e8,e9,e10) -> "(" ^ exprToString e7 ^ "<" ^ exprToString e8 ^ "?" ^ exprToString e9 ^ ":" ^ exprToString e10 ^ ")"

bad:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ exprToString e1 ^ ")"
| Cosine e2 -> "cos(pi*" ^ exprToString e2 ^ ")"
| Average (e3,e4) -> "((" ^ exprToString e3 ^ "+" ^ exprToString e4 ^ ")/2)"

annotated:
let rec exprToString : expr -> string = fun  e  ->  
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ exprToString e1 ^ ")"
| Cosine e2 -> "cos(pi*" ^ exprToString e2 ^ ")"
| Average (e3,e4) -> "((" ^ exprToString e3 ^ "+" ^ exprToString e4 ^ ")/2)"


fix:
let _ = eval (Sine(Varx),1,1)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2

bad:
let _ = eval (Sine(VarX),1,1)

annotated:
let _ = eval (Sine(VarX),1,1)


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2

bad:
let _ = eval (Sine(VarX),1.0,1.0)

annotated:
let _ = eval (Sine(VarX),1.0,1.0)


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> float_of_int x
| VarY -> float_of_int y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> float_of_int x
| VarY -> float_of_int y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (a,i)::t -> 
if a = k then i 
else 
assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y b -> (f b, true),b)


fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (a,i)::t -> 
if a = k then i 
else 
assoc (d,k,t)

bad:
let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun y b -> (f b, true)),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile ((f b, f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, f b  ->  b),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y = (f b, f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y = (f b, f b  ->  b),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y -> (f b, f b = b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> (f b, f b  ->  b),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> (f b, f b ! ->  b),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y b-> (f b, f b ! ->  b),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y -> 
let x = f b in
if x = b then (x, true)
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y -> 
let x = f b in
if x = b then (x, true)
,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y b-> 
let x = f b in
if x = b then (x, true)
else y x 
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y b-> 
let x = f b in
if x = b then (x, true)
else y x 
,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y x = 
let z = f x in
if z = b then (x, true)
else y z,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x  ->  
let z = f x in
if z = b then (x, true)
else y z,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y x = 
let z = f x in
if z = b then (x, true)
else y z
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x  ->  
let z = f x in
if z = b then (x, true)
else y z
,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y x = 
let z = f x in
if z = b then (x, true)
else y z
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x  ->  
let z = f x in
if z = b then (x, true)
else y z
,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z
,b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, x)
,b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, x)
,b


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
)

annotated:
)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, b)
,b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, b)
,b


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
)

annotated:
)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile ((fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
)
,b

annotated:
)
,b


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
)

annotated:
)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100) in
wwhile (f, 2),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100) in
wwhile (f, 2),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y x = let xx = x*x*x in (xx, xx < 100),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x = let xx  ->  x*x*x in (xx, xx < 100),b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile ((let y x = let xx = x*x*x in (xx, xx < 100)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let y x = let xx  ->  x*x*x in (xx, xx < 100)), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y x-> (f x, f x != b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y x-> (f x, f x ! ->  b), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun y x-> (f x, f x ! ->  b)), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> (f b, f b ! ->  b), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> ((f b), (f b) ! ->  b), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y b-> (f b, f b ! ->  b), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y b =
let xx = f b in
(xx, xx != b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y b  -> 
let xx = f b in
(xx, xx != b), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y b1 =
let xx = f b1 in
(xx, xx != b), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y b1  -> 
let xx = f b1 in
(xx, xx != b), b)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let fixpoint (f,b) = wwhile (let y b1 =
let xx = f b1 in
(xx, xx != b1), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y b1  -> 
let xx = f b1 in
(xx, xx != b1), b)


fix:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

bad:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(******************* Functions you need to write **********)

(* build: (int*int->int) * int -> Expr 
Build an expression tree.  The second argument is the depth, 
the first is a random function.  A call to rand(2,5) will give
you a random number in the range [2,5].

Your code should call buildX, buildSine, etc. to construct
the expression.
*)

makeRand(1,2)

annotated:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(******************* Functions you need to write **********)

(* build: (int*int->int) * int -> Expr 
Build an expression tree.  The second argument is the depth, 
the first is a random function.  A call to rand(2,5) will give
you a random number in the range [2,5].

Your code should call buildX, buildSine, etc. to construct
the expression.
*)

makeRand(1,2)


fix:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

bad:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(******************* Functions you need to write **********)

(* build: (int*int->int) * int -> Expr 
Build an expression tree.  The second argument is the depth, 
the first is a random function.  A call to rand(2,5) will give
you a random number in the range [2,5].

Your code should call buildX, buildSine, etc. to construct
the expression.
*)



makeRand(1,2)

annotated:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(******************* Functions you need to write **********)

(* build: (int*int->int) * int -> Expr 
Build an expression tree.  The second argument is the depth, 
the first is a random function.  A call to rand(2,5) will give
you a random number in the range [2,5].

Your code should call buildX, buildSine, etc. to construct
the expression.
*)



makeRand(1,2)


fix:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in x

bad:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rand = makeRand (1,7) in
let x = rand(1,7)


fix:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in x

bad:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in rand

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rand = makeRand (1,7) in
let x = rand(1,7) in rand


fix:
let rand = makeRand(1,7)

bad:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in x

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rand = makeRand (1,7) in
let x = rand(1,7) in x


fix:
let rec build (rand, depth) = 
let x = rand(0,6) in 
match x with 
| 0 -> buildX()
| 1 -> buildY()
| 2 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 3 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = 
let x = rand(1,7) in 
match x with 
| 1 -> buildX()
| 2 -> buildY()
| 3 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 4 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let x = rand(1,7) in 
match x with 
| 1 -> buildX()
| 2 -> buildY()
| 3 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 4 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))


fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh(e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then 
eval(e3,x,y)
else eval(e4,x,y)
| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)
| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh(e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then 
eval(e3,x,y)
else eval(e4,x,y)
| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh(e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then 
eval(e3,x,y)
else eval(e4,x,y)
| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)


fix:
let _ = eval (AddThree(VarX,VarY,VarX),1.,5.)

bad:
let _ = eval (AddThree(VarX,VarY,VarX),1.,2.,3.)

annotated:
let _ = eval (AddThree(VarX,VarY,VarX),1.,2.,3.)


fix:
let _ = eval (AddThree(VarX,VarY,VarX),1.,5.)

bad:
let _ = eval (AddThree(VarX,VarY,VarX),1.,2.)

annotated:
let _ = eval (AddThree(VarX,VarY,VarX),1.,2.)


fix:
let g1 () = 20,8,9

bad:
let _ = eval (Power(VarX,VarY),3.,2.)

annotated:
let _ = eval (Power(VarX,VarY),3.,2.)


fix:
let g1 () = 20,8,9

bad:
let _ = eval (AddThree(VarX,VarY,VarX),2.,5.)

annotated:
let _ = eval (AddThree(VarX,VarY,VarX),2.,5.)


fix:
let g1 () = 20,8,9

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

annotated:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv


fix:
let g1 () = 20,8,9

bad:
let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

annotated:
let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))


fix:
let g1 () = 20,8,9

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let g1 () = 20,8,9

bad:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

annotated:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


fix:
let g1 () = 20,8,9

bad:
let rec build (rand, depth) = 
let x = rand(0,7) in 
match x with 
| 0 -> buildX()
| 1 -> buildY()
| 2 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 3 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))
| 4 -> if depth = 0 then build(rand,depth)
else buildTimes(build(rand,depth-1),build(rand,depth-1))
| 5 -> if depth = 0 then build(rand,depth)
else buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 -> if depth = 0 then build(rand,depth)
else buildPower(build(rand,depth-1),build(rand,depth-1))
| 7 -> if depth = 0 then build(rand,depth)
else buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| _ -> buildX()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let x = rand(0,7) in 
match x with 
| 0 -> buildX()
| 1 -> buildY()
| 2 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 3 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))
| 4 -> if depth = 0 then build(rand,depth)
else buildTimes(build(rand,depth-1),build(rand,depth-1))
| 5 -> if depth = 0 then build(rand,depth)
else buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 -> if depth = 0 then build(rand,depth)
else buildPower(build(rand,depth-1),build(rand,depth-1))
| 7 -> if depth = 0 then build(rand,depth)
else buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| _ -> buildX()


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs = 
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs = 
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs = 
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs = 
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs y = 
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs y  ->  
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs  = function 
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  function 
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs  y=  
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  y ->   
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l 

annotated:


let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l 


fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ "x" in
let base = "" in
let l 

annotated:


let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ "x" in
let base = "" in
let l 


fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l 

annotated:


let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l 


fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ x in
let base = "" in
let l 

annotated:


let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ x in
let base = "" in
let l 


fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "h" in
let l

annotated:


let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "h" in
let l


fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l =

annotated:


let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l =


fix:


let pipe fs =  
let f a x = x a in
let b

bad:


let pipe fs y=  
let f a x = x a in
let b

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs y ->   
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let _ = pipe [(fun x -> x+x);

annotated:


let _ = pipe [(fun x -> x+x);


fix:
(* UNCOMMENT AFTE

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
(* UNCOMMENT AFTE

bad:


let _ = pipe [(fun x -> x+x);

annotated:


let _ = pipe [(fun x -> x+x);


fix:
(* UNCOMMENT AFTE

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
(* UNCOMMENT AFTE

bad:
let pipe fs =  
let f a x = x a in
let b

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   
let f a x = x a in
let b


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs =  
let f a x = x base in
le

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   
let f a x = x base in
le


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs =  
let f a x = x' (x a)  in

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   
let f a x = x' (x a)  in


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs =  
let f a x = fun (x a)  i

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   
let f a x = fun (x a)  i


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs =  
let f a x = fun x' ->  x

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   
let f a x = fun x' ->  x


fix:
(* UNCOMMENT AFTE

bad:


let pipe fs y=  
let f a x = x a  in
let 

annotated:


let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs y ->   
let f a x = x a  in
let 


fix:
;;

bad:
let sqsum xs = 
let f a x = x * x + a in

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x * x + a in


fix:
;;

bad:
let sqsum xs = 
let f a x = x * x + a in

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x * x + a in


fix:
let sqsum xs = 
let f a x = (x * x + a)

bad:
let sqsum xs = 
let f a x = (x * x + a) 

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (x * x + a) 


fix:


let sqsum xs = 
let f a x = x * x + a in

bad:
let sqsum xs = 
let f a x = x * x + a in

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = x * x + a in


fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
if i = 0 then []
else if i = 1 then l
else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
if i = 0 then []
else if i = 1 then l
else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs =
match xs with
[] -> 0 | h::t -> h + sumList t

bad:
let rec sumList xs =
match xs with
[] -> 0 | h::t -> h + sumList

annotated:
let rec sumList : int list -> int = fun  xs  -> 
match xs with
[] -> 0 | h::t -> h + sumList


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
n/10 == 0 -> [n] | digitsOfInt n/10 -> n%10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
n/10 == 0 -> [n] | digitsOfInt n/10 -> n%10 :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | digitsOfInt n/10 -> n%10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | digitsOfInt n/10 -> n%10 :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | digitsOfInt (n/10) -> n%10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | digitsOfInt (n/10) -> n%10 :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | digitsOfInt n -> n%10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | digitsOfInt n -> n%10 :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | n -> digitsOfInt n/10 n%10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | n -> digitsOfInt n/10 n%10 :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | n -> digitsOfInt n/10 :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | n -> digitsOfInt n/10 :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | n -> digitsOfInt n :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | n -> digitsOfInt n :: []


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | n -> [digitsOfInt n/10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | n -> [digitsOfInt n/10]


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | n/10 -> [digitsOfInt n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | n/10 -> [digitsOfInt n]


fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec digitsOfInt n =
match n with
0 -> [] | (n/10) -> [digitsOfInt n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0 -> [] | (n/10) -> [digitsOfInt n]


fix:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> digitsOfInt (n/10) @  [n mod 10]

bad:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> digitsOfInt (n/10) @  [n%10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0  -> [] 
| _  -> digitsOfInt (n/10) @  [n%10]


fix:
let rec digitsOfInt n =
_ -> digitsOfInt (n/10) @  [n mod 10]

bad:
let rec digitsOfInt n =
n -> digitsOfInt (n/10) @  [n mod 10]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
n -> digitsOfInt (n/10) @  [n mod 10]


fix:
let rec digitsOfInt n =
if n = 0 then [0]
else hDigitsofInt n

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)


fix:
let rec digitsOfInt n =
if n = 0 then [0]
else hDigitsofInt n

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)


fix:
let rec digitsOfInt n =
if n = 0 then [0]
else hDigitsofInt n

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)


fix:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)
if n = 0 then [0]

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)
if n = 0 then [0]


fix:
let rec digitsOfInt n =
if n = 0 then [0]
else
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)


fix:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help num = fun
match num with
0  -> [] 
| _  -> cat (help (num/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help num = fun
match num with
0  -> [] 
| _  -> cat (help (num/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun |
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n = fun |
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n = fun 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n = 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n in 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n in 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else fun rec help n   ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else fun rec help n   ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else fun help n  ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else fun help n  ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n  ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n  ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n  =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n = 0 then [0]
else let rec help n  =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)


fix:
let rec listReverse l = 
match l with
[]   -> []
| h::t -> listReverse (t::(cat l h))

bad:
let rec listReverse l = 
match l with
[]   -> []
| h::t -> listReverse ((cat l h)::t)

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
match l with
[]   -> []
| h::t -> listReverse ((cat l h)::t)


fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

bad:
let palindrome w = 
let l = explode w

annotated:
let palindrome : string -> bool = fun  w  ->  
let l = explode w


fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

bad:
let reverse = listReverse l

annotated:
let reverse = listReverse l


fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

bad:
let palindrome w = 
let l = explode w

annotated:
let palindrome : string -> bool = fun  w  ->  
let l = explode w


fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

bad:
let reverse = listReverse l

annotated:
let reverse = listReverse l


fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

bad:
let palindrome w = 
let l = explode w

annotated:
let palindrome : string -> bool = fun  w  ->  
let l = explode w


fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

bad:
let reverse = listReverse l

annotated:
let reverse = listReverse l


fix:
let _ = additivePersistence 9999

bad:
let _ = additivePersistence (-9999)

annotated:
let _ = additivePersistence (-9999)


fix:
let rec assoc (d,k,l) = match l with
[]   -> d
| h::t -> 
if k = h then 10 else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
[]   -> d
| h::t -> assoc (d,k,l) in
if k = h then 10 else assoc (d,k,t)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
[]   -> d
| h::t -> assoc (d,k,l) in
if k = h then 10 else assoc (d,k,t)


fix:
let rec assoc (d,k,l) = match l with
[]   -> d
| (n,a)::t -> 
if k = n then a else assoc (d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])


fix:
let rec assoc (d,k,l) = match l with
[]   -> d
| (n,a)::t -> 
if k = n then a else assoc (d,k,t)

bad:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

annotated:
let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h,t) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h,t) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h , t) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h , t) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h::[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h::[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h@[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h@[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then [] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then [] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h::[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h::[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then (h::[]) in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then (h::[]) in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h@seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h@seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let rec wwhile (f,b) = match f with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec wwhile (f,b) = match f with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec wwhile (f,b) = match f with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let rec wwhile (f,b) = match f with
f(num, b00l)-> if b00l then num else wwhile (f, num)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
f(num, b00l)-> if b00l then num else wwhile (f, num)


fix:
let rec wwhile (f,b) = match f b with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let rec wwhile (f,b) = let f b in match t with
()-> if b00l then num else wwhile (f, num)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  let f b in match t with
()-> if b00l then num else wwhile (f, num)


fix:
let rec wwhile (f,b) = match f b with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let rec wwhile (f,b) = fun f b in match t with
()-> if b00l then num else wwhile (f, num)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  fun f b in match t with
()-> if b00l then num else wwhile (f, num)


fix:
let rec wwhile (f,b) = match f b with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let rec wwhile (f,b) = fun f b match t with
()-> if b00l then num else wwhile (f, num)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  fun f b match t with
()-> if b00l then num else wwhile (f, num)


fix:
let rec wwhile (f,b) = match f b with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let rec wwhile (f,b) = match f b with
()-> if b00l then num else wwhile (f, num)

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with
()-> if b00l then num else wwhile (f, num)


fix:
let fixpoint (f,b) = wwhile (f b,b)

bad:
let fixpoint (f,b) = wwhile (fixpoint(f,b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fixpoint(f,b),b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile (b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile (fixpoint (f,b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fixpoint (f,b),b)


fix:
let fixpoint (f,b) = wwhile (match f with num -> num,b)

bad:
let fixpoint (f,b) = wwhile (match f with num,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (match f with num,b)


fix:
93

bad:
let fixpoint (f,b) = wwhile ((),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((),b)


fix:
let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)

bad:
let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y ! ->  b)),b)


fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e ^")"

bad:
let rec exprToString e = match e with
Thresh (a,b,c,d) -> exprToString a b c d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
Thresh (a,b,c,d) -> exprToString a b c d


fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e ^")"

bad:
let rec exprToString e = match e with
Thresh (a,b,c,d) -> 
(exprToString a, exprToString b,exprToString c,exprToString d)

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
Thresh (a,b,c,d) -> 
(exprToString a, exprToString b,exprToString c,exprToString d)


fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e ^")"

bad:
let rec exprToString e = match e with
VarX x -> "x"
| VarY y -> "y"
| Sine s -> "sin (pi*" ^ exprString e ^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX x -> "x"
| VarY y -> "y"
| Sine s -> "sin (pi*" ^ exprString e ^")"


fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e ^")"

bad:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprString e ^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprString e ^")"


fix:
let rec exprToString e = match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin (pi*" ^ exprToString e ^")"
| Cosine e       -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)  -> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times   (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh (e,f,g,h) 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

bad:
let rec exprToString e = match e with
VarX     -> "x"
| VarY     -> "y"
| Sine e   -> "sin (pi*" ^ exprToString e ^")"
| Cosine e -> "cos (pi*" ^ exprToString e ^")"
| Averages -> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times    -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh   
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX     -> "x"
| VarY     -> "y"
| Sine e   -> "sin (pi*" ^ exprToString e ^")"
| Cosine e -> "cos (pi*" ^ exprToString e ^")"
| Averages -> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times    -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh   
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"


fix:
let rec exprToString e = match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin (pi*" ^ exprToString e ^")"
| Cosine e       -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)  -> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times   (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh (e,f,g,h) 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

bad:
let rec exprToString e = match e with
VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin (pi*" ^ exprToString e ^")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^")"
| Average e -> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times e   -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh e  
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin (pi*" ^ exprToString e ^")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^")"
| Average e -> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times e   -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh e  
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"


fix:
let rec exprToString e = match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin (pi*" ^ exprToString e ^")"
| Cosine e       -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)  -> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times   (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh (e,f,g,h) 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

bad:
let rec exprToString e = match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average e e-> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times e e  -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh e e e e 
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average e e-> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times e e  -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh e e e e 
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"


fix:
let rec exprToString e = match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin (pi*" ^ exprToString e ^")"
| Cosine e       -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)  -> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times   (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh (e,f,g,h) 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

bad:
let rec exprToString e = match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average e f-> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times e f  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh e f g h 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average e f-> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times e f  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh e f g h 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"


fix:
let rec exprToString e = match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin (pi*" ^ exprToString e ^")"
| Cosine e       -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)  -> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times   (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh (e,f,g,h) 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

bad:
let rec exprToString e = match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)-> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh e f g h 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)-> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh e f g h 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> failwith "sad"

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0
| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> failwith "sad"

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0
| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> failwith "sad"


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e3,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e3,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(val(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(val(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))


fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y) < eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y) < eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)


fix:
let rec build (rand, depth) = 
if(depth > 0) then
if rand mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rand mod 5 = 2 then buildAverage(buildX(),buildY())
else if rand mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
if(depth > 0) then
if rand%5 = 0 then buildSine (build(rand, depth-1) )
else if rand%5 = 1 then buildCosine(build(rand, depth-1) )
else if rand%5 = 2 then buildAverage(buildX(),buildY())
else if rand%5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand%2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth > 0) then
if rand%5 = 0 then buildSine (build(rand, depth-1) )
else if rand%5 = 1 then buildCosine(build(rand, depth-1) )
else if rand%5 = 2 then buildAverage(buildX(),buildY())
else if rand%5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand%2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec build (rand, depth) = 
if(depth > 0) then
if rand mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rand mod 5 = 2 then buildAverage(buildX(),buildY())
else if rand mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
if(depth > 0) then
if rand%.5 = 0 then buildSine (build(rand, depth-1) )
else if rand%5 = 1 then buildCosine(build(rand, depth-1) )
else if rand%5 = 2 then buildAverage(buildX(),buildY())
else if rand%5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand%2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth > 0) then
if rand%.5 = 0 then buildSine (build(rand, depth-1) )
else if rand%5 = 1 then buildCosine(build(rand, depth-1) )
else if rand%5 = 2 then buildAverage(buildX(),buildY())
else if rand%5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand%2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand 0 100 in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand 0 100 in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand 0 100 in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand 0 100 in
if rand mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth > 0) then
let rnd = rand 0 100 in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand 0 100 in
if rand mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec build (rand, depth) = 
Format.sprintf "%d" depth in
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
Format.sprintf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
Format.sprintf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec build (rand, depth) = 

if(depth > 0) then
Format.printf "%d" depth

bad:
let rec build (rand, depth) = 

if(depth > 0) then
Format.sprintf "%d" depth

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  

if(depth > 0) then
Format.sprintf "%d" depth


fix:
let rec build (rand, depth) = 
let _ = Format.printf "%d" depth in
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 

if(depth > 0) then
Format.printf "%d" depth in
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  

if(depth > 0) then
Format.printf "%d" depth in
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec build (rand, depth) = 
let _ = Format.printf "%d" depth in
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
Format.printf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
Format.printf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec build (rand, depth) = 
let _ = Format.printf "%d" depth in
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
let _ = Format.printf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let _ = Format.printf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())


fix:
let rec eval (e,x,y) = match e with
VarX	             -> x
| VarY  	       -> y
| Sine e               -> sin(pi*.eval(e,x,y))
| Cosine e             -> cos(pi*.eval(e,x,y))
| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)
| Timmy1 (e1,e2,e3)    -> 
(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))
| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))

bad:
let rec eval (e,x,y) = match e with
VarX	             -> x
| VarY  	       -> y
| Sine e               -> sin(pi*.eval(e,x,y))
| Cosine e             -> cos(pi*.eval(e,x,y))
| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)
| Timmy1 (e1,e2,e3)    -> 
(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))
| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
VarX	             -> x
| VarY  	       -> y
| Sine e               -> sin(pi*.eval(e,x,y))
| Cosine e             -> cos(pi*.eval(e,x,y))
| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)
| Timmy1 (e1,e2,e3)    -> 
(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))
| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))


fix:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand (0, 5) in
if rnd mod 7 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7=4 then
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else (*if rnd mod 7=5 then*)
buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))
(*else
buildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)
else
let rnd = rand (0, 2) in
if rnd mod 2 =0 then buildX() 
else buildY()

bad:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand (0, 5) in
if rnd mod 7 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7=4 then
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else (*if rnd mod 7=5 then*)
buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))
(*else
buildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)
else
let rnd = rand (0, 2) in
if rnd mod 2 =0 then buildX() 
else buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if(depth > 0) then
let rnd = rand (0, 5) in
if rnd mod 7 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7=4 then
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else (*if rnd mod 7=5 then*)
buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))
(*else
buildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)
else
let rnd = rand (0, 2) in
if rnd mod 2 =0 then buildX() 
else buildY()


fix:
let pipe fs = 
let f a x = a+x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a+x in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = a+x in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = a+x in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x =  fun a -> x  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a + x  in
let base =  fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a + x  in
let base =  fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun x -> a  in
let base =  fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  fun x -> a  in
let base =  fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  f (fun a->x)-> a  in
let base =  fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  f (fun a->x)-> a  in
let base =  fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =  (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  f (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  f (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =   (fun a->x) x in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a (fun a->x) in
let base =  fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  a (fun a->x) in
let base =  fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =   (fun a->x) a in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =   (fun a>x) a in
let base =  fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =   (fun a>x) a in
let base =  fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =   (fun x->a) a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =   (fun x->a) a in
let base =  x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =   (fun x->a) a in
let base =  x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x =   (fun x->a) a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =   (fun x->a) a in
let base =  a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =   (fun x->a) a in
let base =  a in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep  in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x (a^sep)  in
let base = h in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = x (a^sep)  in
let base = h in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^sep  in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep  in
let base = h in
let l = x in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep  in
let base = h in
let l = x in
List.fold_left f base l


fix:
let stringOfList f l =  List.map f l

bad:
let stringOfList f l = f (pipe List.map l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  f (pipe List.map l)


fix:
let stringOfList f l =  sepConcat "" (List.map f l)

bad:
let stringOfList f l =  sepConcat f (List.map f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->   sepConcat f (List.map f l)


fix:
let stringOfList f l =  sepConcat "[]" (List.map f l)

bad:
let stringOfList f l =  sepConcat (List.map f l) l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->   sepConcat (List.map f l) l


fix:
let stringOfList f l =  sepConcat "" (List.map f l)

bad:
let stringOfList f l = (List.map f (sepConcat "" l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  (List.map f (sepConcat "" l))


fix:
let rec clone x n = match n with
0    -> []
| _ ->  x::clone x (n-1)

bad:
let rec clone x n = match n with
0    -> []
| h::t ->  x::clone x (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
0    -> []
| h::t ->  x::clone x (n-1)


fix:
let rec clone x n = if n <= 0 then [] else x::clone x (n-1)

bad:
let rec clone x n = match n with
n <= 0 -> []
| _      ->  x::clone x (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
n <= 0 -> []
| _      ->  x::clone x (n-1)


fix:
let rec clone x n = if n <= 0 then [] else x::clone x (n-1)

bad:
let rec clone x n = match n with
n < 0 -> []
| _      ->  x::clone x (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
n < 0 -> []
| _      ->  x::clone x (n-1)


fix:
let rec clone x n = if n <= 0 then [] else x::clone x (n-1)

bad:
let rec clone x n = match n with
n = 0 -> []
| _      ->  x::clone x (n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with
n = 0 -> []
| _      ->  x::clone x (n-1)


fix:
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

bad:
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then (clone 0 l1, l2) 
else if (s2<s1) then (l1, clone 0 l2)
else (l1,l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then (clone 0 l1, l2) 
else if (s2<s1) then (l1, clone 0 l2)
else (l1,l2)


fix:
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

bad:
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 s1-s2)@l2)
else (l1,l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 s1-s2)@l2)
else (l1,l2)


fix:
let rec removeZero l = match l with
[]  -> []
| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t

bad:
let rec removeZero l = match l with
h   -> if (h != 0) then []
| h::t-> if(h=0) then removeZero t else h::removeZero t

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
h   -> if (h != 0) then []
| h::t-> if(h=0) then removeZero t else h::removeZero t


fix:
let rec removeZero l = match l with
[]  -> []
| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t

bad:
let rec removeZero l = match l with
[]  -> []
| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t

annotated:
let rec removeZero : int list -> int list = fun  l  ->  match l with
[]  -> []
| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base = [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith ""
in
let base = [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> []
| h::t -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
[]   -> []
| h::t -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> []
| h::t -> []
in
let base = [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
[]   -> []
| h::t -> []
in
let base = [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> ([],[])
| h::t -> ([],[])
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
[]   -> ([],[])
| h::t -> ([],[])
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
([],[])   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
([],[])   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
[]   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
[] -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
[] -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[] -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
[] -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[] -> ([], [])
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
[] -> ([], [])
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
[] -> ([], [])
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
[] -> ([], [])
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  fun x -> x in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  fun x -> x in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (snd a) with
[]  -> (fst x + snd x, ((fst x + snd x)/10)::[(fst x + snd x) mod 10]) 
|h::t -> (0, [] )
in
let base =  (0, []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(c, h::t) -> []
in
let base =  (0, []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
(c, h::t) -> []
in
let base =  (0, []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let rec mulByDigit i l = match i with
0 -> []
| 1 -> l
| 2 -> bigAdd l l
| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)

bad:
let rec mulByDigit i l = 
let lr = List.rev l in
match lr with
(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) 
| (c,h::t) -> 
let sum = c + (fst x * snd x) in
(sum/10, (sum mod 10)::(snd a))

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let lr = List.rev l in
match lr with
(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) 
| (c,h::t) -> 
let sum = c + (fst x * snd x) in
(sum/10, (sum mod 10)::(snd a))


fix:
let rec mulByDigit i l = match i with
0 -> []
| 1 -> l
| 2 -> bigAdd l l
| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)

bad:
let rec mulByDigit i l = match i with
0 -> []
| 1 -> l
| 2 -> bigAdd l l
| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match i with
0 -> []
| 1 -> l
| 2 -> bigAdd l l
| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)


fix:
let _ = mulByDigit 9999999999999 [9;9;9;9]

bad:
let _ = mulByDigit 99999999999999999999 [9;9;9;9]

annotated:
let _ = mulByDigit 99999999999999999999 [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
(_,[])   -> mulByDigit (fst x) l1
|(c, h::t) -> (c, mulByDigit h x)
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with
(_,[])   -> mulByDigit (fst x) l1
|(c, h::t) -> (c, mulByDigit h x)
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
(_,[])   -> mulByDigit (fst x) l1
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  match a with
(_,[])   -> mulByDigit (fst x) l1
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (fst a, bigAdd () ()) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (fst a, bigAdd () ()) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (x@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = 
((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = match a with
(((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match a with
((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs = 
if List.length xs>0 then
List.hd xs + sumList (List.tl xs)
else
0

bad:
let rec sumList xs = 
if List.length xs>0 then
List.hd xs + sumList List.tl xs
else
0

annotated:
let rec sumList : int list -> int = fun  xs  ->  
if List.length xs>0 then
List.hd xs + sumList List.tl xs
else
0


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitOfInt n/10 @ ( n mod 10 ::[])
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitOfInt n/10 @ ( n mod 10 ::[])
else
[]


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 @ ( n mod 10 ::[])
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10 @ ( n mod 10 ::[])
else
[]


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
(digitsOfInt n/10) @ ( n mod 10 ::[])
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
(digitsOfInt n/10) @ ( n mod 10 ::[])
else
[]


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10 
else
[]


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[1;]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10 
else
[1;]


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[1]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10 
else
[1]


fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[1]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10 
else
[1]


fix:
let rec digitsOfInt n = 
if n>0 then
[5]@ digitsOfInt (n/10)
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10
else
[]


fix:
let rec digitsOfInt n = 
if n>0 then
[5]@ digitsOfInt (n/10)
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10
else
[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
digitsOfInt n/10
else
[]


fix:
let rec digitsOfInt n = 
if n>0 then
[5]@ digitsOfInt (n/10)
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
[5]@ digitsOfInt n/10
else
[1]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>0 then
[5]@ digitsOfInt n/10
else
[1]


fix:
let rec additivePersistence n =
if n>0 then
1+ additivePersistence (help n)
else
0

bad:
let rec additivePersistence n =
if n>0 then
1+ additivePersistence help  n
else
0

annotated:
let rec additivePersistence : int -> int = fun  n  -> 
if n>0 then
1+ additivePersistence help  n
else
0


fix:
let rec listReverse l = 
if List.length l >0 then
(List.hd l ::[])
else
[]

bad:
let rec listReverse l = 
if List.length>0 then
(listReverse List.tl l) @ (List.hd l ::[])
else
[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
if List.length>0 then
(listReverse List.tl l) @ (List.hd l ::[])
else
[]


fix:
let rec listReverse l = 
if List.length l >0 then
(List.hd l ::[])
else
[]

bad:
let rec listReverse l = 
if List.length l >0 then
(listReverse List.tl l) @ (List.hd l ::[])
else
[]

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
if List.length l >0 then
(listReverse List.tl l) @ (List.hd l ::[])
else
[]


fix:
let rec sumList xs = match xs with
[]->0
| h::x -> h+(sumList x)

bad:
let rec sumList xs = match xs with
[]->0
|List.hd xs + sumList (List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
[]->0
|List.hd xs + sumList (List.tl xs)


fix:
let rec sumList xs = match xs with
[]->0
| h::x -> h+(sumList x)

bad:
let rec sumList xs = match xs with
[]->0
| List.hd xs + sumList (List.tl xs)

annotated:
let rec sumList : int list -> int = fun  xs  ->  match xs with
[]->0
| List.hd xs + sumList (List.tl xs)


fix:
let rec listReverse l = match l with
[]->[]
|h::x->(listReverse x) @ h

bad:
let rec listReverse l = match l with
[]->[]
|h:x->(listReverse x) @ h

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with
[]->[]
|h:x->(listReverse x) @ h


fix:
let rec digitsOfInt n = 
if n>10 then
(n mod 10):: (digitsOfInt (n/10))
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
(n mod 10):: (digitsOfInt (n/10)
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>10 then
(n mod 10):: (digitsOfInt (n/10)
else
[n]


fix:
let rec digitsOfInt n = 
if n>=100 then
[n mod 10]
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
(digitsOfInt (n/10))::[n mod 10]
else
n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>10 then
(digitsOfInt (n/10))::[n mod 10]
else
n


fix:
let rec digitsOfInt n = 
if n>=100 then
[n mod 10]
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
n::[n mod 10]
else
n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>10 then
n::[n mod 10]
else
n


fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
n::[]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
n::[]


fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else




(* uncomment and run AFTER you have implemented digitsOfInt *)
let _ = digitsOfInt 3124

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else




(* uncomment and run AFTER you have implemented digitsOfInt *)
let _ = digitsOfInt 3124


fix:
let rec digitsOfInt n = 
if n>=10 then
digitsOfInt (n/10) @ [n mod 10]
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app digitsOfInt (n/10) [n mod 10]
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app digitsOfInt (n/10) [n mod 10]
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
(digitsOfInt (n/10)) @ ([n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
(digitsOfInt (n/10)) @ ([n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
n

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
n


fix:
let rec digitsOfInt n = 
if n>=10 then
(digitsOfInt (n/10)) @ ([n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ((digitsOfInt (n/10)) ([n mod 10]))
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ((digitsOfInt (n/10)) ([n mod 10]))
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
(digitsOfInt (n/10)) @ ([n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ((digitsOfInt (n/10)) ([n mod 10]))
else
[n+0]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ((digitsOfInt (n/10)) ([n mod 10]))
else
[n+0]


fix:
let rec digitsOfInt n = 
if n>=10 then
(n/(helpFac n 1))::digitsOfInt (n/10)
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
(n/(help n 1))::digitsOfInt (n/10)
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
(n/(help n 1))::digitsOfInt (n/10)
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
[n]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
[n]


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
app [n] []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
app [n] []


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
app [n] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
app [n] [8]


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ([n/10] [n mod 10]) 
else
app [3] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ([n/10] [n mod 10]) 
else
app [3] [8]


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ([(n/10)] [n mod 10]) 
else
app [3] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ([(n/10)] [n mod 10]) 
else
app [3] [8]


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ([n/10] [n mod 10]) 
else
app [3] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ([n/10] [n mod 10]) 
else
app [3] [8]


fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app ([n / 10] [n mod 10]) 
else
app [3] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app ([n / 10] [n mod 10]) 
else
app [3] [8]


fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10)) [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app digitsOfInt n/10 [n mod 10] 
else
app [3] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app digitsOfInt n/10 [n mod 10] 
else
app [3] [8]


fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10)) [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app digitsOfInt (n/10) [n mod 10] 
else
app [3] [8]

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n>=10 then
app digitsOfInt (n/10) [n mod 10] 
else
app [3] [8]


fix:
let _ = digitsOfInt 3124

bad:
let _ = digitsOfInt 3124let _ =digitsOfInt 1001

annotated:
let _ = digitsOfInt : int -> int list = fun  3124let _  -> digitsOfInt 1001


fix:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) (n mod 10::ls)
else
[n]
in
driver n []

bad:
let digitsOfInt n = 
let driver n ls=
if n>=10 then
driver n/10 (n mod 10::ls)
else
[n]
in
driver n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let driver n ls=
if n>=10 then
driver n/10 (n mod 10::ls)
else
[n]
in
driver n []


fix:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) (n mod 10::ls)
else
[n]
in
driver n []

bad:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver n/10 (n mod 10::ls)
else
[n]
in
driver n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec driver n ls=
if n>=10 then
driver n/10 (n mod 10::ls)
else
[n]
in
driver n []


fix:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) ((n mod 10)::ls)
else
ls
in
driver (n*10) []

bad:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) ((n mod 10)::ls)
else
ls
in
driver n*10 []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec driver n ls=
if n>=10 then
driver (n/10) ((n mod 10)::ls)
else
ls
in
driver n*10 []


fix:
let additivePersistence n =let rec county n=
if n>=10 then
1+ additivePersistence (help n)
else
0
in 
county n

bad:
let additivePersistence n =let rec county=
if n>=10 then
1+ additivePersistence (help n)
else
0
in 
county n

annotated:
let additivePersistence : int -> int = fun  n =let rec county -> 
if n>=10 then
1+ additivePersistence (help n)
else
0
in 
county n


fix:
let rec assoc (d,k,l) = match (d ,k,l) with
|(x,y,[])->x
|(x,y,(a,b)::t)->if a=y then
b
else
assoc (x,y,t)

bad:
 _=(removeDuplicates [1,6,2,4,12,2,13,6,9])

annotated:
 _=(removeDuplicates [1,6,2,4,12,2,13,6,9])


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem seen h) then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem seen h) then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev helper ([],l)

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev helper ([],l)


fix:
let rec wwhile (f,b) = match f b with
|(a,c)->if not c then
a
else
wwhile (f,a)

bad:
let rec wwhile (f,b) = match f b with
|(a,c)->if not c then
a
else
wwhile f a

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with
|(a,c)->if not c then
a
else
wwhile f a


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile ((let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x)

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> 
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x)

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile ((let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x) )

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> 
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x) )

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x)

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> 
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x)

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile ((let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x))

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> 
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x))

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> 
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> 
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=
(let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) )
in
sec (y x) x

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> 
(let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) )
in
sec (y x) x

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=f b
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> f b
,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=y b in
g y b
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> y b in
g y b
,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=y b in
g f b
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> y b in
g f b
,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=

in
g f b

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> 

in
g f b

,b)


fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x= y x

in
g f b

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x ->  y x

in
g f b

,b)


fix:
let fixpoint (f,b) = wwhile (let g x=

in
(g (f b),false)

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=
((y x),false)
in
g f b

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> 
((y x),false)
in
g f b

,b)


fix:
let fixpoint (f,b) = wwhile (let g x=

in
(g (f b),false)

,b)

bad:
let fixpoint (f,b) = wwhile (let g x=
(x,false)
in
g f b

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> 
(x,false)
in
g f b

,b)


fix:
let fixpoint (f,b) = wwhile (let g x=

in
(g (f b),false)

,b)

bad:
let fixpoint (f,b) = wwhile (let g x=
(x,false)
in
g (f b)

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> 
(x,false)
in
g (f b)

,b)


fix:
let fixpoint (f,b) = wwhile (let g x=

in
(g (f b),false)

,b)

bad:
let fixpoint (f,b) = wwhile (let g x=
x,false
in
g (f b)

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> 
x,false
in
g (f b)

,b)


fix:
let fixpoint (f,b) = wwhile (let g x=

in
(g (f b),false)

,b)

bad:
let fixpoint (f,b) = wwhile (let g x=
x
in
g (f b)

,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> 
x
in
g (f b)

,b)


fix:
let g x y= ((y x),false)

bad:
let fixpoint (f,b) = wwhile (let g x y= ((y x),false)
in g b f
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x y ->  ((y x),false)
in g b f
,b)


fix:
let h q x y=q x y

bad:
let fixpoint (f,b) = wwhile (g b f
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (g b f
,b)


fix:
let f x = let xx = x*x*x in (xx,xx<100)

bad:
let fixpoint (f,b) = wwhile (let h x b= b x in h f b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x b ->  b x in h f b


fix:
let f x = let xx = x*x*x in (xx,xx<100)

bad:
,
,b)

annotated:
,
,b)


fix:
let f x = let xx = x*x*x in (xx,xx<100)

bad:
let fixpoint (f,b) = wwhile ((let h x b= b x in h f b),
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x b ->  b x in h f b),
,b)


fix:
let f x = let xx = x*x*x in (xx,xx<100)

bad:
let fixpoint (f,b) = wwhile ((h x b = b x 
in h f b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((h x b  ->  b x 
in h f b


fix:
let h x y = ((y x),x<100)

bad:
let fixpoint (f,b) = wwhile (let h x y = ((y x),x=x) in
h b f
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x y = ((y x),x -> x) in
h b f
,b)


fix:
let h x y = ((y x),x<100)

bad:
let fixpoint (f,b) = wwhile (let h x y = ((y x),x<100) in
h b f
,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x y  ->  ((y x),x<100) in
h b f
,b)


fix:
let h x=(x*x,x<100)

bad:
let fixpoint (f,b) = wwhile (h b f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (h b f,b)


fix:
let h x=(x*x,x<100)

bad:
let fixpoint (f,b) = wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)


fix:
let fixpoint (f,b) = wwhile (let h a= f a
in h b,b)

bad:
let fixpoint (f,b) = wwhile (let h = f
in (h,false),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h  ->  f
in (h,false),b)


fix:
let fixpoint (f,b) = wwhile (let h a= f a
in h b,b)

bad:
let fixpoint (f,b) = wwhile (let h a= f
in h a,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f
in h a,b)


fix:
let fixpoint (f,b) = wwhile (let h a= f a
in h b,b)

bad:
let fixpoint (f,b) = wwhile (let h a= f
in h b,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f
in h b,b)


fix:
let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in
h,b)

bad:
let fixpoint (f,b) = wwhile (let h x= (f x,false),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x ->  (f x,false),b)


fix:
let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in
h,b)

bad:
let fixpoint (f,b) = wwhile (let h x= (f x,false) in
h,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x ->  (f x,false) in
h,b)


fix:
let rec assoc (d,k,l) = match (d ,k,l) with
|(x,y,[])->x
|(x,y,(a,b)::t)->if a=y then
b
else
assoc (x,y,t)

bad:
let fixpoint (f,b) = wwhile (let h x= let first =f x in
let second =f first in 
let third = f second 
in  (second,not ((first=second)&&(second=third)
&&(third=first))
in
h,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x= let first  -> f x in
let second =f first in 
let third = f second 
in  (second,not ((first=second)&&(second=third)
&&(third=first))
in
h,b)


fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)


fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)


fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)


fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)


fix:
let _ = eval (sampleExpr1,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let rec build (rand, depth) = let res=rand(0,4) in match depth with
0-> if (res mod 2)=0 then
buildX()
else
buildY()
|_ ->let nd=depth-1 in
match res with
|0->buildAverage(build(rand,nd),build(rand,nd))
|1->buildThresh(build(rand,nd),build(rand,nd),
build(rand,nd),build(rand,nd))
|2->buildTimes(build(rand,nd),build(rand,nd))
|3->buildSine(build(rand,nd))
|4->buildCosine(build(rand,nd))
|_->buildX()

bad:
let rec build (rand, depth) = let res=rand(0,4) in match depth with
0-> if (res mod 2)=0 then
buildX()
else
buildY()
|_ ->let nd=depth-1 in
match res with
|0->buildAverage(build(rand,nd),build(rand,nd))
|1->buildThresh(build(rand,nd),build(rand,nd),
build(rand,nd),build(rand,nd))
|2->buildTimes(build(rand,nd),build(rand,nd))
|3->buildSine(build(rand,nd))
|4->buildCosine(build(rand,nd))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let res -> rand(0,4) in match depth with
0-> if (res mod 2)=0 then
buildX()
else
buildY()
|_ ->let nd=depth-1 in
match res with
|0->buildAverage(build(rand,nd),build(rand,nd))
|1->buildThresh(build(rand,nd),build(rand,nd),
build(rand,nd),build(rand,nd))
|2->buildTimes(build(rand,nd),build(rand,nd))
|3->buildSine(build(rand,nd))
|4->buildCosine(build(rand,nd))


fix:
et rec exprToString e = match e 
with  
VarX -> "x"
| VarY -> "y"
| Sine  expr -> "sin(pi*"^(exprToString expr)^")"
| Cosine expr-> "cos(pi*"^(exprToString expr)^")"
| Average (expr,expr1)->"(("^(exprToString expr)^"+"
^(exprToString expr1)^")/2)"
|Times   (expr,expr1)->(exprToString expr)^"*"^(exprToString expr1)
|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),
(exprToString expr2),
(exprToString expr3) 
in
"("^res1^"+"^res2^"+"^res3^")/(abs("^res1^")+abs("^res2^")+abs("
^res3^"))"

|Squa expr -> let res=exprToString expr in
"abs("^res^")/(abs"^res^"+"^res^"^2)"
| Thresh  (expr,expr1,expr2,expr3)->"("^(exprToString expr)^"<"
^(exprToString expr1)^"?"
^(exprToString expr2)^":"^
(exprToString expr3)

bad:
let rec exprToString e = match e 
with  
VarX -> "x"
| VarY -> "y"
| Sine  expr -> "sin(pi*"^(exprToString expr)^")"
| Cosine expr-> "cos(pi*"^(exprToString expr)^")"
| Average (expr,expr1)->"(("^(exprToString expr)^"+"
^(exprToString expr1)^")/2)"
|Times   (expr,expr1)->(exprToString expr)^"*"^(exprToString expr1)
|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),
(exprToString expr2),
(exprToString expr3) 
in
"("^res1^"+"^res2^"+"^res3^")/(abs("^res1^")+abs("^res2^")+abs("
^res3^"))"

|Squa expr -> let res=exprToString expr in
"abs("^res^")/(abs"^res^"+"^res^"^2)"
| Thresh  (expr,expr1,expr2,expr3)->"("^(exprToString expr)^"<"
^(exprToString expr1)^"?"
^(exprToString expr2)^":"^
(exprToString expr3)

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e 
with  
VarX -> "x"
| VarY -> "y"
| Sine  expr -> "sin(pi*"^(exprToString expr)^")"
| Cosine expr-> "cos(pi*"^(exprToString expr)^")"
| Average (expr,expr1)->"(("^(exprToString expr)^"+"
^(exprToString expr1)^")/2)"
|Times   (expr,expr1)->(exprToString expr)^"*"^(exprToString expr1)
|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),
(exprToString expr2),
(exprToString expr3) 
in
"("^res1^"+"^res2^"+"^res3^")/(abs("^res1^")+abs("^res2^")+abs("
^res3^"))"

|Squa expr -> let res=exprToString expr in
"abs("^res^")/(abs"^res^"+"^res^"^2)"
| Thresh  (expr,expr1,expr2,expr3)->"("^(exprToString expr)^"<"
^(exprToString expr1)^"?"
^(exprToString expr2)^":"^
(exprToString expr3)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)
| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),
eval(expr2,x,y)) in
(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))

| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)
| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),
eval(expr2,x,y)) in
(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))

| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)


fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)
| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),
eval(expr2,x,y)) in
(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))

| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)
| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),
eval(expr2,x,y)) in
(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))

| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let _=eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _=eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

bad:
let fixpoint (f,b) = wwhile (let h x= let first =x in
let second =f first 
in  (second,not ((first=second)))
in
h,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x= let first  -> x in
let second =f first 
in  (second,not ((first=second)))
in
h,b)


fix:
let buildNom(e,e1,e2)		   = Nom(e,e1,e2)

bad:
let buildNom(e,e1,e2)		   = Nom(e,e1,e2)

annotated:
let build: ((int * int -> int) * int) -> expr = fun Nom(e,e1,e2)		    ->  Nom(e,e1,e2)


fix:
let _=  (build(makeRand(3,4),3))

bad:
let _= exprToString (build(makeRand(3,4),2))

annotated:
let _= exprToString (build(makeRand(3,4),2))


fix:
let pipe fs = 
let f a x = x a in
let base = (fun j y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun j y->y) in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun j y->y) in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]


fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

annotated:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun z->z) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = y in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = y in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = fun z->z in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = fun z->z in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x =  in
let base = fun z->z in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base = fun z->z in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base = (fun a->a) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base = in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  a in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  fs in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  fs in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  *1 in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = x a in
let base =  *1 in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x _->x) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x _->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base =  (fun x->x) in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base =  (fun x->x) in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x _->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base =  (fun x->x) in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base =  (fun x->x) in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = x in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base =  (fun x ->x) in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base =  (fun x ->x) in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun j->fun y-> x a in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun j->fun x-> a in
let base =  (fun x ->x) in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun j->fun x-> a in
let base =  (fun x ->x) in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun j->a x  in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun j->a-> x  in
let base =  (fun x ->x) in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun j->a-> x  in
let base =  (fun x ->x) in 
List.fold_left f base fs


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = sepConcat sep t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = sepConcat sep t in
List.fold_left f base l


fix:
let stringOfList f l = List.map f l

bad:
let stringOfList f l = map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  map f l


fix:
let stringOfList f l = List.map f l

bad:
let stringOfList f l = map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  map f l


fix:
let stringOfList f l = List.map f l

bad:
let stringOfList f l = map f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  map f l


fix:
let stringOfList f l ="["^ (sepConcat "; " (List.map f l) )^"]"

bad:
let stringOfList f l ="["^ (sepConcat "; " sepList.map f l) ^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  -> "["^ (sepConcat "; " sepList.map f l) ^"]"


fix:
let stringOfList f l ="["^ (sepConcat "; " (List.map f l) )^"]"

bad:
let stringOfList f l ="["^ (sepConcat "; " (sepList.map f l) )^"]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  -> "["^ (sepConcat "; " (sepList.map f l) )^"]"


fix:
let rec clone x n = let rec  helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n

bad:
let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->help (sub::xs) sub (depth -1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with
0->xs
|_->help (sub::xs) sub (depth -1)


fix:
let rec clone x n = let rec  helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n

bad:
let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->help (sub::xs) sub (depth-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with
0->xs
|_->help (sub::xs) sub (depth-1)


fix:
let rec clone x n = let rec  helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n

bad:
let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)


fix:
let rec clone x n = let rec  helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n

bad:
let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n


fix:
let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in
let appendS=(clone ( abs  sizeDif ) 0) in
if sizeDif<0 then ( appendS@l1,l2)
else (l1,appendS@l2)

bad:
let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in
let appendS=(clone ( abs  sizeDif ) 0) in
if sizeDif<0 then ( appendS@l1,l2)
else then (l1,appendS@l2)

annotated:
let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let sizeDif ->  (List.length l1)-(List.length l2) in
let appendS=(clone ( abs  sizeDif ) 0) in
if sizeDif<0 then ( appendS@l1,l2)
else then (l1,appendS@l2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res%10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2)

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res%10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2)


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([10],[10])

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([10],[10])


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res%10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine List.rev l1 List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res%10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine List.rev l1 List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine List.rev l1 List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine List.rev l1 List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->((car::s),((re+y)mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->((((re+y)/10)+car)::s),((re+y)mod 10)::c2

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->((((re+y)/10)+car)::s),((re+y)mod 10)::c2


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->((car::s),((re+y)mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->let sub=re+y in( ((sub /10) +car)::s),
((sub mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->let sub=re+y in ((((sub /10 )+car)::s),
((sub mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->let sub=re+y in ((((sub /10 )+car)::s),
((sub mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in
let p1,p2=a in
match p2 with 
[]->(p1,(res/10)::(res mod 10)::[])
|a::b->let re=a+(res mod 10)  in
(p1,(re/10)::(re mod 10)::b )in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in
let p1,p2=a in
match p2 with 
[]->(res/10)::(res mod 10)::[]
|a::b->let re=a+(res mod 10)  in
(re/10)::(re mod 10)::b in

let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in
let p1,p2=a in
match p2 with 
[]->(res/10)::(res mod 10)::[]
|a::b->let re=a+(res mod 10)  in
(re/10)::(re mod 10)::b in

let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let bigMul l1 l2 = 
let f a x = s in
let base =([0],[0]) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = s in
let base =([0],[0]) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let b,c=a in match b with 
d::t-> ((d*10)::t, t)
|_    ->a
in

let base =(1::l2,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let b,c=a in match b with 
d::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))
|_    ->a
in

let base =(1::l2,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let b,c=a in match b with 
d::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))
|_    ->a
in

let base =(1::l2,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let _ = fixpoint (collatz, 1)

annotated:
let _ = fixpoint (collatz, 1)


fix:
let fixpoint (f,b) = wwhile(if f b = b then f, b)

bad:
let fixpoint (f,b) = wwhile((f::(f b = b)), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((f::(f b  ->  b)), b)


fix:
let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)

bad:
let _ = fixpoint (collatz, 48)

annotated:
let _ = fixpoint (collatz, 48)


fix:
let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)

bad:
let _ = fixpoint (collatz, 107)

annotated:
let _ = fixpoint (collatz, 107)


fix:
let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)

bad:
let _ = fixpoint (collatz, 3)

annotated:
let _ = fixpoint (collatz, 3)


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> sprintf"%s" e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> sprintf"%s" e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> sprintf(%s) e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> sprintf(%s) e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> sprintf("%s") e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> sprintf("%s") e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> Output.sprintf("%s") e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> Output.sprintf("%s") e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> Module.sprintf("%s") e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> Module.sprintf("%s") e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> ""
| Sine  
| Cosine   
| Average  
| Times    
| Thresh

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX     -> "%s" e
| VarY     -> ""
| Sine  
| Cosine   
| Average  
| Times    
| Thresh


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     ->
| Cosine   ->
| Average  ->
| Times    ->
| Thresh   ->

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     ->
| Cosine   ->
| Average  ->
| Times    ->
| Thresh   ->


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s" e
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s" e
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s %s" e e
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s %s" e e
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s %s" e 
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s %s" e 
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> "%s" e
| VarY              -> "%s" e
| Sine (e)          -> "%s" e 
| Cosine (e)        -> "%s" e
| Average (e,e)     -> "%s" e
| Times (e,e)       -> "%s" e
| Thresh (e,e,e,e)  -> "%s" e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> "%s" e
| VarY              -> "%s" e
| Sine (e)          -> "%s" e 
| Cosine (e)        -> "%s" e
| Average (e,e)     -> "%s" e
| Times (e,e)       -> "%s" e
| Thresh (e,e,e,e)  -> "%s" e


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> "%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> "%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> sprintf"%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> sprintf"%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1"
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1"
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.printf"e1"
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.printf"e1"
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%d" e1
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%d" e1
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%x" e1
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%x" e1
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1" 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1" 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1" 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1" 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX x             -> x
| VarY y             -> y
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX x             -> x
| VarY y             -> y
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> e
| VarY y             -> y
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> e
| VarY y             -> y
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> e
| VarY y             -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> e
| VarY y             -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s" e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX              -> Printf.sprintf"%s" e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX e          -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX e          -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX e          -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX e          -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX           -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX           -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX           -> ""::e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX           -> ""::e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> 
"%d" e
| VarY -> 
e
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> 
"%d" e
| VarY -> 
e
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> 
Printf.sprintf"%d" e
| VarY -> 
e
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> 
Printf.sprintf"%d" e
| VarY -> 
e
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""


fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

bad:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""


fix:
let rec eval (e,x,y) = match e with
| VarX ->
x
| VarY ->
y
| Sine e0 ->
sin(eval e0)
| Cosine e1 ->
cos(eval e1)
| Average (e2,e3)->
((eval e2)+(eval e3))/2
| Times (e4,e5) ->
(eval e4)*(eval e5)
| Thresh (e6, e7, e8, e9) ->
if (eval e6)<(eval e7) then (eval e8)
else (eval e9)

bad:
let rec eval (e,x,y) = match e with
| VarX ->
x
| VarY ->
y
| Sine e0 ->
sin(eval e0)
| Cosine e1 ->
cos(eval e1)
| Average (e2,e3)->
((eval e2)+(eval e3))/2
| Times (e4,e5) ->
(eval e4)*(eval e5)
| Thresh (e6, e7, e8, e9) ->
(eval e6)<(eval e7)?(eval e8):(eval e9)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX ->
x
| VarY ->
y
| Sine e0 ->
sin(eval e0)
| Cosine e1 ->
cos(eval e1)
| Average (e2,e3)->
((eval e2)+(eval e3))/2
| Times (e4,e5) ->
(eval e4)*(eval e5)
| Thresh (e6, e7, e8, e9) ->
(eval e6)<(eval e7)?(eval e8):(eval e9)


fix:
let rec eval (e,x,y) = match e with
| VarX ->
x
| VarY ->
y
| Sine e0 ->
sin(eval e0)
| Cosine e1 ->
cos(eval e1)
| Average (e2,e3)->
((eval e2)+(eval e3))/2
| Times (e4,e5) ->
(eval e4)*(eval e5)
| Thresh (e6, e7, e8, e9) ->
if (eval e6)<(eval e7) then (eval e8)
else (eval e9)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec build (rand, depth) =
failwith "ugh"

bad:
let rec build (rand, depth) =
if depth = 0 then 
if (rand mod 2) = 0 then buildX()
else buildY()
else if (rand mod 5) = 0 then 
buildSine(build(rand, depth - 1))
else if (rand mod 5) = 1 then 
buildCosine(build(rand, depth - 1))
else if (rand mod 5) = 2 then 
buildAverage(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 3 then 
buildAverage(build(rand, depth - 1))
else if (rand mod 5) = 4 then 
buildThresh(build(rand, depth -1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0 then 
if (rand mod 2) = 0 then buildX()
else buildY()
else if (rand mod 5) = 0 then 
buildSine(build(rand, depth - 1))
else if (rand mod 5) = 1 then 
buildCosine(build(rand, depth - 1))
else if (rand mod 5) = 2 then 
buildAverage(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 3 then 
buildAverage(build(rand, depth - 1))
else if (rand mod 5) = 4 then 
buildThresh(build(rand, depth -1))


fix:
let rec build (rand, depth) =
failwith "ugh"

bad:
let rec build (rand, depth) =
if depth = 0 then 
if (rand mod 2) = 0 then buildX()
else buildY()
else if (rand mod 5) = 0 then 
buildSine(build(rand, depth - 1))
else if (rand mod 5) = 1 then 
buildCosine(build(rand, depth - 1))
else if (rand mod 5) = 2 then 
buildAverage(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 3 then 
buildTimes(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 4 then 
buildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 
if depth = 0 then 
if (rand mod 2) = 0 then buildX()
else buildY()
else if (rand mod 5) = 0 then 
buildSine(build(rand, depth - 1))
else if (rand mod 5) = 1 then 
buildCosine(build(rand, depth - 1))
else if (rand mod 5) = 2 then 
buildAverage(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 3 then 
buildTimes(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 4 then 
buildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr,0.5,0.2)

annotated:
let _ = eval (sampleExpr,0.5,0.2)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

annotated:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)


fix:
let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))
| _ -> buildY()

bad:
let rand = 

let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand depth - 2), build(rand,depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))

annotated:
let rand = 

let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand depth - 2), build(rand,depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))


fix:
let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))
| _ -> buildY()

bad:
let rand = 

let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))

annotated:
let rand = 

let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))


fix:
let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))
| _ -> buildY()

bad:
let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))


fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h h
| [] -> fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| (b, c)::t -> f b c
| [] -> fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> a (x g) in
let base = match fs with 
| (b, c)::t -> f b c
| [] -> fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h h
| [] -> fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h h
| [] -> fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h t
| [] -> fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h t
| [] -> fun x -> x in 
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h h
| [] -> fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [] 3

annotated:
let _ = pipe [] 3


fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f (fun x -> x) h
| [] -> fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> x (a g) in
let base = match fs with 
| (fun b -> c)::t -> f (fun x -> x) h
| [] -> fun x -> x in 
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun g -> x (a g) in
let base = match fs with 
| (fun b -> c)::t -> f (fun x -> x) h
| [] -> fun x -> x in 
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = h in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = h in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]

annotated:
let _ = sepConcat ", " ["foo";"bar";"baz"]


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = t in
List.fold_left g base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = t in
List.fold_left g base l

bad:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = f t in
List.fold_left g base x

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = f t in
List.fold_left g base x


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = t in
List.fold_left g base l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m b = "[" ^ b ^ "]" in
let n a x = a ^ " ;" ^ x in
let base = f h in 
List.fold_left n base t

bad:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m b = "[" ^ b ^ "]" in
let n a x = a ^ " ;" ^ x in
let base = f h in 
List.fold_left g base t

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with 
| [] -> ""
| h :: t ->
let m b = "[" ^ b ^ "]" in
let n a x = a ^ " ;" ^ x in
let base = f h in 
List.fold_left g base t


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m b = "[" ^ b ^ "]" in
let n a x = a ^ " ;" ^ x in
let base = f h in 
List.fold_left n base t

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" ^ b ^ "]" in
let base = f h in 
List.fold_left m base l

bad:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" b ^ "]" in
let base = f h in 
List.fold_left m base l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" b ^ "]" in
let base = f h in 
List.fold_left m base l


fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" ^ b ^ "]" in
let base = f h in 
List.fold_left m base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]

annotated:
let _ = stringOfList (fun x -> x) ["foo"]


fix:
let _ = stringOfList (fun x -> x) ["foo"]

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

annotated:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]


fix:
let _ = stringOfList (fun x -> x) ["foo"]

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat "; " f l) ^ "]"

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  "[" ^ (sepConcat "; " f l) ^ "]"


fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let padZero l1 l2 = 
if List.length l1 < List.length l2 then
(clone 0 (List.length l2 - List.length l1)::l1),l2
else if List.length l2 > List.length l2 then
l1, (clone 0 (List.length l1 - List.length l2)::l2)
else 
l1, l2

bad:
let padZero l1 l2 = 
if l1 < l2 then 0

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
if l1 < l2 then 0


fix:
let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
l1, List.append (clone 0 (first - sec)) l2
else 
l1, l2

bad:
let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
((clone 0 (sec - first))::l1)
else if first > sec then
l1, ((clone 0 (first - sec))::l2)
else 
l1, l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
((clone 0 (sec - first))::l1)
else if first > sec then
l1, ((clone 0 (first - sec))::l2)
else 
l1, l2


fix:
let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
l1, List.append (clone 0 (first - sec)) l2
else 
l1, l2

bad:
let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
List.append l1 ((clone 0 (first - sec))::l2)
else 
l1, l2

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
List.append l1 ((clone 0 (first - sec))::l2)
else 
l1, l2


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in 
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (i,j)::t -> 
if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)
| [] -> 
(0,0) in 
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (i,j)::t -> 
if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)
| [] -> 
(0,0) in 
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
((i+j+a)/10, (i+j+a)%10) in 
let base = (0,[]) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,[]) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,[]) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in
multipler (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in
multipler (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, (mulByDigit x l2)::(clone 0 m)::n) in
multiplier ((List.length l1)-1) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in
multiplier (float_of_int ((List.length l1)-1)) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in
multiplier (float_of_int ((List.length l1)-1)) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, (mulByDigit x l2)::(clone 0 m)::n) in
multiplier ((List.length l1)-1) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, (mulByDigit x l2)::(clone 0 m)::n) in
multiplier (float_of_int ((List.length l1)-1)) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, (mulByDigit x l2)::(clone 0 m)::n) in
multiplier (float_of_int ((List.length l1)-1)) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs =
match xs with
| [] -> 0
| x::s -> x + sumList s

bad:
let rec sumList xs =
match xs with
| [] -> 0
| x:s -> x + sumList s

annotated:
let rec sumList : int list -> int = fun  xs  -> 
match xs with
| [] -> 0
| x:s -> x + sumList s


fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]

55 / 10

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]

55 / 10


fix:
let rec digitsOfInt n = 
if n < 0 then []
else n mod 10 :: digitsOfInt (n/10)

bad:
let rec digitsOfInt n = 
if n < 0 then []
else n % 10 :: digitsOfInt (n\10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else n % 10 :: digitsOfInt (n\10)


fix:
let rec digitsOfInt n = 
if n < 0 then []
else n mod 10 :: digitsOfInt (n/10)

bad:
let rec digitsOfInt n = 
if n < 0 then []
else n % 10 :: digitsOfInt (n/10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n < 0 then []
else n % 10 :: digitsOfInt (n/10)


fix:
let rec digitsOfInt n = 
if n <= 0 then []
else n mod 10 :: digitsOfInt (n/10)

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else digitsOfInt (n/10) :: n mod 10

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n <= 0 then []
else digitsOfInt (n/10) :: n mod 10


fix:
let rec digitsOfIntHelper n = 
if n > 0 then digitsOfIntHelper (n/10) @ [n mod 10] 
else []

bad:
let rec digitsOfIntHelper n = 
if n > 0 digitsOfIntHelper (n/10) @ [n mod 10] 
else []

annotated:
let rec digitsOfInt : int -> int list = fun Helper n  ->  
if n > 0 digitsOfIntHelper (n/10) @ [n mod 10] 
else []


fix:
let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence sumList (digits n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n = 0 then 0
else 1 + additivePersistence sumList (digits n)


fix:
let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence (sumList digits n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n = 0 then 0
else 1 + additivePersistence (sumList digits n)


fix:
let rec digitsOfInt n = 
if n > 0 then 
let k = digitsOfInt (n/10) in
(n mod 10) :: k
else []

bad:
let rec digitsOfInt n = 
if n > 0 then 
let k = digitsOfInt (n/10) in
k :: (n mod 10)
else []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then 
let k = digitsOfInt (n/10) in
k :: (n mod 10)
else []


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x == y then palindromeHelper s t
| _ -> false)
| _ -> false

annotated:
let palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x == y then palindromeHelper s t
| _ -> false)
| _ -> false


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)

annotated:
let palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then  palindromeHelper s t
| _ -> false)

annotated:
let rec palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then  palindromeHelper s t
| _ -> false)


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then  palindromeHelper s t
| _ -> false)

annotated:
let rec palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then  palindromeHelper s t
| _ -> false)


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)

annotated:
let rec palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)
| _ -> false

annotated:
let rec palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)
| _ -> false


fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t
| _ -> false)
| _ -> false

annotated:
let rec palindrome : string -> bool = fun Helper w r  ->  
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t
| _ -> false)
| _ -> false


fix:
let palindrome w = 
let wl = explode w in
let rl = listReverse wl in
palindromeHelper wl rl

bad:
let _ = palindrome "malayalam"

annotated:
let _ = palindrome "malayalam"


fix:
let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result in []

bad:
let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let result = [] in 
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result


fix:
let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result in []

bad:
let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result in 


let _ = digitsOfInt 100

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let result = [] in 
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result in 


let _ = digitsOfInt 100


fix:
let rec digitsOfInt n = 
let rec digitsOfIntHelper n result = 
if n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)
else result in 
digitsOfIntHelper n []

bad:
let rec digitsOfInt n = 
let rec digitsOfIntHelper n result = 
if n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result
else result in 
digitsOfIntHelper n []

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
let rec digitsOfInt : int -> int list = fun  n  ->  
if n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result
else result in 
digitsOfIntHelper n []


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates
[1;6;2;4;12;2;13;6;9]
[1;6;2;4;12;13;9]

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates
[1;6;2;4;12;2;13;6;9]
[1;6;2;4;12;13;9]


fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average x y -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times x y -> exprToString x + "*" + exprToString y
| Thresh a b c d -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average x y -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times x y -> exprToString x + "*" + exprToString y
| Thresh a b c d -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d


fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average (x,y) -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times x y -> exprToString x + "*" + exprToString y
| Thresh a b c d -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average (x,y) -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times x y -> exprToString x + "*" + exprToString y
| Thresh a b c d -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d


fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average (x,y) -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times (x,y) -> exprToString x + "*" + exprToString y
| Thresh (a,b,c,d) -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average (x,y) -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times (x,y) -> exprToString x + "*" + exprToString y
| Thresh (a,b,c,d) -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d


fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" exprToString c ^ ":" ^ exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" exprToString c ^ ":" ^ exprToString d


fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x + "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^"?" exprToString c ^ ":" ^ exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x + "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^"?" exprToString c ^ ":" ^ exprToString d


fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^"?" exprToString c ^ ":" ^ exprToString d

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^"?" exprToString c ^ ":" ^ exprToString d


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t) ? (eval u) : (eval v))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t) ? (eval u) : (eval v))


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? (eval u) : (eval v)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? (eval u) : (eval v)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? eval u : eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? eval u : eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> (eval s) < (eval t) ? eval u : eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> (eval s) < (eval t) ? eval u : eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval u
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval u
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi 
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi 
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi .* (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi .* (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi * (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi * (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u) * 1 * 1
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u) * 1 * 1
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v


fix:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))
| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))

bad:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))
| 3 -> Times (build (rand, depth-1)) (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  ->  
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))
| 3 -> Times (build (rand, depth-1)) (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1))


fix:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))
| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))

bad:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))
| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  ->  
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))
| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))


fix:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))
| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))

bad:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  ->  
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = sum + x*x in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = sum + x*x in
let base = 0 in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = f x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = let f x = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = let f x = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f -> x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = f -> x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = f x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = fun x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = (fun x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = f in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = 0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a x in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = a in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x in
let base = a in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a -> x in
let base = fun f x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = a -> x in
let base = fun f x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x  in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x in
let base = fun f x  in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> x in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun a -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> fun a -> x in
let base =  fun a -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun f -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> fun a -> x in
let base =  fun f -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun f in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> fun a -> x in
let base =  fun f in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  f x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> fun a -> x in
let base =  f x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun a -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun y -> fun a -> x in
let base =  fun a -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base =  fun a -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun x -> a in
let base =  fun a -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base =  fun a -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base =  fun a -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base =  0 in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base =  0 in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base =  f -> b in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = fun a -> a x in
let base =  f -> b in
List.fold_left f base fs


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = [] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = fun c -> a ^ sep ^ x in
let base = "" in
let l = l in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = fun c -> a ^ sep ^ x in
let base = "" in
let l = l in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = [] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = fun c -> a ^ sep ^ x in
let base = "" in
let l = "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = fun c -> a ^ sep ^ x in
let base = "" in
let l = "" in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = [] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = "" in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = "" in
List.fold_left f base l


fix:
let padZero l1 l2 = 
let leng1 = List.length l1 in
let leng2 = List.length l2 in
(clone 0 (leng1-leng2) @ l1 , clone 0 (leng2-leng1) @ l2)

bad:
let padZero l1 l2 = 
let leng1 = List.length l1 in
let leng2 = List.length l2 in
(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let leng1 = List.length l1 in
let leng2 = List.length l2 in
(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = l1  in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = l1  in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = l1  in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = l1  in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = [] in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = [] in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = [] in
let args = ([], []) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = [] in
let args = ([], []) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = ([], []) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = ([], []) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = 0 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = 0 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [[],[]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [[],[]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([]) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = ([]) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x.first in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  x.first in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a.first + x.first, a.second + x.second) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (a.first + x.first, a.second + x.second) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a, a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (a, a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a, x) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (a, x) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a + x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + x.first in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a + x.first in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a + x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  [a] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  [a] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + 1 in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a + 1 in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a, a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (a, a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  ([a], a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  ([a], a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a[0] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a[0] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = 0 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = 0 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + 1 in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a + 1 in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + 1 in
let base = 5 in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a + 1 in
let base = 5 in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  [5],[5] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  [5],[5] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a.first,a.second in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a.first,a.second in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a.fst,a.snd in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  a.fst,a.snd in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = (List.rev l1, List.rev l2) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = (List.rev l1, List.rev l2) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = (List.rev l1, []) in
let args = [List.rev l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = (List.rev l1, []) in
let args = [List.rev l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9] [1;0;0;2]

annotated:
let _ = bigAdd [9;9] [1;0;0;2]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = bigAdd [9;9;9;9] [9;9;9]

annotated:
let _ = bigAdd [9;9;9;9] [9;9;9]


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> []. snd a
| h:t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| []  -> []. snd a
| h:t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> []. snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| []  -> []. snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> [], snd snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| []  -> [], snd snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match fst a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match fst a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev (List.combine (l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev (List.combine (l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev (List.combine (l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev (List.combine (l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = (List.combine (l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = (List.combine (l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.combine (l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.combine (l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.combine (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.combine (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1, l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1, l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = [0, 0] in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in 
let base = (0, []) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = (0, 0) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = (0, 0) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in 
let base = (0, []) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = (0, []) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = (0, []) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
(*let (_, res) = List.fold_left f base args in
res*)
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
(*let (_, res) = List.fold_left f base args in
res*)
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
(*let (_, res) = List.fold_left f base args in
res*)
(*in*) 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
(*let (_, res) = List.fold_left f base args in
res*)
(*in*) 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "3232" in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = failwith "3232" in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| _ -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| () -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| () -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| [] -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| ([]) -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| ([]) -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| 5 -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| 5 -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| 'a' -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| 'a' -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (_, _) -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with
| (_, _) -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, (fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, (fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))


fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
let f x a = let digitRes = (x * i) + fst a in
digitRes / 10, (digitRes mod 10) :: snd a in
let base  = (0, []) in
let (_, result) = List.fold_right f (0 :: l) base in
result

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let f x a = let digitRes = (x * i) + fst a in
digitRes / 10, (digitRes mod 10) :: snd a in
let base  = (0, []) in
let (_, result) = List.fold_right f (0 :: l) base in
result


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value (snd a) in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value (snd a) in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x in 
let base = ([], []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x in 
let base = ([], []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value x :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value x :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd x value :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd x value :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value (snd a) in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value (snd a) in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res


fix:
let rec sumList xs =
match xs with
[] -> []
| head::tail -> head + (sumList tail)

bad:
let rec sumList xs =
match xs with
[] -> []
| head::tail- > head + (sumList tail)

annotated:
let rec sumList : int list -> int = fun  xs  -> 
match xs with
[] -> []
| head::tail- > head + (sumList tail)


fix:
let rec sumList xs =
match xs with
[] -> 0
| head::tail -> head + (sumList tail)

bad:
let _ = sumList [1; 2; 3; 4]

annotated:
let _ = sumList [1; 2; 3; 4]


fix:
let rec listReverse l = 
match l with 
[] -> []
| head::tail -> listReverse tail @ [head]

bad:
let _ = listReverse [1; 2; 3; 4]

annotated:
let _ = listReverse [1; 2; 3; 4]


fix:
let rec listReverse l = 
match l with 
[] -> []
| head::tail -> listReverse tail @ [head]

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]

annotated:
let _ = listReverse ["a"; "b"; "c"; "d"]


fix:
let rec append_new xs1 xs2= 
match xs1 with
[] -> xs2
| head::tail -> head::(append_new tail xs2)

bad:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)):(eval(var0, x, y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)):(eval(var0, x, y)))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)) : (eval(var0, x, y)))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)) : (eval(var0, x, y)))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
)

annotated:
)


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (.(eval(var3, x, y) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (.(eval(var3, x, y) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> .((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> .((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (.(eval(var3, x, y)) + eval(var4, x, y))/2
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (.(eval(var3, x, y)) + eval(var4, x, y))/2
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))


fix:
let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX()
| 1 -> buildY()
else let recurse = (rand 0 5) in match recurse with
| 0 -> buildSine(build(rand, depth-1))
| 1 -> buildCosine(build(rand, depth-1))
| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX
| 1 -> buildY

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX
| 1 -> buildY


fix:
let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX()
| 1 -> buildY()
else let recurse = (rand 0 5) in match recurse with
| 0 -> buildSine(build(rand, depth-1))
| 1 -> buildCosine(build(rand, depth-1))
| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX()
| 1 -> buildY()
else 
(*
call rand get some number
switch statement to choose
1 then return expr x
0 then return expr y
*)


(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = failwith "to be implemented"

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX()
| 1 -> buildY()
else 
(*
call rand get some number
switch statement to choose
1 then return expr x
0 then return expr y
*)


(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = failwith "to be implemented"


fix:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index))))

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index))))


fix:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

annotated:
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9] [9;9;9;9]


fix:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

annotated:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]


fix:
let padZero l1 l2 = 
let lenl1 = List.length l1 in 
let lenl2 = List.length l2 in 
((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))

bad:
let padZero l1 l2 = 
let lenl1 = List.length l1 in 
let lenl2 = List.length l2 in 
(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let lenl1 = List.length l1 in 
let lenl2 = List.length l2 in 
(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| isNotP n ->[]
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| isNotP n ->[]
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| if isNotP n ->[]
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| if isNotP n ->[]
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| if isNotP n then n->[]
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| if isNotP n then n->[]
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| isNotP n then n->[]
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| isNotP n then n->[]
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| if isNotP n then []
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| if isNotP n then []
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| if isNotP n =true then []
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| if isNotP n =true then []
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| if n<=0 then []
| explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| if n<=0 then []
| explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| if n<=0 then []
| else explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  match n with
| if n<=0 then []
| else explode (string_of_int n)


fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = 
| if n<=0 then []
| else explode (string_of_int n)

annotated:
let rec digitsOfInt : int -> int list = fun  n  ->  
| if n<=0 then []
| else explode (string_of_int n)


fix:
let rec additivePersistence n = 

sumList (digitsOfInt n)

bad:
let rec additivePersistence n = sumList digitOfInt n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  sumList digitOfInt n


fix:
let rec additivePersistence n = 

sumList (digitsOfInt n)

bad:
let rec additivePersistence n = 

sumList (digitOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  

sumList (digitOfInt n)


fix:
let rec additivePersistence n = 
if n<10 then a
else  additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = match n with
if n<10 then n
else  _=sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  match n with
if n<10 then n
else  _=sumList (digitsOfInt n)


fix:
let rec additivePersistence n = 
if n<10 then a
else  additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = match n with
if n<10 then n
else  n=sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  match n with
if n<10 then n
else  n=sumList (digitsOfInt n)


fix:
let rec additivePersistence n = 
if n<10 then a
else  additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
if n<10 then n
else  n=sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n<10 then n
else  n=sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n


fix:
let rec additivePersistence n = 
if n<10 then a
else  additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
if n<10 then n
else  sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
if n<10 then n
else  sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n


fix:
let rec additivePersistence n = 
if n<10 then a
else  additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n a= 
if n<10 then a
else  sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n

annotated:
let rec additivePersistence : int -> int = fun  n a ->  
if n<10 then a
else  sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n


fix:
let rec additivePersistence n = 
let c=0 in
let rec break(num,count)=
if num>9 then
break(sumList(digitsOfInt(num)),(count+1))
else
count
in
break(n,c)

bad:
let rec additivePersistence n = 
let c=0 in
let rec break(num,count)=
if num>9
break(sumList(digitsOfInt(num)),(count+1))
else
count
in
break(n,c)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
let c=0 in
let rec break(num,count)=
if num>9
break(sumList(digitsOfInt(num)),(count+1))
else
count
in
break(n,c)


fix:
let rec listReverse l = 
let rec a acc=function
|[]-> acc
|h::t -> a(h::acc) t in
a [] l

bad:
let rec listReverse l = 
let rec a acc=function
|[]-> acc
|h::t -> a(h::acc) t in
a [] list

annotated:
let rec listReverse : 'a list -> 'a list = fun  l  ->  
let rec a acc=function
|[]-> acc
|h::t -> a(h::acc) t in
a [] list


fix:
let palindrome w = 
if explode w = listReverse (explode w) then true
else false

bad:
let palindrome w = 
if explode w = listReverse (explode w)

annotated:
let palindrome : string -> bool = fun  w  ->  
if explode w = listReverse (explode w)


fix:
let rec assoc (d,k,l) = match l with
|(s,n)::t -> if s=k then n
else assoc(d,k,t)
|[]->d

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
| (x,true) -> f x
| (x,false) -> x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
| (x,true) -> f x
| (x,false) -> x


fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
|(x,true) -> wwhile(f x)
| (x,false) -> x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
|(x,true) -> wwhile(f x)
| (x,false) -> x


fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
let (n,boo) = f b
| boo=true -> wwhile(f,n)
| boo=false -> n

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
let (n,boo) = f b
| boo=true -> wwhile(f,n)
| boo=false -> n


fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
(n,boo) -> f b
| boo=true -> wwhile(f,n)
| boo=false -> n

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
(n,boo) -> f b
| boo=true -> wwhile(f,n)
| boo=false -> n


fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
(n,boo) -> f b
if boo= true then wwhile(f,n)
else n

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
(n,boo) -> f b
if boo= true then wwhile(f,n)
else n


fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
(n,boo) -> f b

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with
(n,boo) -> f b


fix:
let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

bad:
let rec wwhile (f,b) = match f with 
let (i,r) = f b in
| r=true -> wwhile (f,i)
| r=false ->i

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with 
let (i,r) = f b in
| r=true -> wwhile (f,i)
| r=false ->i


fix:
let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

bad:
let rec wwhile (f,b) = match f with 
let rec (i,r) = f b in
| r=true -> wwhile (f,i)
| r=false ->i

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with 
let rec (i,r) = f b in
| r=true -> wwhile (f,i)
| r=false ->i


fix:
let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

bad:
let rec wwhile (f,b) = 
let  (x,y) = f b in
match (x,y) with 
| y=true -> wwhile (f,x)
| y=false -> x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let  (x,y) = f b in
match (x,y) with 
| y=true -> wwhile (f,x)
| y=false -> x


fix:
let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

bad:
let rec wwhile (f,b) = 
let  (x,y) = f b in
match (x,y) with 
| y -> wwhile (f,x)
| !y -> x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let  (x,y) = f b in
match (x,y) with 
| y -> wwhile (f,x)
| !y -> x


fix:
let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

bad:
let rec wwhile (f,b) = 
let  (x,y) = f b in
match (x,y) with 
if y then wwhile (f,x)
else x

annotated:
let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  
let  (x,y) = f b in
match (x,y) with 
if y then wwhile (f,x)
else x


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f b-1 then (b,false)),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f b-1 then (b,false) in f),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in ),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f (b-1) then (b,false) in ),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f (b-1) then (b,false) in f),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<>b && (x,y)<>f (b-1))),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<>b)),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y)= f b in (x, x! -> b)),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x>b||x<b)),b)


fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<100)),b)


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY"/"VarX
| Cosine -> VarX"/"VarY

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY"/"VarX
| Cosine -> VarX"/"VarY


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY@"/"@VarX
| Cosine -> VarX@"/"@VarY

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY@"/"@VarX
| Cosine -> VarX@"/"@VarY


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY^"/"^VarX
| Cosine -> VarX^"/"^VarY

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY^"/"^VarX
| Cosine -> VarX^"/"^VarY


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString e
| Cosine -> exprToString e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString e
| Cosine -> exprToString e


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString e
| Cosine -> exprToString e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString e
| Cosine -> exprToString e


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString VarX
| Cosine -> exprToString e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString VarX
| Cosine -> exprToString e


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine -> exprToString e

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine -> exprToString e


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e1 e2 ->"("^(exprToString e1)^"+"^(exprToString e2)^")/2"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e1 e2 ->"("^(exprToString e1)^"+"^(exprToString e2)^")/2"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e1 e ->"("^(exprToString e1)^"+"^(exprToString e)^")/2"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e1 e ->"("^(exprToString e1)^"+"^(exprToString e)^")/2"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e e ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e e ->"("^(exprToString e)^"+"^(exprToString e)^")/2"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e ->"("^(exprToString e)^"+"^(exprToString e)^")/2"


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

annotated:
let rec exprToString : expr -> string = fun  e  ->  match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"


fix:
let aa =exprToString VarX

bad:
let aa = exprToString Average(VarX, VarY)

annotated:
let aa = exprToString Average(VarX, VarY)


fix:
let aa =exprToString VarX

bad:
let aa =exprToString Average(VarX, VarY)

annotated:
let aa =exprToString Average(VarX, VarY)


fix:
let aa =exprToString VarX

bad:
let aa =exprToString VarX;

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

annotated:
let aa =exprToString VarX;

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))


fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e1)^"+"^(exprToString e2)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"

bad:
let aa =exprToString Average(VarY,VarX)

annotated:
let aa =exprToString Average(VarY,VarX)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine -> buildSine(e)

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine -> buildSine(e)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> buildSine(e)

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> buildSine(e)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> buildSine(x)

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> buildSine(x)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e1-> buildSine(e1)

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e1-> buildSine(e1)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e1-> buildSine(e1)

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e1-> buildSine(e1)


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> 0.34*e

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> 0.34*e


fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> build(pi*e)

annotated:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> build(pi*e)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = (-:float) match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  (-:float) match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = (float) match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  (float) match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| (float) VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| (float) VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x:float
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x:float
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x of float
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x of float
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (e1+.e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (e1+.e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (e1.+.e2.)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (e1.+.e2.)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (float)(e1+e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (float)(e1+e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2
| Times (e1, e2)-> float_of_int e1*.float_of_int e2
| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2
| Times (e1, e2)-> float_of_int e1*.float_of_int e2
| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> if e1=VarX then e1=x else e1=y if e2=VarX then e2=x else e2=y -> (e1+e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> if e1=VarX then e1=x else e1=y if e2=VarX then e2=x else e2=y -> (e1+e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x.
| Cosine e-> pi*.y.
| Average (e1,e2) -> buildAverage(e1,e2)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x.
| VarY -> y.
| Sine e -> pi*.x.
| Cosine e-> pi*.y.
| Average (e1,e2) -> buildAverage(e1,e2)

annotated:
let rec eval (e,x,y) =
match e with
| VarX -> x.
| VarY -> y.
| Sine e -> pi*.x.
| Cosine e-> pi*.y.
| Average (e1,e2) -> buildAverage(e1,e2)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)
| Thresh (e1,e2,e3,e4) ->((eval(e1,x,y))<(eval(e2,x,y)) ? (eval(e3,x,y)) : (eval(e4,x,y))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)
| Thresh (e1,e2,e3,e4) ->((eval(e1,x,y))<(eval(e2,x,y)) ? (eval(e3,x,y)) : (eval(e4,x,y))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval( e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval( e4,x,y))


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?(eval(e3,x,y)):(eval(e4,x,y))
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?(eval(e3,x,y)):(eval(e4,x,y))
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y):.eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y):.eval(e4,x,y))


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y) : eval(e4,x,y))

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y) : eval(e4,x,y))


fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  -> 
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y)


fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
let rec helper(d1,k1,l1) = match l1 with
|(s,n)::t -> if s=k1 then n
else assoc(d1,k1,t)
|[]->d1
in helper(d,k,l)

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper(d1,k1,l1) = match l1 with
|(s,n)::t -> if s=k1 then n
else assoc(d1,k1,t)
|[]->d1
in helper(d,k,l)


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)

annotated:
let _ = eval (sampleExpr1,0.5,0.2)


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec build (rand, depth) = match rand depth with

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec build (rand, depth) = 
match rand depth with
| (1,d) -> d=(d-1) && buildX()
| (2,d) -> d=(d-1) && buildY()

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
match rand depth with
| (1,d) -> d=(d-1) && buildX()
| (2,d) -> d=(d-1) && buildY()


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec build (rand, depth) = match rand depth with

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec build (rand, depth) = 
let build(r) = if r=1 then buildX() else buildY() in (depth-1,depth>0)
in build(r)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 1 then buildX() else buildY() in (depth-1,depth>0)
in build(r)


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec build (rand, depth) = match rand depth with
if r=1 then buildX() else buildY() in (depth-1,depth>0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with
if r=1 then buildX() else buildY() in (depth-1,depth>0)


fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec build (rand, depth) = match rand depth with
if rand=1 then buildX() else buildY() in (depth-1,depth>0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with
if rand=1 then buildX() else buildY() in (depth-1,depth>0)


fix:
let rec assoc (d,k,l) = 
let rec helper(d1,k1,l1) = match l1 with
|(s,n)::t -> if s=k1 then n
else assoc(d1,k1,t)
|[]->d1
in helper(d,k,l)

bad:
let rec build (rand, depth) = match rand depth with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> match r(0,7) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,depth)-> match r(0,7) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> match r(0,7) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,depth)-> match r(0,7) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(_,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(_,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0)

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)


fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base = h^sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = List.rev x^a in
let base = sep in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = List.rev x^a in
let base = sep in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base = h^sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = List.rev t^a in
let base = h^sep in
let l = sl in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = List.rev t^a in
let base = h^sep in
let l = sl in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ (x^a)in
let base = h^sep in
let l = List.rev t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ (sepConcat a x)in
let base = h^sep in
let l = List.rev t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ (sepConcat a x)in
let base = h^sep in
let l = List.rev t in
List.fold_left f base l


fix:
let _ = sumList [1; 3; 5; 7; 9; 11];

string_of_int(32)

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]

int_of_string(32)

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11]

int_of_string(32)


fix:
let _ = sumList [1; 3; 5; 7; 9; 11];

string_of_int(32)

bad:
let _ = sumList [1; 3; 5; 7; 9; 11];

int_of_string(32)

annotated:
let _ = sumList [1; 3; 5; 7; 9; 11];

int_of_string(32)


fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ [(n mod 10)]

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 
then []
else match n with
| n -> [] @ (n mod 10)


fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ [(n mod 10)]

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] :: (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 
then []
else match n with
| n -> [] :: (n mod 10)


fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ [(n mod 10)]

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ (n mod 10)

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 
then []
else match n with
| n -> [] @ (n mod 10)


fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> n mod 10 :: []

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n % 10) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n % 10) :: []


fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> n mod 10 :: []

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n mod 10) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n mod 10) :: []


fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> n mod 10 :: []

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n mod 10) :: []

annotated:
let rec digitsOfInt : int -> int list = fun  n  -> 
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n mod 10) :: []


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let digitsOfInt n = 
let rec addDigit next n = 
if n < 0 then []
else addDigit ((n mod 10)::next) (n/10)

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec addDigit next n = 
if n < 0 then []
else addDigit ((n mod 10)::next) (n/10)


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
) in 
addDigit [] n

annotated:
) in 
addDigit [] n


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let digitsOfInt n = 
let rec addDigit next n = 
if n < 0 then []
else addDigit ((n mod 10)::next) (n/10)

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec addDigit next n = 
if n < 0 then []
else addDigit ((n mod 10)::next) (n/10)


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let digitsOfInt n = 
let rec addDigit next n = 
if n < 10 then n::next
else addDigit ((n mod 10)::next) (n/10)

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec addDigit next n = 
if n < 10 then n::next
else addDigit ((n mod 10)::next) (n/10)


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

annotated:
let digitsOfInt : int -> int list = fun  n  ->  
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let digitsOfInt n = 
if n <= 0 then []
else let rec addDigit n acc = 
if n <= 0 then acc
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let _ = digitsOfInt 3124

annotated:
let _ = digitsOfInt 3124


fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n <= 0 then acc
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

bad:
let _ = digitsOfInt (-3124)

annotated:
let _ = digitsOfInt (-3124)


fix:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> additivePersistence sumList (digitsOfInt n)

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match n with
| 0 -> 0
| _ -> additivePersistence sumList (digitsOfInt n)


fix:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> additivePersistence (sumList (digitsOfInt n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match n with
| 0 -> 0
| _ -> additivePersistence (sumList (digitsOfInt n))


fix:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> (sumList (digitsOfInt n))

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

bad:
let rec additivePersistence n = 
match n with
| _ -> (sumList (digitsOfInt n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match n with
| _ -> (sumList (digitsOfInt n))


fix:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

bad:
let rec additivePersistence n = 
match n with
| _ -> additivePersistence(sumList (digitsOfInt n))

annotated:
let rec additivePersistence : int -> int = fun  n  ->  
match n with
| _ -> additivePersistence(sumList (digitsOfInt n))


fix:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

bad:
let _ = additivePersistence 9876

annotated:
let _ = additivePersistence 9876


fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence sumDigits n count+1
else count
in count = 0

annotated:
let additivePersistence : int -> int = fun  n  ->  
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence sumDigits n count+1
else count
in count = 0


fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence sumDigits n (count+1)
else count
in count = 0

annotated:
let additivePersistence : int -> int = fun  n  ->  
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence sumDigits n (count+1)
else count
in count = 0


fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence (sumDigits n) count+1
else count
in count = 0

annotated:
let additivePersistence : int -> int = fun  n  ->  
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence (sumDigits n) count+1
else count
in count = 0


fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence sumDigits n count+1
else count
in count = 0

annotated:
let additivePersistence : int -> int = fun  n  ->  
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence sumDigits n count+1
else count
in count = 0


fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count
in count = 0

annotated:
let additivePersistence : int -> int = fun  n  ->  
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count
in count = 0


fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count

annotated:
let additivePersistence : int -> int = fun  n  ->  
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec reverse l acc = 
reverse l acc in
match l with
| [] -> []
| hd::tl -> reverse l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec reverse l acc = 
reverse l acc in
match l with
| [] -> []
| hd::tl -> reverse l []


fix:
let digitsOfInt n = 
let rec lastDigit n accu = 
if n <= 0 then accu
else lastDigit (n/10) (n mod 10::accu) in
match n with
| _ -> lastDigit n []

bad:
let rec digitalRoot n =
match n with
| _ -> 
if lengthOfList (digitsOfInt n) 0 = 1 then n
else digitalRoot (sumList (digitsOfInt n))

annotated:
let rec digitalRoot n =
match n with
| _ -> 
if lengthOfList (digitsOfInt n) 0 = 1 then n
else digitalRoot (sumList (digitsOfInt n))


fix:
let digitsOfInt n = 
let rec lastDigit n accu = 
if n <= 0 then accu
else lastDigit (n/10) (n mod 10::accu) in
match n with
| _ -> lastDigit n []

bad:
let _ = digitalRoot 9876

annotated:
let _ = digitalRoot 9876


fix:
let digitsOfInt n = 
let rec lastDigit n accu = 
if n <= 0 then accu
else lastDigit (n/10) (n mod 10::accu) in
match n with
| _ -> lastDigit n []

bad:
let listReverse l = 
let rec accReverse l acc =
match l with
| [] -> acc
| hd::tl -> accReverse tl (hd::acc)

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec accReverse l acc =
match l with
| [] -> acc
| hd::tl -> accReverse tl (hd::acc)


fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec accReverse l accu =
match l with
| [] -> accu
| hd::tl -> accReverse tl (hd::accu)
in accReverse l []

annotated:
let listReverse : 'a list -> 'a list = fun  l  ->  
let rec accReverse l accu =
match l with
| [] -> accu
| hd::tl -> accReverse tl (hd::accu)
in accReverse l []


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = fun x -> (explode s = listReverse(explode s))

annotated:
let palindrome : string -> bool = fun  w = fun x -> (explode s  ->  listReverse(explode s))


fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = fun x -> (explode w = listReverse(explode w))

annotated:
let palindrome : string -> bool = fun  w = fun x -> (explode w  ->  listReverse(explode w))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
l

annotated:
l


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
l

annotated:
l


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not List.mem seen h then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not (List.mem seen h) then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not (List.mem seen h) then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
l

annotated:
l


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not (List.mem seen h) then
let seen' = h::rest in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

annotated:
let removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not (List.mem seen h) then
let seen' = h::rest in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
l

annotated:
l


fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = seen' in
let rest' = t in
else
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

annotated:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let rec assoc (d,k,l) = match l with
| (s,i):t -> if s = k then i
else assoc (d,k,t)
| [] -> d

annotated:
let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with
| (s,i):t -> if s = k then i
else assoc (d,k,t)
| [] -> d


fix:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (x,y)
| false -> x
in helper (f,b) (b, true)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f, x)
| false -> x
in (f,b) (b, true)

annotated:
let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f, x)
| false -> x
in (f,b) (b, true)


fix:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (x,y)
| false -> x
in helper (f,b) (b, true)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (x,y)
| false -> x
in (f,b) (b, true)

annotated:
let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (x,y)
| false -> x
in (f,b) (b, true)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) f b
| false -> x
in helper (f,b) (b, true)

annotated:
let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) f b
| false -> x
in helper (f,b) (b, true)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) f b
| false -> x
in helper (f,b) (b, true)

annotated:
let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) f b
| false -> x
in helper (f,b) (b, true)


fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (f b)
| false -> x
in helper (f,b) (b, true)

annotated:
let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> 
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (f b)
| false -> x
in helper (f,b) (b, true)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

annotated:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1


fix:
let fixpoint (f,b) = wwhile ((f f b),b)

bad:
let fixpoint (f,b) = wwhile ((f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((f (f b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f (f b)),b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((f b),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)


fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)


fix:
let fixpoint (f,b) = wwhile (f,f b)

bad:
let fixpoint (f,b) = wwhile ((wwhile (f b)),b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((wwhile (f b)),b)


fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (f,(f b))

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,(f b))


fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)


fix:
let fixpoint (f,b) = 
wwhile (f, if b = (f b) then b else b)

bad:
let fixpoint (f,b) = 
let f x = xx = (f x) in (xx, xx != b) in f in
wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = xx = (f x) in (xx, xx != b) in f in
wwhile (f,b)


fix:
let fixpoint (f,b) = 
wwhile (f, if b = (f b) then b else b)

bad:
let fixpoint (f,b) = 
let f x = xx = (f x) in (xx, xx != b) in f
wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = xx = (f x) in (xx, xx != b) in f
wwhile (f,b)


fix:
let fixpoint (f,b) = 
wwhile (f, if b = (f b) then b else b)

bad:
let fixpoint (f,b) = 
let f x = let xx = (f x) in (xx, xx != b) in f
wwhile (f,b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = let xx = (f x) in (xx, xx != b) in f
wwhile (f,b)


fix:
let fixpoint (f,b) = 
wwhile (f, if b = (f b) then b else b)

bad:
let fixpoint (f,b) = 
let f x = let xx = (f x) in (xx, xx != b) in f

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let f x = let xx = (f x) in (xx, xx != b) in f


fix:
let f b = f -> f;
let fixpoint (f,b) = 
wwhile (
, b)

bad:
let fixpoint (f,b) = 
wwhile (f, if b = (f(b)) then b else b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
wwhile (f, if b = (f(b)) then b else b)


fix:
let f b = f -> f;
let fixpoint (f,b) = 
wwhile (
, b)

bad:
let fixpoint (f,b) = wwhile (f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f, b)


fix:
let fixpoint (f,b) = 
let g b = (b, (f b)) in 
wwhile (g, b)

bad:
let fixpoint (f,b) = 
let g b = b in 
wwhile ((g), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g b = b in 
wwhile ((g), b)


fix:
let fixpoint (f,b) = 
let g b = (b, (f b)) in 
wwhile (g, b)

bad:
let fixpoint (f,b) = 
let g b = b in 
wwhile (g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g b = b in 
wwhile (g, b)


fix:
let fixpoint (f,b) = 
let g b = (b, (f b)) in 
wwhile (g, b)

bad:
let fixpoint (f,b) = 
let g b = b in 
wwhile ((g,true), b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g b = b in 
wwhile ((g,true), b)


fix:
let fixpoint (f,b) = 
let g b = (b, (f b)) in 
wwhile (g, b)

bad:
let fixpoint (f,b) = 
let g b = b, (f b) in 
wwhile (g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g b = b, (f b) in 
wwhile (g, b)


fix:
let fixpoint (f,b) = 
if b != f b then
let f b = b, (f b) in
wwhile(f, b)
else b

bad:
let fixpoint (f,b) = 
let g x = b, (f b) in (b = (f b)) in 
wwhile (g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
let g x = b, (f b) in (b = (f b)) in 
wwhile (g, b)


fix:
let fixpoint (f,b) = 
if b != f b then
let f b = b, (f b) in
wwhile(f, b)
else b

bad:
let fixpoint (f,b) = 
if b != f b then
let f x = b, (f b) in
wwhile(f, b)
else b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
if b != f b then
let f x = b, (f b) in
wwhile(f, b)
else b


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let fixpoint (f,b) = 
if b != f b then
let b = f b in
wwhile(f, b)
else b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  
if b != f b then
let b = f b in
wwhile(f, b)
else b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != f b then
wwhile(f, f b)
else
b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b != f b then
wwhile(f, f b)
else
b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != (f b) then
wwhile(f, f b)
else
b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b != (f b) then
wwhile(f, f b)
else
b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != (f b) then
let f = (f, true) in
wwhile(f, f b)
else
b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b != (f b) then
let f = (f, true) in
wwhile(f, f b)
else
b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != (f b) then
let f = (f b, true) in
wwhile(f, f b)
else
b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b != (f b) then
let f = (f b, true) in
wwhile(f, f b)
else
b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != (f b) then
let f b = (b, true) in
wwhile(f, f b)
else
b

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b != (f b) then
let f b = (b, true) in
wwhile(f, f b)
else
b


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != (f b) then
let f b = (b, true) in
wwhile(f, f b)
else
wwhile(f b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b != (f b) then
let f b = (b, true) in
wwhile(f, f b)
else
wwhile(f b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b = f b then
f b
else
let g b = (f b, true) in
wwhile(g, f b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
if b = f b then
f b
else
let g b = (f b, true) in
wwhile(g, f b)


fix:
let fixpoint (f,b) =
let g b = (f b, (b = f b)) in
wwhile(g, f b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

annotated:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let fixpoint (f,b) =
let g x = (f b, (b = f b)) in
wwhile(g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let g x = (f b, (b = f b)) in
wwhile(g, b)


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let fixpoint (f,b) =
let g x = (f b, (b != f b)) in
wwhile(g, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let g x = (f b, (b != f b)) in
wwhile(g, b)


fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

annotated:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)


fix:
let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(y, b)

bad:
let fixpoint (f,b) =
let y x= (f b, (b = f b)) in
wwhile(y b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let y x= (f b, (b = f b)) in
wwhile(y b, b)


fix:
let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(y, b)

bad:
let fixpoint (f,b) =
let y x= (f b, (b = f b)) in
wwhile(y, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let y x= (f b, (b = f b)) in
wwhile(y, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let y = f b in (y, (b = f b)) in
wwhile(f, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(y, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let y = f b in (y, (b = f b)) in
wwhile(y, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let y = f b in (y, (b = f b)) in
wwhile(y, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let y = f b in (y, (b  ->  f b)) in
wwhile(y, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let y = f b in (y, (b = f b)) in
wwhile(f b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let y = f b in (y, (b  ->  f b)) in
wwhile(f b, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = let y x = f b in (y, (b = f b)) in
wwhile(y, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let y x = f b in (y, (b  ->  f b)) in
wwhile(y, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let y x = (f b, (b = f b)) in
wwhile(y, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let y x = (f b, (b = f b)) in
wwhile(y, b)


fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let f x = (f b, (b = f b)) in
wwhile(f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f x = (f b, (b = f b)) in
wwhile(f, b)


fix:
let fixpoint (f,b) =
let f x = (f b, (f b = b)) in
wwhile(f, b)

bad:
let fixpoint (f,b) =
let f x = (f, (f b = b)) in
wwhile(f, f b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f x = (f, (f b = b)) in
wwhile(f, f b)


fix:
let fixpoint (f,b) =
let f x = (f b, (f b = b)) in
wwhile(f, b)

bad:
let fixpoint (f,b) =
let f x = (f, (f b = b)) in
wwhile(f, x)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f x = (f, (f b = b)) in
wwhile(f, x)


fix:
let fixpoint (f,b) =
let f x = (f b, (f b = b)) in
wwhile(f, b)

bad:
let fixpoint (f,b) =
let f x = (f, (f b = b)) in
wwhile(f b, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f x = (f, (f b = b)) in
wwhile(f b, b)


fix:
let fixpoint (f,b) =
let f x = (f b, (f b = b)) in
wwhile(f, b)

bad:
let fixpoint (f,b) =
let f x = (f x, (f b = b)) in
wwhile(f, b)

annotated:
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> 
let f x = (f x, (f b = b)) in
wwhile(f, b)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi* eval e)
| Cosine e-> cos(pi* eval e)
| Average (e1,e2) -> (eval e1 + eval e2) / 2
| Times (e1,e2) -> eval e1 * eval e2
| Thresh (e1,e2,e3,e4) -> eval e1 < eval e2 ? eval e3 : eval e4

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi* eval e)
| Cosine e-> cos(pi* eval e)
| Average (e1,e2) -> (eval e1 + eval e2) / 2
| Times (e1,e2) -> eval e1 * eval e2
| Thresh (e1,e2,e3,e4) -> eval e1 < eval e2 ? eval e3 : eval e4


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval e)
| Cosine e-> cos(pi*. eval e)
| Average (e1,e2) -> (eval e1 +. eval e2) /. 2
| Times (e1,e2) -> eval e1 *. eval e2
| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval e)
| Cosine e-> cos(pi*. eval e)
| Average (e1,e2) -> (eval e1 +. eval e2) /. 2
| Times (e1,e2) -> eval e1 *. eval e2
| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)


fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)


fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)

annotated:
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)


fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let build (rand, depth) = 
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))
| 4 -> buildAverage(helper (e, rand, depth-1),helper (e, rand, depth-1))

annotated:
let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))
| 4 -> buildAverage(helper (e, rand, depth-1),helper (e, rand, depth-1))


fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let build (rand, depth) = 
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))

annotated:
let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))


fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let build (rand, depth) = 
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))

annotated:
let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))


fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))


fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,9) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 7 -> buildSquared(build(rand,depth-1))
| 8 -> buildRoot(build(rand,depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,9) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 7 -> buildSquared(build(rand,depth-1))
| 8 -> buildRoot(build(rand,depth-1))

annotated:
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,9) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 7 -> buildSquared(build(rand,depth-1))
| 8 -> buildRoot(build(rand,depth-1))


fix:
let _ = eval (Sine(VarX),pi,0.)

bad:
let _ = eval (Sine(VarX)),pi,0

annotated:
let _ = eval (Sine(VarX)),pi,0


fix:
let _ = eval (Sine(VarX),pi,0.)

bad:
)

annotated:
)


fix:
let _ = eval (Sine(VarX),pi,0.)

bad:
let _ = eval ((Sine(VarX)),pi,0)

annotated:
let _ = eval ((Sine(VarX)),pi,0)


fix:
let _ = eval (Sine(VarX),pi,0.)

bad:
let _ = eval ((Sine(VarX)),pi,0.)

annotated:
let _ = eval ((Sine(VarX)),pi,0.)


fix:
let sqsum xs = 
let f a x = (a*x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (fun f _ -> a*a) in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (fun f _ -> a*a) in
let base = 0 in
List.fold_left f base xs


fix:
let sqsum xs = 
let f a x = (a*a) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = () in
let base = 0 in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = () in
let base = 0 in
List.fold_left f base xs


fix:
let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]
let_ = sqsum [1;2;3]

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]
let_ = sqsum [1;2;3]


fix:
let sqsum xs = 
let f a x = (a+x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (a+x*x) in
let base = x in
List.fold_left f base xs

annotated:
let sqsum : int list -> int  = fun  xs  ->  
let f a x = (a+x*x) in
let base = x in
List.fold_left f base xs


fix:
let pipe fs = 
let f a x = (a+x) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = base in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = base in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = fs in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = fs in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = f in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = f in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = [] in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = [] in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = (fun a->a) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = (fun a->a) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = () in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = () in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a+x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f -> (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun x y) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun x y) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = fun f -> (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun x -> f (a x)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun x -> f (a x)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun f -> f (a x)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun f -> f (a x)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun f -> f (x)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun f -> f (x)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun f -> a(f x)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (fun f -> a(f x)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a (f x)) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a (f x)) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (x)a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (a x) in
let base = _ in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let pipe fs = 
let f a x = (a x) in
let base = _ in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (a x) in
let base = _ in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (x) in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = (x) in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (a x) in
let base = _ in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = () in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (a x) in
let base = () in
List.fold_left f base fs


fix:
let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

List.fold_left

annotated:
let _ = sqsum [(-1); (-2); (-3); (-4)]

List.fold_left


fix:
let pipe fs = 
let f a x = (x a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x x) in
let base = fun x -> x in
List.fold_left f base fs

annotated:
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  
let f a x = (x x) in
let base = fun x -> x in
List.fold_left f base fs


fix:
let pipe fs = 
let f a x = (fun y -> x (a y)) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

annotated:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = h in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = h in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = l in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = l in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep::sepConcat(sep t) in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep::sepConcat(sep t) in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^sepConcat(sep t) in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^sepConcat(sep t) in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^t in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^t in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat(sep t) in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat(sep t) in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sepConcat(h^sep t) in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = sepConcat(h^sep t) in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sepConcat h^sep t in
let base = "" in
let l = t in
List.fold_left f base l

annotated:
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = sepConcat h^sep t in
let base = "" in
let l = t in
List.fold_left f base l


fix:
let stringOfList f l = List.map sepConcat

bad:
let stringOfList f l = List.map sepConcat ""

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat ""


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat l "") f

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat l "") f


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat "" l) f

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" l) f


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat "" l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" l)


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" (f l))


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l))

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" (f l))


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat) f l

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat) f l


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l)) (f l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" (f l)) (f l)


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let _ = sepConcat "" ["foo"]

bad:
let _ = sepConcat ["foo"]

annotated:
let _ = sepConcat ["foo"]


fix:
let stringOfList f l = List.map (sepConcat) (l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l)) (l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" (f l)) (l)


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

annotated:
let _ = stringOfList string_of_int [1;2;3;4;5;6]


fix:
let stringOfList f l = List.map (sepConcat) (l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l)) (l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat "" (f l)) (l)


fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat) f(l)

annotated:
let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat) f(l)


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else x :: clone x n-1


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else x :: clone x n-1


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else x :: clone (x n-1)

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else x :: clone (x n-1)


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else x :: clone x n-1


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else clone x n-1


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else then x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else then x :: clone x n-1


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1

annotated:
let rec clone : 'a -> int -> 'a list = fun  x n  ->  
if n <= 0 then []
else x :: clone x n-1


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x n-1 x:acc
in helper x n []

annotated:
let clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper x n acc =
if n <= 0 then acc
else helper x n-1 x:acc
in helper x n []


fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x n-1 x::acc
in helper x n []

annotated:
let clone : 'a -> int -> 'a list = fun  x n  ->  
let rec helper x n acc =
if n <= 0 then acc
else helper x n-1 x::acc
in helper x n []


fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
List.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]
else
List.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
List.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]
else (List.length l1) > (List.length l2)
List.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if (List.length l1) < (List.length l2) then
List.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]
else (List.length l1) > (List.length l2)
List.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]


fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
([(clone 0 (List.length l2 - List.length l1)) @ l1], [l2])
else
([l1], [(clone 0 (List.length l1 - List.length l2)) @ [l2])

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if (List.length l1) < (List.length l2) then
([(clone 0 (List.length l2 - List.length l1)) @ l1], [l2])
else
([l1], [(clone 0 (List.length l1 - List.length l2)) @ [l2])


fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
([(clone 0 (List.length l2 - List.length l1)) @ l1], l2)
else
([l1], [(clone 0 (List.length l1 - List.length l2)) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if (List.length l1) < (List.length l2) then
([(clone 0 (List.length l2 - List.length l1)) @ l1], l2)
else
([l1], [(clone 0 (List.length l1 - List.length l2)) @ l2)


fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)


fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)
else
(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)
else
(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)

annotated:
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
if (List.length l1) < (List.length l2) then
((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)
else
(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)


fix:
let _ = stringOfList string_of_int [9;9]

bad:
let _ = stringOfList [9;9]

annotated:
let _ = stringOfList [9;9]


fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.rev List.combine( padZero([9;9] [1;0;0;2]))

annotated:
let _ = List.rev List.combine( padZero([9;9] [1;0;0;2]))


fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.rev (List.combine( padZero([9;9] [1;0;0;2])))

annotated:
let _ = List.rev (List.combine( padZero([9;9] [1;0;0;2])))


fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.rev (List.combine( padZero [9;9] [1;0;0;2]))

annotated:
let _ = List.rev (List.combine( padZero [9;9] [1;0;0;2]))


fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.combine(padZero [9;9] [1;0;0;2])

annotated:
let _ = List.combine(padZero [9;9] [1;0;0;2])


fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.rev(padZero [9;9] [1;0;0;2])

annotated:
let _ = List.rev(padZero [9;9] [1;0;0;2])


fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [0;0;0;0]

int_of_list [9;9]

annotated:
let _ = removeZero [0;0;0;0]

int_of_list [9;9]


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = xin

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = xin


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (a,b) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (a,b) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0,List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0,List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, l1) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, l1) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, []) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, []) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [l1,l2])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [l1,l2])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [ (3, [] ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [ (l1+l2, [] ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [ (l1+l2, [] ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x'::xs -> x' in
let base = (0, []) in
let args =  match l1 with
| h::t -> [[ (h, l2 ) ]] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x::xs -> x in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| x::xs -> x in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x'::xs -> x' in
let base = (0, []) in
let args =  match l1 with
| h::t -> [[ (h, l2 ) ]] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x'::xs -> x' in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| x'::xs -> x' in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> c in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> c in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> (c,a) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> (c,a) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, [1]) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, [1,1]) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, [1,1]) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c+d::a,l2) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c+d::a,l2) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d::t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d::t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c+d)::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c+d)::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d::t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d::t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c,d in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c,d in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d::t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,a) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,a) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,[a]) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,[a]) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,c+t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,c+t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::
match a with 
| (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::
match a with 
| (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::a) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::a) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::
match a with 
| (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
match a with 
| (a1,a2)->a1)::a2 in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
match a with 
| (a1,a2)->a1)::a2 in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
match a with 
| (a1,a2)-> a1::a2 in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
match a with 
| (a1,a2)-> a1::a2 in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o)::p

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o)::p


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (o,p) = a in
let (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (o,p) = a in
let (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine 0::l1 0::l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

annotated:
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = let (o,p) = a in
let (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine 0::l1 0::l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))


fix:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> (h*i) :: acc 
in helper i l []

bad:
let rec mulByDigit i l = let h::t = List.rev l in
mulByDigit (h*i)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l = let h::t  ->  List.rev l in
mulByDigit (h*i)


fix:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> h*i :: acc 
in helper i l []

bad:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> helper(t*i) :: acc 
in helper i l []

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> helper(t*i) :: acc 
in helper i l []


fix:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> h*i :: acc 
in helper i l []

bad:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> helper(h*i) :: acc 
in helper i l []

annotated:
let mulByDigit : int -> int list -> int list  = fun  i l  ->  
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> helper(h*i) :: acc 
in helper i l []


fix:
let rec mulByDigit i l = mulByDigit (i-1) (bigAdd l l)

bad:
let rec mulByDigit i l = mulByDigit i-1 (bigAdd l l)

annotated:
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit i-1 (bigAdd l l)


fix:
let sqsum xs = 
let f a x = (a+x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let a1::a2::t = l1 in
(mulByDigit a2 (mulByDigit a1 l2))

annotated:
let a1::a2::t = l1 in
(mulByDigit a2 (mulByDigit a1 l2))


fix:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) )in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = [(l1, l2)] in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (o,p) = a in 
let (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = [(l1, l2)] in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in
let base = (0,[]) in
let args = [l1] in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (o,p) = a in 
let (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in
let base = (0,[]) in
let args = [l1] in
let (_, res) = List.fold_left f base args in
res


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let _ = bigMul [[9;9;9;9]] [9;9;9;9]

annotated:
let _ = bigMul [[9;9;9;9]] [9;9;9;9]


fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

annotated:
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (o,p) = a in 
let h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res


