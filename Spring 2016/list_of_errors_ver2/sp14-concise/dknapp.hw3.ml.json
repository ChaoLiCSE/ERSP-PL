{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = a (x a) in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'b\n       but an expression was expected of type\n         ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h::t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x\n| _ -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = h::t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" [\"[\"; List.map f l; \"]\"];;\n", "in": "let stringOfList f l = sepConcat \"; \" [\"[\"; List.map f l;\"]\"]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" [[\"[\"]; List.map f l; [\"]\"]];;\n", "in": "let stringOfList f l = sepConcat \"; \" [[\"[\"]; List.map f l;[\"]\"]]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \"; \" (List.append (\"[\" :: (List.map f l)) \"]\");;\n", "in": "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) \"]\")", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) [\"]\"])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\"", "type": "type", "out": "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nif n <= 0 then []\nelse x :: clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet rec helper acc x n =\nif n <= 0 then acc\nelse helper (x::acc) x (n-1)\nin\nhelper [] x n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| x::xs' -> match x with\n| 0 -> removeZero xs'\n| _ -> l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum % 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum%10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum % 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum % 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = (0, []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = (0, []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int list\n       Type 'a list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          ([], (helper [] 0 padded1 padded2)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          ([], (helper [] 0 (List.rev padded1) (List.rev padded2))) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 (List.rev padded1) (List.rev padded2))\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> List.rev c; List.rev d)\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in (helper (sum mod 10)) ::\n             (acc (sum / 10) (t1, t2))) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> List.rev c; List.rev d)\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int list * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * int list -> int list -> int list\n       but an expression was expected of type\n         'a * int list -> int list -> 'a * int list\n       Type int list is not compatible with type 'a * int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      ([], (helper [] 0 g)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (q,r)  -> r) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      ([], (helper [] 0 g)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) -> (([], 0), (r :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = ((List.rev pad1), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = (List.rev pad1 , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * 'a list\n       but an expression was expected of type (int list * int) * int list\n       Type int list is not compatible with type int list * int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> \nlet sum = h+x+r in\n(([],0), (sum/10)::(sum mod 10)::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> \nlet sum = h+x+r in\n(([],0), (sum/10)::(sum mod 10)::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (([],_), acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> \nlet sum = (h*i)+r in\n(([],0), (sum/10)::(sum mod 10)::acc)\n| ((h::t,r), acc) ->\nlet sum = (h*i)+r in\n((t,(sum/10)), (sum mod 10)::acc)\nin\nlet base = ((List.rev l,0), []) in\nlet args = (List.rev l) in\nlet (_, res) = List.fold_left f base args in\nmatch res with\n| 0::t -> t\n| _ -> res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (([],_), acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> \nlet sum = (h*i)+r in\n(([],0), (sum/10)::(sum mod 10)::acc)\n| ((h::t,r), acc) ->\nlet sum = (h*i)+r in\n((t,(sum/10)), (sum mod 10)::acc)\nin\nlet base = ((List.rev l,0), []) in\nlet args = (List.rev l) in\nlet (_, res) = List.fold_left f base args in\nremoveZero res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (([],_), acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> \nlet sum = (h*i)+r in\n(([],0), (sum/10)::(sum mod 10)::acc)\n| ((h::t,r), acc) ->\nlet sum = (h*i)+r in\n((t,(sum/10)), (sum mod 10)::acc)\nin\nlet base = ((List.rev l,0), []) in\nlet args = (List.rev l) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (([],_), acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> \nlet sum = (h*i)+r in\n(([],0), (sum/10)::(sum mod 10)::acc)\n| ((h::t,r), acc) ->\nlet sum = (h*i)+r in\n((t,(sum/10)), (sum mod 10)::acc)\nin\nlet base = ((List.rev l,0), []) in\nlet args = (List.rev l) in\nlet (_, res) = List.fold_left f base args in\nremoveZero res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nif l1 = [] or l2 = [] then []\nelse\nlet f a x = match a with\n| (lst, acc) -> (lst, bigAdd acc (mulByDigit x lst)) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| (lst, acc) -> (lst, bigAdd acc (mulByDigit x lst)) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| (lst, acc) -> (lst, bigAdd acc (mulByDigit x lst)) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) ->\n          let sum = (h + x) + r in\n          (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = (((List.rev pad1), 0), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (([],_),acc) -> failwith \"should never reach here\"\n    | ((h::[],r),acc) ->\n        let sum = (h * i) + r in\n        (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n    | ((h::t,r),acc) ->\n        let sum = (h * i) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n  let base = (((List.rev l), 0), []) in\n  let args = List.rev l in\n  let (_,res) = List.fold_left f base args in removeZero res;;\n\nlet bigMul l1 l2 =\n  if (l1 = []) || (l2 = [])\n  then []\n  else\n    (let f a x =\n       match a with\n       | ((lst,decPlace),acc) ->\n           (lst, (decPlace + 1)) bigAdd acc\n             (List.append (mulByDigit x lst) (clone 0 decPlace)) in\n     let base = (l1, []) in\n     let args = l2 in let (_,res) = List.fold_left f base args in res);;\n", "in": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type 'a * int\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) ->\n          let sum = (h + x) + r in\n          (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = (((List.rev pad1), 0), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (([],_),acc) -> failwith \"should never reach here\"\n    | ((h::[],r),acc) ->\n        let sum = (h * i) + r in\n        (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n    | ((h::t,r),acc) ->\n        let sum = (h * i) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n  let base = (((List.rev l), 0), []) in\n  let args = List.rev l in\n  let (_,res) = List.fold_left f base args in removeZero res;;\n\nlet bigMul l1 l2 =\n  if (l1 = []) || (l2 = [])\n  then []\n  else\n    (let f a x =\n       match a with\n       | ((lst,decPlace),acc) ->\n           (lst, (decPlace + 1)) bigAdd acc\n             (List.append (mulByDigit x lst) (clone 0 decPlace)) in\n     let base = ((l1, 0), []) in\n     let args = l2 in let (_,res) = List.fold_left f base args in res);;\n", "in": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type 'a * int\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
