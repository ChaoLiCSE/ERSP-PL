{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | _ -> (List.hd xs) + (sumList List.tl) | [] -> [];;\n", "in": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + sumList List.tl\n| [] -> []", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList", "type": "type", "out": "Error: This expression has type int list -> 'a list\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | _ -> (List.hd xs) + 2 | [] -> [];;\n", "in": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + 2\n| [] -> []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)", "type": "type", "out": "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs", "type": "type", "out": "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x + x;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x + x", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| xs -> List.hd xs + sumList List.tl xs", "type": "type", "out": "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> List.hd xs + sumList List.tl xs", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "sumList [1]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | n -> 5 | 0 -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| 0 -> []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | 0 -> [] :: ns | n -> n :: ns;;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> [] :: ns\n| n -> n :: ns", "type": "scope", "out": "Error: Unbound value ns\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: ns", "type": "scope", "out": "Error: Unbound value ns\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)", "type": "scope", "out": "Error: Unbound value ns\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n::ns -> (n::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| n -> (n mod 10)::ns", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> (n mod 10)::ns", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> (n mod 10)::ns", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (List.hd (n mod 10)) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd (n mod 10)::ns", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n - List.hd ((n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> digitsOfInt(n - List.hd ((n mod 10)::ns))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> digitsOfInt(n - List.hd ((n mod 10)::ns))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n - List.hd ((n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> n mod List.hd ((n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> ((n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> ((n mod 10)::ns)\ndigitsOfInt n / 10", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (((n mod 10) :: ns) digitsOfInt n) / 10;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10)::ns)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt 222", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt 3124", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n > 0\nthen ((n mod 10)::(digitsOfInt (n / 10)))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt -5", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "in": "digitsOfInt -5", "type": "type", "out": "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "in": "digitsOfInt (-5)", "type": "type", "out": "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt 123", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))\n| 0 -> ns", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (-2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt -2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt - 2;;\n", "in": "digitsOfInt (-2)", "type": "type", "out": "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n =", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n =", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "in": "let rec additivePersistence n =", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}, {"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 20", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nsumList digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 9876", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 9876", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 3", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 3", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 10", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 9876", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 14", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 14", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = count + 1 in\nlet count = 0 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec additivePersistence n =\n  let count = count + 1 in\n  let count = 0 in\n  if n < 10 then count else additivePersistence (digitalRoot n);;\n", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (digitalRoot n)", "type": "scope", "out": "Error: Unbound value count\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nlet count = count + 1 in\nif n < 10\nthen count\nelse additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nif (sumList (digitsOfInt n)) != digitalRoot n\nthen count = count + 1\nelse additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 in\nif (sumList (digitsOfInt n)) != digitalRoot n\nthen count + 1\nelse additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) != digitalRoot n'\nthen count + 1\nelse additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) != digitalRoot n'\nthen count\nelse count + 1 and additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\ncount = count + 1 in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ =\n  let rec additivePersistence n =\n    let count = 0\n    and n' = n in count = (count + 1) in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\ncount = count + 1\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse additivePersistence (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value n'\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value n'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l'))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (List.hd l)::(listReverse (List.tl l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| l -> (listReverse (List.tl l))::(List.hd l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (listReverse (List.tl l)) :: (List.hd l);;\n", "in": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| h::t -> (List.hd l)::(listReverse (List.tl l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (List.hd l)::l' (List.tl l) in\nlr [] listReverse", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec lr l' =\n    match l with | [] -> l' | h::t -> (lr (List.hd l)) :: (l' (List.tl l)) in\n  lr [] listReverse;;\n", "in": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec lr l' = match l with | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "in": "let rec listReverse l = \nlet rec lr l' = function\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nexplode w", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = explode w;;\n\nlet _ = palindrome hello;;\n", "in": "palindrome \"hello\"", "type": "scope", "out": "Error: Unbound value hello\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nexplode w = listReverse (explode w )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "palindrome \"hello\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "palindrome \"racecar\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = failwith \"TBD: ...\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec count i =\nif n = digitalRoot n\nthen i\nelse (sumList (digitsOfInt n))\nin\ncount 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec countHelper n i =\nlet countHelper2 = countHelper3 n in\nmatch countHelper2 with\n| i = digitalRoot n -> count\n| n -> countHelper countHelper3 n (i + 1)\nin\ncountHelper 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n)) (count + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n)) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nmatch n' with\nif n' = digitalRoot(n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 1111;\nlet _ = additivePersistence 9876", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 98765", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 99999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 9999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 999999999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 99999999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 9999999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 9999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 99999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 9999999999", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 3", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 9", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 10", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 11", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 15", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 18", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 22", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 99", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 1010", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "additivePersistence 981", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse (((n mod 10)::(digitsOfInt (n / 10))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> listReverse (ns)\n| n -> \nif n < 0\nthen []\nelse ((n mod 10)::(digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ((digitsOfInt (n / 10))) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse (( digitsOfInt (n / 10) ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse ( ((n mod 10) ::  ( digitsOfInt (n / 10)) ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [(n mod 10) :: (digitsOfInt (n / 10))];;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) )", "type": "type", "out": "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "type": "scope", "out": "Error: Unbound value ns'\nHint: Did you mean ns?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "type": "scope", "out": "Error: Unbound value ns'\nHint: Did you mean ns?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse listReverse ( ((n mod 10) ::  ( digitsOfInt (n / 10)) ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| (h::t) -> listReverse ns\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| _ -> listReverse ns\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "type": "type", "out": "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\n| _ -> listReverse ns", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot 14", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sumList = [1; 2; 3]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sumList = [1; 2; 3];;\n\nlet _ = h :: (t sumList);;\n", "in": "(h::t) sumList", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sumList = [1; 2; 3];;\n\nlet _ = (h :: t) sumList;;\n", "in": "sumList", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet this = listReverse n in\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "type": "type", "out": "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}, {"min": "", "in": "let digitsOfInt n = \nlet xxx = function \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let digitsOfInt n = \nlet rec xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "type": "scope", "out": "Error: Unbound value xxx\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "in": "let rec digitsOfInt n = \nlet xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "type": "", "out": ""}], "event": "eval"}
