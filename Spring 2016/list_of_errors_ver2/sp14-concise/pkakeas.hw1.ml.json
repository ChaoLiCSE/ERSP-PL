{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList failed\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sum xs'", "type": "scope", "out": "Error: Unbound value sum\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then 4;;\n", "in": "let rec digitsOfInt n = \nif n < 0 then 4", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then 0;;\n", "in": "let rec digitsOfInt n = \nif n < 0 then 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then n;;\n", "in": "let rec digitsOfInt n = \nif n < 0 then n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else n;;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [1;2;3]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [1;2;3;4;5;6;7;8;9]\nelse [1;2;3]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let innerFunc elem = Printf.printf \"Element is %d\\n\" elem in\n     List.iter innerFunc n);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet innerFunc elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter innerFunc n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let f elem = Printf.printf \"Element is %d\\n\" elem in List.iter f n);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let f elem = Printf.printf \"Element is %d\\n\" elem in List.iter f n);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop listElem1 listElem2 =\n       if listElem1 = 0\n       then listElem2\n       else loop (listElem1 / 10) ((listElem1 mod 10) :: listElem2) in\n     match listElem1 with | _ -> loop listElem1 []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop listElem1 listElem2 =\nif listElem1 = 0 then listElem2\nelse loop (listElem1/10) (listElem1 mod 10::listElem2) in\nmatch listElem1 with\n| _ -> loop listElem1 []", "type": "scope", "out": "Error: Unbound value listElem1\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nsumList (digitsOfInt (abs n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif (n mod 10 ) != 0 then sumList (digitsOfInt (abs n) )\nelse sumList (digitsOfInt (abs n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif (n mod 10 ) <> 0 then sumList (digitsOfInt (abs n) )\nelse sumList (digitsOfInt (abs n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n = if (n mod 10) != 0 then x = (x + 1);;\n", "in": "let rec additivePersistence n = \nif n mod 10  != 0 then \nx = x + 1", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec loop retVal =\n    if retVal < 10 then retVal else loop sumList (digitsOfInt retVal) in\n  match n with | 0 -> 0 | _ -> loop n;;\n", "in": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) in match n with \n| 0 -> 0\n| _ -> loop n", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec recursive_loop retVal = \nif retVal < 10 then retVal\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| addP -> addP + 1\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP = (addP + (1 recursive_loop (sumList (digitsOfInt retVal)))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP = (addP + (1 recursive_loop (sumList (digitsOfInt retVal)))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else incr addP recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nincr addP\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then 8\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then n\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n\nlet rec recursive_loop retVal = \nlet addP = 0 in\nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    let addP = 0 in\n    let rec recursive_loop retVal =\n      if retVal < 10 then addP else addP = (addP + 1) in\n    recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    let addP = 0 in\n    let rec recursive_loop retVal = if retVal < 10 then addP else addP + 1 in\n    recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "scope", "out": "Error: Unbound value retVal\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP + (1 recursive_loop (sumList (digitsOfInt retVal))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal addP =\n    if retVal < 10\n    then addP\n    else\n      (let addP = addP + 1 in recursive_loop (sumList (digitsOfInt retVal))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal addP =\n    if retVal < 10\n    then addP\n    else\n      (let addP = addP + 1 in\n       recursive_loop (sumList (digitsOfInt retVal)) addP) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n addP", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec recursive_loop retVal = \nif retVal < 10 then retVal\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec rev acc = function\n| [] -> acc\n| h::t -> rev (h::acc) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec rev element = function\n| [] -> element\n| h::t -> rev (h::element) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w = w = (List.listReverse w);;\n", "in": "let palindrome w =\nw = List.listReverse w", "type": "scope", "out": "Error: Unbound value List.listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nw = listReverse w", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet reverse = listReverse w in\nif reverse = w then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = explode (listReverse w) in\n  if reverse = w then true else false;;\n", "in": "let palindrome w =\nlet reverse = explode (listReverse w) in\nif reverse = w then true\nelse false", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "in": "let palindrome w =\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         char list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let pk = explode w in\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "in": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         char list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet convertedString = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = convertedString then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec rev element = function\n| [] -> element\n| head::tail -> rev (head::element) tail in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet reverse = listReverse (explode w) in\nif reverse = explode w then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nif listReverse (explode w) = explode w then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop_rec n counter =\nif n = 0 then counter\nelse loop_rec (n/10) (n mod 10::counter) in\nmatch n with\n| _ -> loop_rec n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec recursive_loop retVal = \nif retVal < 10 then retVal\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> recursive_loop n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \n(* define helper function to add elements in opposite order to list *)\nlet rec reverseList element = function\n| [] -> element\n| head::tail -> reverseList (head::element) tail in\nreverseList[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \n(* define helper function to add elements in opposite order to list *)\nlet rec reverseList element = function\n(* IF the empty list, return that, else recurse with head and tail*)\n| [] -> element\n| head::tail -> reverseList (head::element) tail in\nreverseList[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n(* If the empty list, return 0 *)\n| []  -> 0\n| x::xs' ->x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse\ndigitalRoot (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse\ndigitalRoot (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n(* If your number is less than 10 then just return 0 *)\nif n < 10 then 0\nelse\n(* recursively call AP on the sum of your int list and keep adding\non 1 to keep track of how many times you've added/recursed*)\n1 + additivePersistence (sumList (digits n ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n(* If the empty list, return 0 *)\n| []  -> 0\n| x::xs' ->x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
