{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x sum x = sum + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = fun sum x -> sum + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = sum + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = sum + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value sum\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = f x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = f x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y a = x in let base a = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y a = x in let base f = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y a = x in let base = f x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  f x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y a = x in let base a = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = a in let base a = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base =  fun a -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a x in let base a = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x c = a ^ (sep ^ x) in\n      let base = \"\" in let l = l in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x c = a ^ (sep ^ x) in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string -> string -> 'a -> string\n       but an expression was expected of type string -> string -> string\n       Type 'a -> string is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = [] in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  ((((clone 0 leng1) - leng2) @ l1), (((clone 0 leng2) - leng1) @ l2));;\n", "in": "let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 (leng1-leng2) @ l1 , clone 0 (leng2-leng1) @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 (leng2 - leng1) @ l1 , clone 0 (leng1 - leng2) @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| []    -> [] \n| h::t  -> if h = 0 then removeZero l else t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| h::t  -> if h = 0 then removeZero t else t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| []    -> []\n| h::t  -> if h = 0 then removeZero t else t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| []    -> []\n| h::t  -> if h = 0 then removeZero t else l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = l1 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = ([], []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = ([], []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type ('c list * 'd list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [[],[]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         ('a list * 'b list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([]) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a.first + x.first, a.second + x.second) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a.first + x.first), (a.second + x.second)) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound record field first\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, x) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, x) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x.first in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound record field first\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  [a] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a] in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'a list\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  ([a], a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([a], a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a[0] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'a list * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a [0] in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int list -> 'a) -> 'b -> 'a\n       but an expression was expected of type\n         (int list -> 'a) -> 'b -> int list -> 'a\n       The type variable 'a occurs inside int list -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = ([], []) in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = 5 in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = 5 in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  [5],[5] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value padZero\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a.first,a.second in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a.first), (a.second)) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a.fst,a.snd in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound record field first\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a.fst), (a.snd)) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound record field fst\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, List.rev l2) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, []) in\nlet args = [List.rev l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h:t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> [].snd a\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound record field snd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> ([], (snd snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b -> 'b\n       but an expression was expected of type 'c * ('d -> 'e)\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match fst a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match fst a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = List.combine l1 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = [0, 0] in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, 0) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, ((fst h + snd h) mod 10) :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( ((fst h + snd h) / 10, (fst h + snd h) mod 10) :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t -> ((((fst h) + (snd h)) / 10), (((fst h) + (snd h)) mod 10)) ::\n          t in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: snd a )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) ::\n            (snd a))) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> (fst h + snd h) / 10, ((fst h + snd h) mod 10) :: snd a in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type (int * int) list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) ::\n            (snd a))) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type (int * int) list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\nin \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> x\n| h::t  -> x in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> x | h::t -> x in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = List.combine l1 l2;;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2", "type": "scope", "out": "Error: Unbound value l1\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"3232\" in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a\n| h::t -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| () -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | () -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type unit list\n       Type 'a * 'b is not compatible with type unit \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([]) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| 5 -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 5 -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| 'a' -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 'a' -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (_, _) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type char list\n       Type 'a * 'b is not compatible with type char \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, fst a + (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, \nfst a + (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, \nfst a + (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, \nfst a + (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet digitSum = fst x + snd x + fst a in\ndigitSum / 10, \ndigitSum mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet digitSum = fst x + snd x + fst a in\ndigitSum / 10, \ndigitSum mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet digitSum = fst x + snd x + fst a in\ndigitSum / 10, \ndigitSum mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.rev ((0, 0) :: List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f ((0, 0) :: l) base in\nresult", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f ((0, 0) :: l) base in result;;\n", "in": "let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (0 :: l) base in\nresult", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (l) base in\nresult", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (0 :: l) base in\nresult", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (0 :: l) base in\nremoveZero result", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigSum value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value bigSum\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = ([], []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd x value :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 @ clone 0 (fst a) in\nfst a + 1, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
