{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then b'\nelse wwhile (f,b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = if b = (f b) then b else fixpoint (f, (f b));;\n", "in": "let fixpoint (f,b) = \nif b = (f b) then b\nelse fixpoint (f, f b)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "in": "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "in": "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "in": "let fixpoint (f,b) = \nlet y = (f b) in\nif b = y then b\nelse fixpoint (f, y)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | aPrime -> if b = aPrime then b else fixpoint (f, aPrime);;\n", "in": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| aPrime -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile( f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "in": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let temp = (rand (0, 1)) = 0 in if temp then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let temp = rand(0,1) = 0 in\nif temp then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> buildSine( build(rand, depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y == 2 then buildX ();;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y == 2 then buildX()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then 5;;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then 5", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in y;;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\ny", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then y;;\n", "in": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif (y = 2) then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then buildX ());;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in y = 2);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\ny = 2", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then VarX else VarY\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then VarX else VarY\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "if rand (0,1) = 0 then buildX() else buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rand (a,b) = if a < b then a else b;;\n\nlet _ =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "in": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "type": "scope", "out": "Error: Unbound value depth\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 ->\nbuildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) ) \n| _ -> failwith \"Unexpected output from rand\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 ->\nif (rand (0,1) = 0) then buildX() else buildY()\n| _ ->\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) ) \n| _ -> failwith \"Unexpected output from rand\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 ->\nif (rand (0,2) = 0) then buildX() else buildY()\n| _ ->\nlet y =  2 * rand (2,7) in match y with\n| 4 | 5 -> buildSine( build(rand, depth-1) ) \n| 6 | 7 -> buildCosine( build(rand, depth-1) )\n| 8 | 9 | 10 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 11 | 12 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 13 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) ) \n| _ -> failwith \"Unexpected output from rand\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| MultDivPi(e1,e2,e3) ->\n( (eval (e1,x,y)) *. (eval (e2,x,y)) *. (eval (e3,x,y)) ) /. pi\n| Div7(e1) ->\n(eval (e1,x,y)) /. 7.0\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 ->\nif (rand (0,2) = 0) then buildX() else buildY()\n| _ ->\nlet y =  (10 * rand (2,9)) + rand(0,10) in match y with\n| 20 | 21 | 22 | 23 | 24\n| 25 | 26 | 27 | 28 | 29 -> buildSine( build(rand, depth-1) ) \n| 30 | 31 | 32 | 33 | 34\n| 35 | 36 | 37 | 38 | 39 \n| 40 | 41 | 42 | 43 | 44\n| 45 | 46 | 47 | 48 | 49 \n| 50 | 51 | 52 | 53 | 54\n-> buildCosine( build(rand, depth-1) )\n| 55 | 56 | 57 | 58 | 59\n| 60 | 61 | 62 | 63 | 64\n-> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 65 | 66 | 67 | 68 | 69\n| 70 | 71 | 72 | 73 | 74\n-> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 75 | 76 | 77 | 78 | 79\n-> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )\n| 80 | 81 | 82 | 83 | 84\n-> buildDiv7( build(rand, depth-1) )\n| 85 | 86 | 87 | 88 | 89\n-> buildMultDivPi( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1) )\n| _ -> failwith \"Unexpected output from rand\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
