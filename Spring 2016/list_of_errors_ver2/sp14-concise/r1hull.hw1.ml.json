{"ocaml": [{"min": "\nlet rec sumList xs = (xs.(0)) + (hd xs);;\n", "in": "let rec sumList xs = \nxs.(0) + hd xs", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = if xs.length != 0 then (xs.(0)) + (sumList (hd xs));;\n", "in": "let rec sumList xs = \nif xs.length != 0 then xs.(0) + sumList(hd xs)", "type": "scope", "out": "Error: Unbound record field length\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (hd xs));;\n", "in": "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(hd xs)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b array\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (List.hd xs));;\n", "in": "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(List.hd xs)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b array\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.hd xs));;\n", "in": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n", "in": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n", "in": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = let x::t = xs in if t != [] then x + (sumList t);;\n", "in": "let rec sumList xs = \nlet x :: t = xs in\nif t != [] then x + sumList (t)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = let x::t = xs in if x != [] then x + (sumList t);;\n", "in": "let rec sumList xs = \nlet x :: t = xs in\nif x != [] then x + sumList (t)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = let x::t = xs in x + (if t != [] then sumList t);;\n", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t != [] then sumList (t)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = (n mod 10) :: (if n <> [] then digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n", "in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "type": "scope", "out": "Error: Unbound value digInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n", "in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "type": "scope", "out": "Error: Unbound value digInt\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet int list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = digInt = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "type": "scope", "out": "Error: Unbound value digInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  (int list digInt) = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n = \nint list digInt = n mod 10 :: digitsOfInt( n / 10)", "type": "scope", "out": "Error: Unbound value int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = digInt = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "type": "scope", "out": "Error: Unbound value digInt\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digitsOfInt ( n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let int list digInt = (n mod 10) :: digInt in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let int list digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nlet int list digInt = [] in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  let l = [] in\n  match n / 10 with\n  | 0 -> []\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let digitsOfInt n =\nlet l = [] in\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> []\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type int list\n       Type 'a list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> (listReverse l) :: x;;\n", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l x);;\n", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l) x", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| h:: t -> h :: listReverse(t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| h:: t -> listReverse(t) @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet h::t = l in\nmatch t with \n| []   -> []\n| _ -> listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| h::t -> listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with \n| []   -> l\n| h::t -> listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> x | h::t -> (h :: x; listReverse t);;\n", "in": "let rec listReverse l = \nmatch l with \n| []   -> x\n| h::t -> (h :: x; listReverse t )", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let h::t = l in\n  let x = h :: x in match l with | [] -> x | h::t -> listReverse t;;\n", "in": "let rec listReverse l = \nlet h::t = l in\nlet x = h :: x in\nmatch l with \n| []   -> x\n| h::t -> listReverse t", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let h::t = l in\n  let x = h :: x in match t with | [] -> x | h::t -> listReverse t;;\n", "in": "let rec listReverse l = \nlet h::t = l in\nlet x = h :: x in\nmatch t with \n| []   -> x\n| h::t -> listReverse t", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = if l <> [] then (h :: t) = l;;\n", "in": "let rec listReverse l = \nif l <> [] then h::t = l", "type": "scope", "out": "Error: Unbound value h\n"}, {"min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse t;;\n\nlet _ = let x = h :: x in match t with | [] -> x | h::t -> listReverse t;;\n", "in": "let x = h :: x in\nmatch t with \n| []   -> x\n| h::t -> listReverse t", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> x + 0 | h::t -> x + (sumList t);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| h::t -> h + sumList(t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  if l <> [] then match l with | [] -> l | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = \nif l <> [] then \nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> []\n| h::t -> listReverse2 t (h::dest)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = listReverse (digitsToList n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = listReverse (digitsToList n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet l = digits n in\nmatch l with\n| [] -> []\n| h::t -> digitalRoot(sumList(t))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList t);;\n", "in": "let rec digitalRoot n = digitalRoot(sumList(t))", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList n);;\n", "in": "let rec digitalRoot n = digitalRoot(sumList(n))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = digitalRoot(sumList(digits(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n mod 10 <> 0 then digitalRoot(sumList(digits(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot2 num total =\ntotal + if n mod 10 <> 0 then digitalRoot2(sumList(digits(num))) else 0", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (n mod 10) <> 0 then digitalRoot2 (sumList (digits num)) else 0);;\n", "in": "let rec digitalRoot2 num total =\ntotal + if num mod 10 <> 0 then digitalRoot2(sumList(digits(num))) else 0", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0 then digitalRoot2 (sumList (digits num)) else 0);;\n", "in": "let rec digitalRoot2 num total =\ntotal + if num mod 10 <> 0 then digitalRoot2(sumList(digits(num)) total) else 0", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0\n     then digitalRoot2 (sumList (digits num) total)\n     else 0);;\n", "in": "let rec digitalRoot2 num total =\ntotal + if num mod 10 <> 0 then digitalRoot2((sumList(digits(num))) total) else 0", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0\n     then digitalRoot2 ((sumList (digits num)) total)\n     else 0);;\n", "in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\ntotal + if s mod 10 <> 0 then digitalRoot2 s else 0", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  total + (if (s mod 10) <> 0 then digitalRoot2 s else 0);;\n", "in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\nlet total = total + s in\nif s mod 10 <> 0 then digitalRoot2 s total else 0", "type": "scope", "out": "Error: Unbound value digits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s mod 10) <> 0 then digitalRoot2 s total else 0;;\n", "in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\nlet total = total + s in\nif s mod 10 <> 0 then digitalRoot2 s total else total", "type": "scope", "out": "Error: Unbound value digits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s mod 10) <> 0 then digitalRoot2 s total else total;;\n", "in": "let rec digitalRoot n = digitalRoot2 n 0", "type": "scope", "out": "Error: Unbound value digits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\nlet total = total + s in\nif s / 10 <> 0 then digitalRoot2 s total else total", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}, {"min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s / 10) <> 0 then digitalRoot2 s total else total;;\n", "in": "let rec digitalRoot n = digitalRoot2 n 0", "type": "scope", "out": "Error: Unbound value digits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot2 num =\nlet l = digits(num) in\nlet s = sumList(l) in\nif s / 10 <> 0 then digitalRoot2 s else s", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}, {"min": "\nlet rec digitalRoot2 num =\n  let l = digits num in\n  let s = sumList l in if (s / 10) <> 0 then digitalRoot2 s else s;;\n", "in": "let rec digitalRoot n = digitalRoot2 n", "type": "scope", "out": "Error: Unbound value digits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 65536;;\n", "in": "let additivePersistence n = \nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence (n + 1) else 0", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let additivePersistence n = \nlet l = digits(n) in\nlet s = sumList(l) in\nlet p = p + 1 in\nif s / 10 <> 0 then additivePersistence s else p", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet additivePersistence n =\n  let l = digits n in\n  let s = sumList l in\n  let p = p + 1 in if (s / 10) <> 0 then additivePersistence s else p;;\n", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "type": "scope", "out": "Error: Unbound value digits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence s c) + 1 else c;;\n", "in": "let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "type": "scope", "out": "Error: Unbound value digits\n"}, {"min": "\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let digitsOfInt n = listReverse (digitsToList n)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "in": "let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let digitsOfInt n = listReverse (digitsToList n)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = listReverse (digitsToList n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "in": "let listReverse l = listReverse2 l []", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l = listReverse2 l [];;\n", "in": "let rec listReverse2 l dest = ", "type": "scope", "out": "Error: Unbound value listReverse2\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = listReverse2 l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = listReverse (digitsToList n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence s c+1 else c", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = additivePersistence n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence s c) + 1 else c;;\n\nlet additivePersistence n = additivePersistence n 0;;\n", "in": "let additivePersistence n = additivePersistence2 n 0", "type": "type", "out": "NO ERROR FROM MINIMAL PROGRAM!!!\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c+1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = additivePersistence2 n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c+1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet f = explode w in\nlet b = listReverse f in\nif proceed f b then true else false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "type": "", "out": ""}], "event": "eval"}
