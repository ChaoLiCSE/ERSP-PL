{"ocaml": [{"min": "\nlet digits n = digitsOfInt (abs n);;\n", "in": "let digits n = digitsOfInt (abs n)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = let x = 3 in x+2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (0, n)\nelse additivePersistence (a+1, sumList(digits n))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse (digitalRoot (sumList (digits n)))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "in": "let rec additivePersistence (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  4;;\n", "in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin 4", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin (4,5)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10 then (a, n) else intFun ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n", "in": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse intFun (a+1, sumList(digits n))\nin (4,5)", "type": "scope", "out": "Error: Unbound value intFun\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistenceDigitalRoot (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistenceDigitalRoot (a+1, sumList(digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence (n) = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n = let (a,b) = additivePersistenceDigital (0, n) in a;;\n", "in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigital (0, n)\nin a", "type": "scope", "out": "Error: Unbound value additivePersistenceDigital\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n[] -> []\n| x :: xs -> (listReverse xs) @ [x]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "in": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "type": "scope", "out": "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "in": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "type": "scope", "out": "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = palindromeA ([('a', 'b', 'c')], 0);;\n", "in": "let rec palindromeA (w, p) = \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "type": "scope", "out": "Error: Unbound value palindromeA\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif ((List.length w) < (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif ((List.length w) <= (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nif ((List.nth w p) = (List.nth w (List.length w - 1 - p)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) < (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindrome (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p)\nthen if ((List.nth w p) = (List.nth w ((List.length w) - 1 - p)))\nthen palindromeA (w, p + 1)\nelse false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = palindromeA (explode w, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = palindromeA (explode w, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}, {"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin b", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}, {"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec listReverse l = match l with\n[] -> []\n| x :: xs -> (listReverse xs) @ [x]", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
