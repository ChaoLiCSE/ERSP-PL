{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\n1\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList List.tl xs) else 0;;\n", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "type": "scope", "out": "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\n(digitsOfInt n/10) @ ( n mod 10 ::[])\nelse\n[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1;]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n5::[]\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n5::[]\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\nn/10::[]\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then [5] @ ((digitsOfInt n) / 10) else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt n/10\nelse\n[1]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>10 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help  n)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help  n)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence help n) else 0;;\n", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence help  n\nelse\n0", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif n>10 then\n1+ additivePersistence (help n)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = \nif n<10 then\nn\nelse\ndigitalRoot (help n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = \nif n<10 then\n10\nelse\n5", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = \nif n<10 then\nn\nelse\n5", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n<10 then\nn\nelse\ndigitalRoot (help n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  if List.length > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "in": "let rec listReverse l = \nif List.length>0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "in": "let rec listReverse l = \nif List.length l >0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(listReverse (List.tl l)) @ (List.hd l ::[])\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (go w) = (listReverse (go w));;\n", "in": "let palindrome w = \n(go w)=(listReverse (go w))", "type": "scope", "out": "Error: Unbound value go\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ h", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ (h::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "in": "let rec digitsOfInt n = \nif n>10 then\n(digitsOfInt (n/10))::[n mod 10]\nelse\nn", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 10 then [n; n mod 10] else n;;\n", "in": "let rec digitsOfInt n = \nif n>10 then\nn::[n mod 10]\nelse\nn", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n[n mod 10]\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\nn::[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10]\nelse\n[n]", "type": "type", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "type": "type", "out": "Error: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) @ [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) @ [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)  [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else n;;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\nn", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n + 0];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n+0]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (help n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(help n 1))::digitsOfInt (n/10)\nelse\n[n]", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod 10)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod helpFac n 1)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(app (listReverse x)  (h::[]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod helpFac n 1)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/10)::digitsOfInt (n mod 10)\nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10)@ [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\n[n]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] []", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] [8]", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int list -> int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([(n/10)] [n mod 10]) \nelse\napp [3] [8]", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n / 10] [n mod 10]) \nelse\napp [3] [8]", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp [n/10] [n mod 10] \nelse\napp [3] [8]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt n) / (10 [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt n/10 [n mod 10] \nelse\napp [3] [8]", "type": "type", "out": "Error: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\napp [3] [8]", "type": "type", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\n[n]", "type": "type", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "in": "let digitsOfInt n = \nlet driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "type": "scope", "out": "Error: Unbound value driver\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\nls\nin\ndriver n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n*10 []", "type": "type", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver (n*10) []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []\n\n\n3124 mod 10", "type": "type", "out": "Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nn::ls\nin\ndriver n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =let county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \nadditivePersistence n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n\nlet additivePersistence n =\n  let county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  additivePersistence n;;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let rec county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  county n;;\n", "in": "let additivePersistence n =let rec county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n", "type": "scope", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value help\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ county (help n)\nelse\n0\nin \ncounty n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n|[]->[]\n|h::x->(app (listReverse x)  (h::[]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "type": "", "out": ""}], "event": "eval"}
