{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  failwith \"TBD\" in\nlet base = [] in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet dl = (List.length l1) - (List.length l2)\nin match dl with\n| 0 -> (l1,l2)\n| _ -> \nif dl > 0 then (l1, ((clone 0 dl) @ l2))\nelse (((clone 0 (dl / -1)) @ l1), l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h == 0 then removeZero t else h::t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add l1 l2 =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add l1 l2 = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: a :: ((w + y) mod 10)\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = (0, (List.rev (List.combine l1 l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  (0, List.rev ((List.combine l1 l2))) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * ('a * 'b) list\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev( List.combine l1 l2 ) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h == 0 then removeZero t else h::t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [(0,0)] in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> (((w + z) + y) / 10) :: (((w + y) + z) mod 10) :: t\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match x with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch x with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> (0, 0) in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int * int -> int * int\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int * int is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> (z / 10) :: (z mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::(z mod 10)in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> ((z / 10), [z mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> ((z/10),[z mod 10])in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> [z / 10; z mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::[z mod 10] in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> (((h + z) / 10), ((h + z) mod 10)) :: t\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10)):: t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> (((h + z) / 10), ((h + z) mod 10)) :: t\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10))::t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, l) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, l) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> (((w + z) / 10), ((w + z) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((w+z)/10), ((w+z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value w\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), ((z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), [z mod 10])\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (c, res) = List.fold_left f base args in\nc::res\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (0,y) ->  ( (z/10), (z mod 10)::y)  \n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (c, res) = List.fold_left f base args in\nc::res\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (0,y) ->  ( (z/10), (z mod 10)::y)  \n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2aa in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.combine l1 l2aa in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "scope", "out": "Error: Unbound value l2aa\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) @ (0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::(0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: ([0], [0])) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::([0],[0]))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (c, res) = List.fold_left f base args in\nc::res\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, ((z / 10) :: (z mod 10)))\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::(z mod 10))\n| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, [z / 10; z mod 10])\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::[z mod 10])\n| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::[z mod 10])\n| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::t )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::[z mod 10])\n| (w, h::t) -> ( ((w+z+h)/10), ((w+z+h) mod 10)::t)\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (((w + z) / 10), (0 :: ((w + z) mod 10) :: y))\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) ) @ [(0,0)]in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZer (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) ) @ [(0,0)]in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZer(add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value removeZer\nHint: Did you mean removeZero?\nError: Unbound value removeZer\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZer\nHint: Did you mean removeZero?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) ) @ [(0,0)]in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = fst x + snd x in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) ) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h == 0 then removeZero t else h::t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet rec mulByDigit i l =\n  let l1 = List.reverse l in\n  let l2 = [i] in\n  let mul (l1,l2) =\n    let f a x =\n      let z = (fst x) * (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul (padZero l1 l2));;\n", "in": "let rec mulByDigit i l = \nlet l1 = List.reverse l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value List.reverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet l1 = List.rev l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet l1 = l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet dl = (List.length l1) - (List.length l2)\nin match dl with\n| 0 -> (l1,l2)\n| _ -> \nif dl > 0 then (l1, ((clone 0 dl) @ l2))\nelse (((clone 0 (dl / -1)) @ l1), l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [] i l;;\n", "in": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [] i l", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "in": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> bigAdd lis acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "in": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> bigAdd lis acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [1]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec helper w y acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (w-1) y (bigAdd acc y)\nin \nhelper i l [0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nmulByDigit i l [0]", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nadder i l [0]", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 0 -> [0]\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nadder i l [0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9999999 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 0 -> [0]\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nadder i l [0]", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 0 -> [0]\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nadder i l [0]", "type": "scope", "out": "Error: Unbound value bigAdd\n"}, {"min": "\nlet _ = mulByDigit 0 [1; 2; 3];;\n", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec adder n l' a = match n with\n| 0 -> [0]\n| 1 -> bigAdd l' a\n| _ -> adder (n-1) l' (bigAdd a l') \nin \nadder i l [0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) -> (w, (bigAdd a (mulByDigit (clone x (List.length y)) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) -> (w, (bigAdd y (mulByDigit (clone x (List.length y)) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec bigCombiner l1 l2 acc = \nmatch l1 with\n| [] -> acc\n| h::t -> mulByDigit h l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (w, res) = List.fold_left f base args in\nw::res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec bigCombiner l1 l2 acc = \nmatch l1 with\n| [] -> acc\n| h::t -> mulByDigit h l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (10 ** (List.length y))) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (10 ** (List.length y))) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * mulByTen (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * mulByTen (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * mulByTen (List.length y)) l1)) in \nlet base = (0,[1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * mulByTen (List.length y)) l1)) in \nlet base = (1,[1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec bigCombiner l1 l2 acc n = match l1 with\n| [] -> acc\n| h::t -> bigCombiner t l2 (acc @ mulByDigit ( h * (tensMul n))) (n + 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec tensMul n =\n  match n with | 0 -> 0 | 1 -> 10 | _ -> 10 * (tensMul (n - 1));;\n\nlet rec bigCombiner l1 l2 acc n =\n  match l1 with\n  | [] -> acc\n  | h::t -> bigCombiner t l2 (acc @ (mulByDigit (h * (tensMul n)))) (n + 1);;\n", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"TBD\" in \nlet base = (0, []) in\nlet args = failwith \"tbd\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"TBD\" in \nlet base = (0, []) in\nlet args = failwith \"tbd\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec adder n l' a = match n with\n| 0 -> [0]\n| 1 -> bigAdd l' a\n| _ -> adder (n-1) l' (bigAdd a l') \nin \nadder i l [0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  in \nlet base = (0, []) in\nlet args =  in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  in \nlet base = (0, []) in\nlet args = ( List.rev l1 , List.rev l2 ) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (la, lb) = x in\nlet (i, acc) = a in\nmatch l1 with\n| [] -> (i, acc)\n| h::t -> let temp = mulByDigit h lb \nin (i + 1, ( bigAdd acc (temp * (mulByTen i))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByTen n =\n  match n with | 0 -> 0 | 1 -> 10 | _ -> 10 * (mulByTen (n - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (la,lb) = x in\n    let (i,acc) = a in\n    match l1 with\n    | [] -> (i, acc)\n    | h::t ->\n        let temp = mulByDigit h lb in\n        ((i + 1), (bigAdd acc (temp * (mulByTen i)))) in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (la, lb) = x in\nlet (i, acc) = a in\nmatch l1 with\n| [] -> (i, acc)\n| h::t -> let temp = mulByDigit h lb \nin (i + 1, ( bigAdd acc (temp @ (clone 0 (mulByTen i))))) in\nlet base = (0, []) in\nlet args = (List.rev l1 , List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
