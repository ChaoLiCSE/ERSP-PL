{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::[] -> x | (x::y)::[] -> x + (sumList y);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x] -> x\n| [x::y] -> x + sumList y", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | (x::y)::[] -> x + (sumList y);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a::b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | a -> [a] | ab -> a :: (digitsOfInt b));;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| ab -> a::digitsOfInt b", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) :: (n % 10);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse digitsOfInt (n / 10) :: (n % 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [] else (digitsOfInt (n / 10)) :: (n % 10);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) :: (n % 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse  digitsOfInt (n / 10) @ [n % 10]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n % 10]", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse\ndigitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList digitsOfInt n in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "in": "let rec additivePersistence n =\nlet sum = sumList digitsOfInt n in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "type": "scope", "out": "Error: Unbound value additivePersistance\nHint: Did you mean additivePersistence?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse b @ a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b :: a", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) :: a;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse [b]) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> (listReverse b) @ a", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (wList != wReverse) then 0\nelse 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (wList != wReverse) then false\nelse true", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nthen wList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 0;;\n", "in": "let digits n = digitsOfInt (abs n)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}, {"min": "\nlet digits n = digitsOfInt (abs n);;\n", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse 1 + additivePersistence sum", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}, {"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}, {"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 = 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList (b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 0\nelse 1 + additivePersistence (sum)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif n < 10 then 0\nelse\n1 + additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot (sum)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse (a)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ [a]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt (n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n / 10 = 0 then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet wList = explode w in\nlet wReverse = listReverse (wList) in\nif wList = wReverse then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nlet wList = explode w in\nlet wReverse = listReverse wList in\nif wList = wReverse then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =(*\nif n < 0 then []\nelse if n / 10 = 0 then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10] ;;*)\nif n < 0 then []\nelse if n / 10 > 0 then digitsOfInt (n / 10)\n@ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n / 10) > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n / 10) :: [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n/10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n/10) :: [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n/10) :: [n mod 10]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\nelse n", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 9 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "et rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 99 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 100 then\nlet a = (n / 10) mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n\nelse digitsOfInt(n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = 1 ^ 2;;\n", "in": "let rec digitsOfInt n =\nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\ndigitsOfInt a :: b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in (digitsOfInt a) :: b);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nc", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\ndigitsOfInt a :: c", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in let c = [a; b] in if a > 9 then (digitsOfInt a) :: c);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a < 10 then c\nelse digitsOfInt (a / 10)", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) ::[xs]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> [digitsOfInt x; xs]);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) :: xs", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a] -> [a]\n| a :: [b] -> b :: listReverse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::[] -> [a] | a::b::[] -> b :: (listReverse a);;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let c = listReverse b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet c = listReverse b;;\n", "in": "match l with\n| [] -> []\n| a :: b -> let c = listReverse b in", "type": "scope", "out": "Error: Unbound value b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> d :: listReverse c", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\na :: c", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; a]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> [listReverse b; a];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; [a]]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> [listReverse b; [a]];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> b :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse (s.[i]) :: (go (i+1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else (s.[i]) :: (go (i + 1));;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> 0", "type": "scope", "out": "Error: Unbound value s\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> 0;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> [a]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse [n.[0]]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [n.[0]];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse [n[0]]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [n [0]];;\n", "in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> \n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b in\nlast t :: listReverse l", "type": "scope", "out": "Error: Unbound value last\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "in": "let rec listReverse l =\nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l", "type": "scope", "out": "Error: Unbound value last\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b", "type": "scope", "out": "Error: Unbound value last\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a] b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a] b;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a]", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> [a] | b::c -> last c in\n  last l;;\n", "in": "let rec listReverse l =\nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "type": "scope", "out": "Error: Unbound value last\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let last t = function | [] -> [] | a::[] -> [a] | b::c -> last c in last l;;\n", "in": "let rec listReverse l =\nlet rec last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "type": "scope", "out": "Error: Unbound value last\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> a\n| c :: d -> listReverse d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> []\n| c :: d -> getHead l :: listReverse d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b = function\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "in": "let rec listReverse l =\nlet a = [] in\nlet rec get a =\nmatch a with\n| [] -> []\n| x :: xs -> get xs :: [x]\nin get l", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let a = [] in\n  let rec get a = match a with | [] -> [] | x::xs -> [get xs; x] in get l;;\n", "in": "let rec listReverse l =\nlet a = [] in\nlet get a = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch a with\n| [] -> []\nin getList [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> []\n| x :: xs -> getList (x::a) xs\nin getList [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "et _ = listReverse [1; 2; 3; 4]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> []\n| x :: xs -> getList (x::a) xs\nin\ngetList [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> a\n| x :: xs -> getList (x::a) xs\nin\ngetList [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet rec head b =\nmatch b with\n| [] -> a\n| c :: d -> c :: head a\nin\nhead l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet rec head b =\nmatch b with\n| [] -> a\n| c :: d -> c :: head a\nin\nhead l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet rec head b c =\nmatch c with\n| [] -> a\n| c :: d -> head a d\nin\nhead a l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> a\n| x :: xs -> reverse xs (x :: b)\nin\nreverse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> a\n| x :: xs -> reverse xs (x :: b)\nin\nreverse [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x :: b)\nin\nreverse [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x::b)\nin\nreverse [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x::b)\nin\nreverse l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs (x :: b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs (x :: b) in\n  integers n [];;\n\nlet _ = digitsOfInt 3124;;\n", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs ((a mod 10)::b)\nin integers n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs ((a mod 10) :: b) in\n  integers n [];;\n", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n 0;;\n", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\n(*\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n [] ", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
