{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else n mod 10;;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod (10 n)];;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10\nn::[]", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10 :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: [digitsOfInt n]", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n", "in": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) @ myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 @myList", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\n\nn mod 10 :: myList", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\n\nn mod 10 :: myList", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else (n mod 10) :: ((myList n) mod 100) :: myList;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList\nn mod 100 :: myList", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\n(n mod 10 :: myList) :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else n = (n - (n mod 10)); (n :: myList) :: digitsOfInt;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)", "type": "type", "out": "Error: This expression has type int -> int list list\n       but an expression was expected of type int list list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt", "type": "type", "out": "Error: This expression has type int -> int list list\n       but an expression was expected of type int list list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - (n mod 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else rev ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nrev (n mod 10 :: digitsOfInt (n / 10))", "type": "scope", "out": "Error: Unbound value rev\nHint: Did you mean ref?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((n mod 10) :: (digitsOfInt (n / 10))) List.rev;;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))\nList.rev", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev(n mod 10 :: digitsOfInt (n / 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: (List.rev digitsOfInt (n / 10)))", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev (digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: List.rev (digitsOfInt (n / 10)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \ndigitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | h::t -> h + t;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> h + t", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0;\n| _ -> sumList digitsOfInt n", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n;", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then digitalRoot (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "in": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount = count + 1", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "in": "let rec additivePersistence n = \nlet count = [] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen (\n1::count\nadditivePersistence (sumList (digitsOfInt n)))\nelse sumList count", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9 then 1 :: count else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count\nelse sumList count", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) & (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count & additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "type", "out": "Error: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) && (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count && additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "type", "out": "Error: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) &&& (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count &&& additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "scope", "out": "Error: Unbound value &&&\nHint: Did you mean &&?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nx + 1\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n", "in": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "type": "scope", "out": "Error: Unbound value count\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = 1 in x + 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (x additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1 :: x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nsumList x\nend\nelse sumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1::x;\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [1] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1::x;\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  1 @ x;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n", "in": "let rec additivePersistence n = \n1@x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::[2];\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \n-1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \n-23", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) < 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n1::x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else 1 :: x;\n  sumList x;;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1::x;\nsumList x;", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1;2];\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList [x]);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [x];\nend", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nexplode l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse \"nikhil\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n", "in": "let rec listReverse l = \nexplode l\n\nlistReverse \"nikhil\"", "type": "type", "out": "Error: This function has type string -> char list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse \"nikhil\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nexplode l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n[] -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> [1]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\";\"b\";\"c\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> [a]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\";\"b\";\"c\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1 -> [h1] | h::t -> h :: (listReverse t);;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> t :: (listReverse t);;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> t::(listReverse t)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}, {"min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\"; \"b\"; \"c\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|_ -> []\n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)::h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | (h::t)::t -> [];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t)::t -> []", "type": "type", "out": "Error: Variable t is bound several times in this matching\n"}, {"min": "", "in": "listReverse [\"a\";\"b\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::h::t -> [];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::(h::t)) -> []", "type": "type", "out": "Error: Variable h is bound several times in this matching\n"}, {"min": "", "in": "listReverse [\"a\";\"b\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\";\"b\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [h] | h::t -> listReverse t;;\n", "in": "let rec listReverse l = match l with \n|[] -> h::[]\n|(h::t) -> listReverse t", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse t | _ -> [h];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\n|_ -> h::[]", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t h];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\nh::[]", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [(listReverse t) h];;\n", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)\nh::[]", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "listReverse [\"a\";\"b\"]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"hi\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\" print_newline ();\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\" print_newline();\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "type": "type", "out": "Error: This function has type string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    ((print_string \"going into then\") / (print_newline ());\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\" /print_newline();\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\";\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_String \"going into else\"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_String \"going into else\";\n(1::x);\nsumList x\nend", "type": "scope", "out": "Error: Unbound value print_String\nHint: Did you mean print_string?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     x.print;\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\nx.print;\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend", "type": "scope", "out": "Error: Unbound record field print\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     List.print x;\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\nList.print x;\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend", "type": "scope", "out": "Error: Unbound value List.print\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     print_list x (1 :: x);\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\nprint_list x\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend", "type": "scope", "out": "Error: Unbound value print_list\nHint: Did you mean print_int?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [] in \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet x = [] in \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  let x = x + 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; sumList x);;\n", "in": "let rec additivePersistence n = \nlet x = x + 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  let x = x + 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; x);;\n", "in": "let rec additivePersistence n = \nlet x = x + 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nx\nend", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; sumList x);;\n", "in": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then digitalRoot (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nList.rev l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "in": "let palindrome w = \nif (explode w = listReverse w) then true\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet explosion = explode w in\nif (explosion = listReverse explosion) then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (sumList (digitsOfInt n) > 9) then digitalRoot (sumList (digitsOfInt n))\nelse\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet additivePersistence n = count;;\n", "in": "let additivePersistence n =\ncount", "type": "scope", "out": "Error: Unbound value count\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = n + 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet additivePersistence n a = (n + a) + b;;\n", "in": "let additivePersistence n a = n + a + b", "type": "scope", "out": "Error: Unbound value b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n a = n + a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = List.rev l;;\n\nlet additivePersistence n a = n + a;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet additivePersistence n a =\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n)) (a + 1);;\n", "in": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse 9", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec apCalc n a = \nif (sumList (digitsOfInt n) > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = apCalc n 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec apCalc n a = \nif (sumList (digitsOfInt n) > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = apCalc n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec apCalc n a = \nif (sumList (digitsOfInt n) > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec apCalc n a = \nif (n > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = apCalc n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec apCalc n a = \nif (n > 9)\nthen apCalc (sumList (digitsOfInt n)) (a + 1)\nelse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mylistReverse origList newList =\n  match origList with | [] -> [] | h::t -> (myListReverse t h) :: newList;;\n", "in": "let rec mylistReverse origList newList = match origList with\n| [] -> []\n| (h::t) -> myListReverse t h::newList", "type": "scope", "out": "Error: Unbound value myListReverse\nHint: Did you mean mylistReverse?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = myListReverse l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "type": "", "out": ""}], "event": "eval"}
