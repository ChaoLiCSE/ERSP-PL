{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,(n,v)::t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if List.mem h t then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' then wwhile (f, b') else return b';;\n", "in": "let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'", "type": "scope", "out": "Error: Unbound value return\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x in (xx, xx < 1000) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x in (xx, xx < 100000) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x in (xx, xx < 100000) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let fixpoint (f,b) = wwhile ( let fb  = f b in\n(fb,fb=b) ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}, {"min": "\nlet fixpoint (f,b) = wwhile (let fb = f b in ((fb, (fb = b)), b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile (let f b =  let fb  = f b in\n(fb,fb=b) ,b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((let fb = f b in (fb, (fb = b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in\n(fb,fb=b)) ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b = let fb = f b in (fb, (fb = b)) in f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b') ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b'), b);;\n", "in": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "in": "let fixpoint (f,b) = let w b' = let fb  = f b' in \n(fb,fb=b') in  wwhile ( w ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n", "in": "let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb=b') in  w ,b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb = b')) in (w, b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb<>b') in  w ,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb <> b')) in (w, b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let rec exprToString e = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi* eval (a,x,y) )\n| Cosine a         -> cos(pi* eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) + eval (b,x,y))/2)\n| Times (a,b)      -> eval (a,x,y) * eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) + eval (b,x,y))/2)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/2)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->  float x\n| VarY             ->  float y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         int\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = buildThresh(a,b,a_less,b_less) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| 5 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = exprToString build (makeRand, 5);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| 5 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = exprToString build (makeRand, 5);;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = exprToString (build (makeRand, 5));;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "type", "out": "Error: This expression has type int * int -> int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| 5 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,1) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,6) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,1) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,5) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,5) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,5) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,4) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Sigmoid  of expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1.- exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. - (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1.- exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Sigmoid  of expr \n| Tanh     of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh(pi*(\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/\"^ exprToString z \")\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh(pi*(\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/\"^ exprToString z ^ \")\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(pi*.( eval (a,x,y) +. eval (b,x,y))/.(eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = tanh ((-0.5) + 0.9);;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y)))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": ")\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh((\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/(1+\"^ exprToString z ^ \"))\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y))/.(0.1.+.eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y))/.(0.1+.eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y))/.(1.01+.eval (c,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x         -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y)    -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y)      -> exprToString x ^ \"*\" ^ exprToString y\n| Sigmoid x        -> \"sigmoid(\" ^ exprToString x ^ \")\"\n| Tanh (x,y,z)     -> \"tanh((\" ^ exprToString x ^\"+\" ^ exprToString y ^\n\")/(1.01+\"^ exprToString z ^ \"))\"\n| Thresh (x,y,z,w) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^\n\"?\" ^ exprToString z ^ \":\" ^ exprToString w ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,6) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 9 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,6) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 9 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h::seen \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.printf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.printf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.printf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.printf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.printf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nPrintf.printf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  \nPrintf.printf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nsprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  \nsprintf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nPrintf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  \nPrintf.sprintf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  \nPrintf.sprintf \"tanh((%s+%s)/(1.01+%s))\" (exprToString x)  (exprToString y)\n(exprToString z)\n| Thresh (x,y,z,w) ->  \nPrintf.sprintf \"(%s<%s?%s:%s)\" (exprToString x)  (exprToString y) (exprToString z)  (exprToString w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX             ->  \"x\"\n| VarY             ->  \"y\"\n| Sine x           ->  Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x         ->  Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y)    ->  Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y)      ->  Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Sigmoid x        ->  Printf.sprintf \"sigmoid(%s)\" (exprToString x)\n| Tanh (x,y,z)     ->  Printf.sprintf \"tanh((%s+%s)/(1.01+%s))\" \n(exprToString x)  (exprToString y) (exprToString z)\n| Thresh (x,y,z,w) ->  Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) \n(exprToString y) (exprToString z)  (exprToString w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| []   -> \nd\n| (n,v)::t -> \nif n=k then \nv \nelse \nassoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (0,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(0,7) with\n| 0 -> buildSine(b)\n| 1 -> buildCosine(b)\n| 2 -> buildAverage(b,build(rand,depth-1))\n| 3 -> buildTimes(b,build(rand,depth-1))\n| 4 -> buildSigmoid(b)\n| 5 -> buildTanh(b,build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
