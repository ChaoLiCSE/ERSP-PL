{"ocaml": [{"min": "", "in": "let rec sumList xs = (*failwith \"TBD:sumList\"*)\nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = (*failwith \"TBD:sumList\"*)\nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = (*failwith \"TBD\"*)\nlet str = explode w in\nif str = listReverse (str) then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match l with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match l with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = match x with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x l = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = (*failwith \"TBD\"*)\nif n < 10 then n\nelse digitalRoot( sumList (digitsOfInt ( abs n) ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = (*failwith \"TBD\"*)\nif n < 10 then n\nelse digitalRoot( sumList (digitsOfInt ( abs n) ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> h::x\n| _ -> listReverse x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| h::[] ->  h::x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | [] -> h :: x;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| [] ->  h::x", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | _ -> h :: x;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| _ ->  h::x", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h -> h :: x;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| (h) ->  h::x", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| [h] ->  h::x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> t :: x;;\n", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| [h] ->  t::x", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| [h] ->  h::x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "type": "", "out": ""}], "event": "eval"}
