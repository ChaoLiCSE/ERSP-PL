{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen' then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h :: seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value seen'\nHint: Did you mean seen?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif !c' then b' else wwhile(f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif !c' then b' else wwhile(f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif c' = false then b' else wwhile(f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "in": "let fixpoint (f,b) = wwhile (f b <> b,b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f ,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f b ,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (wwhile (f, b),b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (wwhile (f , b) , b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b)", "type": "type", "out": "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ( fixpoint (f , b), b)", "type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (fixpoint, b);;\n", "in": "let fixpoint (f,b) = wwhile ( fixpoint , b)", "type": "scope", "out": "Error: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ( f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let b' = f b in if b' = b then f b else ((f b'), b));;\n", "in": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)", "type": "type", "out": "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" exprToString expr2)\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\"", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) /. 2) + ((eval (e2, x, y)) /. 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) + ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "scope", "out": "Error: Unbound value buildCosine\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildY()                       = VarY", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi *. eval(e, x, y ))\n| Cosine(e)  -> cos(pi *. eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "scope", "out": "Error: Unbound value makeRand\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "type", "out": "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type\n         int * int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx = b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f , b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx = b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif c' = false then b' else wwhile(f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ( wwhile(f, b), b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile (if f b = b then b else f b , b)", "type": "type", "out": "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet (b', c') = f b in\nif b = b' then b else wwhile (f , b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let (b',c') = f b in if b = b' then b else wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b = b' then b else f b in\n  wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f , b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b = b' then b else f b in\n  wwhile ((f b), b);;\n", "in": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f b, b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let f b = b' in if b = b' then b else f b in\n  wwhile ((f b), b);;\n", "in": "let fixpoint (f,b) = \nlet f b = b' in\nif b = b' then b else f b in wwhile (f b, b)", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile ((f b), b);;\n", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx = b) in wwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet xx = f b in (xx, xx <>  b) in wwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let f b = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\")/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet d' = depth - 1 in\nif depth = 0 then\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith\"ruh roh\"\nelse\nmatch rand(2, 7) with\n| 2 -> buildSine(build(rand, d'))\n| 3 -> buildCosine(build(rand , d'))\n| 4 -> buildAverage(build(rand, d'), build(rand, d'))\n| 5 -> buildTimes(build(rand, d'), build(rand, d'))\n| 6 -> buildThresh(build(rand, d'), build(rand, d'), build(rand, d'), build(rand, d'))\n| _ -> failwith \"ruh roh2\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Chunky   of expr * expr * expr\n| Monkey   of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Chunky of expr* expr* expr\n  | Monkey of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Chunky (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Monkey (e1,e2) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then (-1) else 1;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\")/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"\n| Chunky(expr, expr2, expr3) -> \"((\"^exprToString(expr)^\"^\"^exprToString(expr2)^\")^\"^exprToString(expr3)^\")\"\n| Monkey(expr, expr2) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?-1.0:1.0)\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
