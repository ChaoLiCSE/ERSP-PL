{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (a + x) ^ 2 in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a + x^2 in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a +. x ** 2in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a +. x ** 2.0 in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = fs (a x) in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fs (a x) in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fs (a x) in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h curr) tl in\n  iter (fun y  -> y) fs;;\n", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h curr) tl in\niter (fun y-> y) fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h (acc)) tl in\niter (fun y-> y) fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter id fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter id fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x))) tl in\niter id fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (x (a y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  x ^ sep ^ a in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ List.map f l ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^ List.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  (\"[\" (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) List.fold_left (^) \"\"\n     (List.map f l))\n    ^ \"]\";;\n", "in": "let stringOfList f l = \n\"[\" (fun x acc -> x ^ \"; \" ^ acc) \nList.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^\nList.fold_left (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  \"[\" ^\n    ((List.fold_right (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) \"\"\n        (List.map f l))\n       ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^\nList.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^\n(List.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n(List.map f l) \n\"\")\n^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^\n(List.fold_left (fun acc x -> acc ^ \"; \" ^ x) \n\"\"\n(List.map f l) )\n^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif (n <= 0) then []\nelse \nx :: (clone x (n-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.len l1 in\n  let len2 = List.len l2 in\n  (((clone 0 (len2 - len1)) @ l1), ((clone 0 (len1 - len2)) @ l2));;\n", "in": "let padZero l1 l2 = \nlet len1 = List.len l1 in\nlet len2 = List.len l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)", "type": "scope", "out": "Error: Unbound value List.len\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), (((clone 0) - diff) @ l2));;\n", "in": "let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 -diff @  l2)", "type": "type", "out": "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 (-diff) @  l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then t \nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZer t else l;;\n", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZer t \nelse l", "type": "scope", "out": "Error: Unbound value removeZer\nHint: Did you mean removeZero?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), 1) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x / 10, 1 ) in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failWith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failWith \"\" in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value failWith\nHint: Did you mean failwith?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}, {"min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet bigAdd l1 l2 = failWith \"moo\";;\n", "in": "let bigAdd l1 l2 = failWith \"moo\"", "type": "scope", "out": "Error: Unbound value failWith\nHint: Did you mean failwith?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet bigAdd l1 l2 = failWith \"moo\";;\n", "in": "let bigAdd l1 l2 = failWith \"moo\"", "type": "scope", "out": "Error: Unbound value failWith\nHint: Did you mean failwith?\n"}, {"min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = failwith \"moo\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = (0 , 0) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n(if addit > 10 then addit mod 10\nelse 0 , addit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n(if addit > 10 then addit mod 10\nelse 0 , (addit / 10) :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10\nelse 0) , (addit / 10) :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\n(addit / 10) :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\n(addit / 10) :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), (addit / 10) :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = List.hd l1' + List.hd l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = List.hd l1' + List.hd l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | [] -> (0, (if carry > 0 then carry :: num else num))\n      | h::t ->\n          let (l1',l2') = h in\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| [] -> (0, if carry > 0 then carry :: num else num)\n| h :: t -> let (l1', l2') = h in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (x (a y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x - a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (x (a y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then 1 else 0), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f args base in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list -> int * int -> int * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f x a = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit >= 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 9) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\naddit / 10, \n( addit mod 10 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + (carry print_int l1') in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry \nprint_int l1' in\n(addit / 10, ( addit mod 10 :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> int * int list\n       but an expression was expected of type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> ((int -> unit) -> int -> int) * int list\n       Type int is not compatible with type (int -> unit) -> int -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = x in\n      let (l1',l2') = a in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = x in\nlet (l1', l2') = a in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int -> int * int list -> int * int list\n       but an expression was expected of type\n         int * int -> int * int list -> int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l1 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l1 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list -> 'a * 'b -> int * 'a list\n       but an expression was expected of type 'a list -> 'a * 'b -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,nume) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value num\nHint: Did you mean nume?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,nume) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value num\nHint: Did you mean nume?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, num @ [l1] )  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ ((addit mod 10) )) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in car\nin \n(add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZeros (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZeros (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine [0; l1] [0; l2] in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine [0; l1] [0; l2] in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith \"hi %s\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value printf\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith Printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith Printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith (Printf.sprintf \"hi %d\" addit)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nfailwith (Printf.sprintf \"hi %d\" car) res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"hi %d\" car \n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" car)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value car\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car );\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value car\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" car)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value car\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.kprintf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf (\"hi %d\" carry))\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry))\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %s\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %s\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" 1; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let () = Printf.printf \"%d\" in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\"; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> unit\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\";\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"1\\n\";\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\" addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\", addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\", addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         ('c, out_channel, unit) format =\n           ('c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%3d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%8d%8d%8d\\n\" l1' l2' carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%8d%8d%8d\\n\";\n      l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c, out_channel, unit) format =\n           ('b -> 'c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit) format =\n           ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s \" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s \"Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"1\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = (Printf.printf \"%d\\n\" addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf string_of_int addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf string_of_int addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> string\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + 1) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value List.reverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in List.reve res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.reve res\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value List.reve\nHint: Did you mean rev?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.rev res\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = mulByDigit (i - 1)\n(bigAdd l l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = mulByDigit (i - 1) (bigAdd l l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = if i = 0 then l \nelse mulByDigit (i - 1) (bigAdd l l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if i = 1 then l \nelse mulByDigit (i - 1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse l", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then 0\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then 0\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse bigAdd l (mulByDigit (i - 1) l)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)", "type": "scope", "out": "Error: Unbound value bigAdd\n"}, {"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement =  10 ** place  in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit (x * place) l1) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value addit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit (x * place) l1 in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit ((x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit ((x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a (mulByDigit (x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
