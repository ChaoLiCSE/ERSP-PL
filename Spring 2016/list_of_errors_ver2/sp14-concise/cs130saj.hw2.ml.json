{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) t_res =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif t_res then\nvi\nelse if ki = k then\nassoc_tl (d,k,l) true\nelse\nassoc_tl (d,k,tl) false\nin\nassoc_tl (d,k,l) false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) t_res =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif t_res then\nvi\nelse if ki = k then\nassoc_tl (d,k,l) true\nelse\nassoc_tl (d,k,tl) false\nin\nassoc_tl (d,k,l) false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec assoc_tl (d,k,l) =\nmatch l with\n| []\t\t-> d\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc_tl (d,k,tl)\nin\nassoc_tl (d,k,l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc_tl (d,k,tl)\n| _\t\t-> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc_tl (d, k, tl)\n  | _ -> d;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d", "type": "scope", "out": "Error: Unbound value assoc_tl\nHint: Did you mean assoc?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif b' then\nwwhile (f,b')\nelse\nc'", "type": "scope", "out": "Error: Unbound value wwhile\n"}, {"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if b' then wwhile (f, b') else c';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' then\nwwhile (f,b')\nelse\nb'", "type": "type", "out": "Error: This expression has type int -> int * bool\n       but an expression was expected of type bool -> bool * 'a\n       Type int is not compatible with type bool \n"}, {"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (((=) f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((=) f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "type", "out": "Error: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile ((f (=)),b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let g f b = (b = (f b))),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let g f b = (b, (b = (f b)))),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g b = (b, (b = (f b)));;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g f = let xx = f x in (xx, (xx = (f xx)));;\n", "in": "let fixpoint (f,b) = wwhile ((g),b)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((g),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((g),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "in": "let fixpoint (f,b) = wwhile ((g f b),b)", "type": "type", "out": "Error: This expression has type ('a -> 'b) * 'a -> 'b * bool\n       but an expression was expected of type\n         ('a -> 'b) * 'a -> (('a -> 'b) * 'a) * bool\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((g (f, b)),b)", "type": "type", "out": "Error: This function has type ('a -> 'b) * 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g h x = let xx = h x in (xx, (x = (h x)));;\n\nlet _ = g f;;\n", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g h x = let xx = h x in (xx, (x != (h x)));;\n\nlet _ = g f;;\n", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet _ = g f;;\n", "in": "let fixpoint (f,b) = wwhile ((g f),b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let g f x = let xx = f x in (xx, x != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"(\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2\"\n| Times(e1, e2) ->  \"(\" ^ exprToString(e1) ^ \"*\" ^ exprToString(e2) ^ \")\"\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \" + \" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \" * \" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e') -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2) -> \"((\" ^ exprToString(e1) ^ \" + \" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2) ->  exprToString(e1) ^ \" * \" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi * eval(e', x, y))\n| Cosine(e') -> cos(pi * exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) + exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) * exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2) then exprToString(e3) else exprToString(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi * eval(e', x, y))\n| Cosine(e') -> cos(pi * exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) + exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) * exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2)) then exprToString(e3) else exprToString(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. exprToString(e'))\n| Average(e1, e2) -> ((exprToString(e1) +. exprToString(e2))/2)\n| Times(e1, e2) ->  exprToString(e1) *. exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> if (exprToString(e1) < exprToString(e2)) then exprToString(e3) else exprToString(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e'))\n| Average(e1, e2) -> ((eval(e1) +. eval(e2))/2)\n| Times(e1, e2) ->  eval(e1) *. eval(e2)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1) < eval(e2)) then eval(e3) else eval(e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y))/2)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "type": "scope", "out": "Error: Unbound value randX\nHint: Did you mean rand?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()", "type": "scope", "out": "Error: Unbound value randX\nHint: Did you mean rand?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "set _ = build(rand, 5)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 4) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| _ -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| _ -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"\";;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr", "type": "type", "out": "Error: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"}, {"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \n\")*2/(pi^2))\"\n| Asin(e1, e2, e3)      -> \"1\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \")*2/(pi^2))\"\n| Asin(e1, e2, e3)      -> \"1\"", "type": "type", "out": "Error: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| XOR3     of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| Asin     of expr * expr * expr", "type": "type", "out": "Error: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\" ? \" ^ exprToString(e3) ^ \" : \" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ exprToString(e2) ^ \n\")*2/(pi*pi))\"\n| Asin(e1, e2, e3)      -> \"1\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 6) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildAcossin (first_forced, (build (rand, (depth - 1)))));;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "type": "scope", "out": "Error: Unbound value buildAcossin\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Accossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 6) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildAcossin(first_forced, build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e2)", "type": "scope", "out": "Error: Unbound value buildCrazy\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e2;;\n", "in": "let buildX()                       = VarX", "type": "type", "out": "Error: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"}, {"min": "", "in": "let buildY()                       = VarY", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e1)", "type": "type", "out": "Error: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Acossin  of expr * expr\n| Crazy    of expr * expr * expr", "type": "type", "out": "Error: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> exprToString(e1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> Average(e1, e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> eval(Average(e1, e2), x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> eval(Average(e1, e2), x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs(e3) else (-abs(e3))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs e3 else - (abs e3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs_float(e3) else (-abs_float(e3))", "type": "scope", "out": "Error: Unbound constructor VarX\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs_float e3 else - (abs_float e3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then abs_float(eval(e3)) else (-abs_float(eval(e3)))", "type": "scope", "out": "Error: Unbound constructor VarX\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if e1 > e2 then abs_float (eval e3) else - (abs_float (eval e3));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then 1.0 else (-1.0)", "type": "scope", "out": "Error: Unbound constructor VarX\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (e1 > e2) then 1.0 else (-1.0)", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1) > eval(e2)) then eval(e3) else (-eval(e3))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-eval(e3, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else - (eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 * eval(e3, x, y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) * (eval (e3, x, y));;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 60000) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 *. eval(e3, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan2(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan2 res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) + atan(res2) - atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "type": "type", "out": "Error: This expression has type float -> float\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 / (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n(eval(-1.0 *. res3))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n(eval((-1.0) *. res3))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         expr * float * float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         expr * float * float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomColor (8, 1, 1500);;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomColor (8, 1, 1500);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \"\"", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}, {"min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> \"\";;\n", "in": "let buildX()                       = VarX", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)", "type": "scope", "out": "Error: Unbound constructor VarY\n"}, {"min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)", "type": "scope", "out": "Error: Unbound constructor Sine\n"}, {"min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Cosine\n"}, {"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Average\n"}, {"min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "scope", "out": "Error: Unbound constructor Times\n"}, {"min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Thresh\n"}, {"min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "type": "scope", "out": "Error: Unbound constructor Acossin\n"}, {"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (1, 111, 1005);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}, {"min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "in": "let buildX()                       = VarX", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)", "type": "scope", "out": "Error: Unbound constructor VarY\n"}, {"min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)", "type": "scope", "out": "Error: Unbound constructor Sine\n"}, {"min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Cosine\n"}, {"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Average\n"}, {"min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "scope", "out": "Error: Unbound constructor Times\n"}, {"min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Thresh\n"}, {"min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "type": "scope", "out": "Error: Unbound constructor Acossin\n"}, {"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (5, 1315, 666);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}, {"min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "in": "let buildX()                       = VarX", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)", "type": "scope", "out": "Error: Unbound constructor VarY\n"}, {"min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)", "type": "scope", "out": "Error: Unbound constructor Sine\n"}, {"min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Cosine\n"}, {"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Average\n"}, {"min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "scope", "out": "Error: Unbound constructor Times\n"}, {"min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Thresh\n"}, {"min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "type": "scope", "out": "Error: Unbound constructor Acossin\n"}, {"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (8, 543, 35241);;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t\t -> \"x\"\n| VarY\t\t\t -> \"y\"\n| Sine(e')\t\t -> \"sin(pi*\" ^ exprToString(e') ^ \")\"\n| Cosine(e')\t\t -> \"cos(pi*\" ^ exprToString(e') ^ \")\"\n| Average(e1, e2)\t -> \"((\" ^ exprToString(e1) ^ \"+\" ^ exprToString(e2) ^ \")/2)\"\n| Times(e1, e2)\t\t ->  exprToString(e1) ^ \"*\" ^ exprToString(e2)\n| Thresh(e1, e2, e3, e4) -> \"(\" ^ exprToString(e1) ^ \"<\" ^ exprToString(e2) ^ \n\"?\" ^ exprToString(e3) ^ \":\" ^ exprToString(e4) ^ \")\"\n| Acossin(e1, e2)\t -> \"(acos(\" ^ exprToString(e1) ^ \")*asin(\" ^ \nexprToString(e2) ^ \")*2/(pi*pi))\"\n| Crazy(e1, e2, e3)      -> \nlet s1 = exprToString(e1) in\nlet s2 = exprToString(e2) in\nlet s3 = exprToString(e3) in \ns1 ^ \">\" ^ s2 ^ \"?((\" ^\ns1 ^ \"+\" ^ s2 ^ \"+\" ^s3 ^ \")/3:(\" ^ s2 ^ \">\" ^ \ns3 ^ \"?(\" ^ s1 ^ \"*\" ^ s2 ^ \"+\" ^ s1 ^ \")/2:(-\" ^ s3 ^ \")\"", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "in": "let buildX()                       = VarX", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)", "type": "scope", "out": "Error: Unbound constructor VarY\n"}, {"min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)", "type": "scope", "out": "Error: Unbound constructor Sine\n"}, {"min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Cosine\n"}, {"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Average\n"}, {"min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "scope", "out": "Error: Unbound constructor Times\n"}, {"min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Thresh\n"}, {"min": "\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "type": "scope", "out": "Error: Unbound constructor Acossin\n"}, {"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (8, 543, 35241);;\n", "in": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 10) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildAcossin(first_forced, build(rand, depth - 1))\n| _ -> buildCrazy(first_forced, first_forced, first_forced)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomColor (10, 510, 150);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}, {"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. \nasin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then\n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse\n((-1.0) *. res3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildCrazy(e1, e2, e3)\t   = Crazy(e1, e2, e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _ -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l wi\n| (ki, vi)::> \nif ki = k then\nvssoc (d,k,tl)\n|\n\n\neDuplnt list -> int  \n* or more generally, removeDuplicates : 'a list -> 'a lit\n* (removeDuplicates l) is the list of elements of l with uplicates (second,\n* third ... occurrences) removed, and where the remaining lements \n* appear in the same order as in l.\n* e.g. (removeDuplicate [1;6;2;4;12;2;13;6;9]) is [1;6;2;4;2;13;9]\n*\n*  ** your function \"helper\" should be tail recursive **\n* orthis problem only, you may use the library function List.em and List.rev\n*", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []    ->  seen\n| h::t  -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nhelper(seen', t)\nin\nList.rev(helper([], l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = cc;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "type": "scope", "out": "Error: Unbound value cc\n"}, {"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []    ->  seen\n| h::t  -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nhelper(seen', t)\nin\nList.rev(helper([], l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (2, 111, 1005);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}, {"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []    ->  seen\n| h::t  -> \nlet seen' = \nif (List.mem h seen) then\nseen\nelse\nh::seen\nin\nhelper(seen', t)\nin\nList.rev(helper([], l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (ki, vi)::tl ->\nif ki = k then\nvi\nelse \nassoc (d,k,tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
