{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls ->\n      if k = lk then lv else assoc d k ls uncomment after implementing assoc;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls\n\nuncomment after implementing assoc", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc d k l =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc d k l = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * ('d * ('a -> 'b -> 'c)) list * 'e\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * 'd * ('d * ('a -> 'b -> 'c)) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' =  if not (List.mem h seen) then h::seen else seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif not c' then b' else wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) != b), b);;\n", "in": "let fixpoint (f,b) = wwhile (((f b) != b),b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f,(f b) != b),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b else f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if f b = b then b else f b),b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "in": "let fixpoint (f,b) = wwhile ((),b)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "in": "let fixpoint (f,b) = wwhile ((),b)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nmatch c' with\n| false -> b'\n| _ -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n| _ -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun (f,b)  -> if (f b) = b then b else f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         (('a -> 'a) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a) * 'a) * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f b = b),b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (((f b), (f b = b)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else (b, false)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (b, false)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else ( f b, false)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else ( f b, false)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else (f b, false)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) != b then (b, true) else ((f b), false)), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n| true -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun f'-> if f b = b then (b,false) else (f b, true)),b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun f'-> (if f b = b then (b,false) else (f b, true))),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "scope", "out": "Error: Unbound value wwhile2\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "type": "scope", "out": "Error: Unbound value wwhile2\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value wwhile2\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "type": "scope", "out": "Error: Unbound value wwhile\n"}, {"min": "", "in": "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> if (f b) = b then ((f b), false) else ((f b), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> match f b with | b -> ((f b), false) | _ -> ((f b), true)),\n      b);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((fun a -> if b = (f b) then (b,false) else ((f b),true)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun  -> if b = (f b) then (b,false) else ((f b),true)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fphelper),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fphelper f b = if (f b) = b then (b, false) else ((f b), true);;\n\nlet fixpoint (f,b) = wwhile (fphelper, b);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun z -> let b' = (f z) in (b', b' != z)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z)\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"\n| _ -> \"\"", "type": "scope", "out": "Error: Unbound value exprToString\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"\n| _ -> \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,x,y,z) -> if (eval w) < (eval x) then eval y else eval z\n  | Times (x,y) -> (eval x) * (eval y)\n  | Average (x,y) -> ((eval x) * (eval y)) / 2\n  | Cosine x -> cos (pi * (eval x))\n  | Sine x -> sin (pi * (eval x))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)\n| Times (t,u) -> eval(t) * eval(u)\n| Average (t,u) -> (eval(t) * eval(u)) / 2\n| Cosine t -> cos(pi * eval(t))\n| Sine t -> sin(pi * eval(t))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) -> if (eval w) < (eval t) then eval u else eval z\n  | Times (t,u) -> (eval t) * (eval u)\n  | Average (t,u) -> ((eval t) * (eval u)) / 2\n  | Cosine t -> cos (pi * (eval t))\n  | Sine t -> sin (pi * (eval t))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi * eval(t,x,y))\n| Sine t -> sin(pi * eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi * (eval (t, x, y)))\n  | Sine t -> sin (pi * (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "scope", "out": "Error: Unbound value eval\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"}, {"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) *. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) *. eval(u,x,y)) /. 2.0)\n| Cosine t -> (cos(pi *. eval(t,x,y)))\n| Sine t -> (sin(pi *. eval(t,x,y)))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> (cos(pi *. eval(t,x,y)))\n| Sine t -> (sin(pi *. eval(t,x,y)))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper(rand, max_depth, curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX ()\n| 1 -> buildY ()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX \n| 1 -> buildY", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> VarX\n    | 1 -> VarY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build rand (depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build rand (depth - 1))\n    | 3 -> buildCosine (build rand (depth - 1))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,(depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This function has type (int * int -> int) * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> \n\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(2,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(2,6) with\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Tan      of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TupleMod of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Tan      of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TimesMod of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) u )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) u)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "type", "out": "Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildTan(build(rand, (depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n(*| 1 -> buildTan(build(rand, (depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildTan(build(rand, (depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Tan x -> \"tan(pi*\" ^ exprToString(x) ^ \")\"\n| TimesMod (x, y, z) -> \"((\" ^ exprToString(x) ^ \"*\" ^ exprToString(y) ^ \")%\" ^ exprToString(z) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> (mod_float (tan(pi *. eval(t,x,y))) 1.0)\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Tan      of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TimesModOne of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesModOne (w,t,u) -> (mod_float ((eval(w,x,y) *. eval(t,x,y)) *. (eval(u,x,y))) 1.0)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> (mod_float (tan(pi *. eval(t,x,y))) 1.0)\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 1 -> buildTan(build(rand, (depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 1 -> buildTan(mod_float (build(rand, (depth - 1))) 1.0)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildTan(e)\t\t           = (mod_float (Tan(e)) 1.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildCosine(e)                 = Cosine(e)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesModOne (w,t,u) -> (mod_float ((eval(w,x,y) *. eval(t,x,y)) *. (eval(u,x,y))) 1.0)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> (mod_float (tan(pi *. eval(t,x,y))) 1.0)\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| SineSq   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TimesModOne of expr * expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesModOne (w,t,u) -> (mod_float ((eval(w,x,y) *. eval(t,x,y)) *. (eval(u,x,y))) 1.0)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| SineSq t -> (sin(pi *. eval(t,x,y)) *. sin(pi *. eval(t,x,y)))\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildSineSq(build(rand,(depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildSineSq(build(rand,(depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildSineSq(build(rand,(depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesModOne(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' =  if not (List.mem h seen) then h::seen else seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
