{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  (wwhile ((fun x  -> ((f x), (x = (f x)))), b)) *\n    (let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0));;\n", "in": "let fixpoint (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x = f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": " g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in g\nwwhile (g,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x)\nwwhile (g,b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in\nwwhile (g,b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": " f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value assoc\n"}, {"min": "", "in": "let rec wwhile (f,b) = \nlet(i, c) = f(b) in\nif(c = true) then wwhile(f, i) else i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if ( List.mem(h, seen) = true) then let seen' = seen else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if ( List.mem(h, seen) = true) then let seen' = seen in else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if ( List.mem(h, seen) = true) then let seen' = seen else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if ( List.mem(h, seen) = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if (List.mem(h, seen)) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) if (List.mem(h, seen) = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' = *) let x = List.mem(h, seen) in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  let x = List.mem(h, seen) in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  let x = List.mem h seen in if (x = true) then seen' = seen else seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  let x = List.mem h seen in if (x = true) then let seen' = seen else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' =*)  if (List.mem h seen) then let seen' = seen else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \n(*let seen' =*)  if (List.mem h seen) then let seen' = seen in else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else h :: seen(*List.rev(h:: List.rev(seen))*) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else h :: seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if (List.mem h seen) then seen else h :: seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value assoc\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet(i, c) = f(b) in\nif(c = true) then wwhile(f, i) else i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x) in\nwwhile (g,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec ets e s =\n  match e with\n  | VarX  -> ets (e, (s ^ VarX))\n  | VarY  -> ets (e, (s ^ VarY))\n  | Sine  -> ets (e, (s ^ Sine))\n  | Cosine  -> ets (e, (s ^ Cosine))\n  | Average  -> ets (e, (s ^ Average))\n  | Times  -> ets (e, (s ^ Times))\n  | Thresh  -> ets (e, (s ^ Thresh));;\n", "in": "let rec exprToString e = \nets(e, \"\")", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine a -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a, x, y))\n| Cosine (a) -> cos(pi *. eval(a, x, y))\n| Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) / 2)\n| Times (a, b) -> eval(a, x, y) *. eval(b, x, y)\n| Thresh (a, b, c, d) -> if(eval(a, x, y) < eval(b,x ,y)) then  eval(c, x, y) else eval(d, x ,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a, x, y))\n| Cosine (a) -> cos(pi *. eval(a, x, y))\n| Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) / 2.0)\n| Times (a, b) -> eval(a, x, y) *. eval(b, x, y)\n| Thresh (a, b, c, d) -> if(eval(a, x, y) < eval(b,x ,y)) then  eval(c, x, y) else eval(d, x ,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a, x, y))\n| Cosine (a) -> cos(pi *. eval(a, x, y))\n| Average (a, b) -> ((eval(a, x, y) +. eval(b, x, y)) /. 2.0)\n| Times (a, b) -> eval(a, x, y) *. eval(b, x, y)\n| Thresh (a, b, c, d) -> if(eval(a, x, y) < eval(b,x ,y)) then  eval(c, x, y) else eval(d, x ,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let buildX()                       = VarX", "type": "type", "out": "Error: This expression has type expr/1208\n       but an expression was expected of type expr/1436\nError: This expression has type expr/1818\n       but an expression was expected of type expr/1838\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1208\n       but an expression was expected of type expr/1436\n"}, {"min": "", "in": "let buildY()                       = VarY", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "type", "out": "Error: This expression has type expr/1208\n       but an expression was expected of type expr/1436\nError: This expression has type expr/1938\n       but an expression was expected of type expr/1958\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1208\n       but an expression was expected of type expr/1436\n"}, {"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet s = \"\" in\nmatch e with\n| VarX -> s ^ \"x\"\n| VarY -> s ^ \"y\"\n| Sine (a) -> s ^ \"sin(pi*\" ^ exprToString(a) ^\")\"\n| Cosine (a) -> s ^ \"cos(pi*\" ^ exprToString(a) ^ \")\"\n| Average (a, b) -> s ^ \"((\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"/2)\"\n| Times (a, b) -> s ^ exprToString(a) ^ \"*\" ^ exprToString(b)\n| Thresh (a, b, c, d) -> s ^ \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ exprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX else buildY else let x = rand(0, 5) in\nmatch x with\n| 0 -> buildSine(buildX)\n| 1 -> buildCosine(build(rand, depth -1))\n| 2 -> buildAverage(build(rand, depth -1), build(rand, depth -1))\n| 3 -> buildTimes(build(rand, depth -1), build(rand, depth -1))\n| 4 -> buildThresh(build(rand, depth -1), build(rand, depth -1), build(rand, depth -1), build(rand, depth -1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX else buildY else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX else buildY else let x = rand(0, 5) in\nif( x = 0) then buildSine(buildX) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine buildX\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\n(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)\n\n\ndoRandomColor(8, 0, 5)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name) doRandomColor (8, 0, 5);;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "scope", "out": "Error: This function has type\n         (float * float -> float) * (float * float -> float) *\n         (float * float -> float) * int * string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type\n         (float * float -> float) * (float * float -> float) *\n         (float * float -> float) * int * string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| NewA     of expr * expr\n| NewB     of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet s = \"\" in\nmatch e with\n| VarX -> s ^ \"x\"\n| VarY -> s ^ \"y\"\n| Sine (a) -> s ^ \"sin(pi*\" ^ exprToString(a) ^\")\"\n| Cosine (a) -> s ^ \"cos(pi*\" ^ exprToString(a) ^ \")\"\n| Average (a, b) -> s ^ \"((\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"/2)\"\n| Times (a, b) -> s ^ exprToString(a) ^ \"*\" ^ exprToString(b)\n| Thresh (a, b, c, d) -> s ^ \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ exprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"\n| NewA(a, b) -> s ^ \"sin(pi*\"^ exprToString(a) ^ \")*cos(pi*\"^ exprToString(b) ^ \")\"\n| NewB(a, b, c) -> s ^ \"(\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"+\" ^ exprToString(c) ^ \")^0\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet s = \"\" in\nmatch e with\n| VarX -> s ^ \"x\"\n| VarY -> s ^ \"y\"\n| Sine (a) -> s ^ \"sin(pi*\" ^ exprToString(a) ^\")\"\n| Cosine (a) -> s ^ \"cos(pi*\" ^ exprToString(a) ^ \")\"\n| Average (a, b) -> s ^ \"((\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"/2)\"\n| Times (a, b) -> s ^ exprToString(a) ^ \"*\" ^ exprToString(b)\n| Thresh (a, b, c, d) -> s ^ \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ exprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"\n| NewA(a, b) -> s ^ \"sin(pi*\"^ exprToString(a) ^ \")*cos(pi*\"^ exprToString(b) ^ \")\"\n| NewB(a, b, c) -> s ^ \"(\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"+\" ^ exprToString(c) ^ \")-\" ^ \"(\" ^ exprToString(a) ^ \"+\" ^ exprToString(b) ^ \"+\" ^ exprToString(c) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\n(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))\n| 6 -> buildNewA(build(rand, (depth -1)), build(rand, (depth -1)))\n| 7 -> buildNewB(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth - 1)))", "type": "", "out": ""}], "event": "eval"}
