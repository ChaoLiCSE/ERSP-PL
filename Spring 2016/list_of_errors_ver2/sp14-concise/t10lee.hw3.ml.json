{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = a ^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = a ^^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a^^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n           ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun b  -> b) in\n  let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = match x with\n| [] -> (fun b -> b)\nin\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> x a\nin\nlet base = (fun _ x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z d -> x d)\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z d -> x d )\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x  )\nin\nlet base = (fun c y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x  )\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x  )\nin\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z -> x )\nin\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun b -> x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun b a -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x b c = a x in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun b c -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x c = y in let base b = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = ( fun c -> y ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x c = f a x in let base b = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = ( fun c -> f a x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x c = f (a x) in let base b = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = ( fun c -> f (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x c d = a x in let base b = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = ( fun c -> fun d -> (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x x = f (g x) in let base b = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = ( fun x -> f (g x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = ( fun y -> a (y x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = ( fun y -> x (a y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ cc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ cc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "scope", "out": "Error: Unbound value cc\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string -> string -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = h in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string -> string -> string\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string -> string -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ h ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" ^ h ^ \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nList.map f l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nList.map (sepConcat \";\") l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \";\") l;;\n", "in": "let stringOfList f l = \nList.map f (sepConcat \";\") l", "type": "type", "out": "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); h];;\n", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); x];;\n", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = match n with | 0 -> [] | 1 -> [clone x (n - 1); x];;\n", "in": "let rec clone x n = match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = match n with\n| 0 -> []\n| a -> if a < 0 then [] else clone x (n-1) @ [x]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (List.append (clone 0 (List.length l1 - List.length l2)) l2, l1)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (List.append (clone 0 (List.length l1 - List.length l2)) l2, l1)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t;;\n", "in": "let rec removeZero l = match l with\n| [] -> l\n| h::t -> if h = 0 then removeZero t", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t;;\n", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a::x in\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if t1 + t2 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if t1 + t2 then [t1+t2]\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (t1 + t2) > 9 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if t1 + t2 > 9 then [t1+t2]\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [h1 + h2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [h1+h2]\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then []\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [1+h1] @ a\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then [1+h1] @ a\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then false in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then false\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor false does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then 9 in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> 0\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then 9\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> []\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then x a\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list list * int list list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> a\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then x \nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list list * int list list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> a\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list list * int list list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> 0\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list list * int list list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0 :: a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([],[]) -> 0 :: a\n| ([h1::t1],[h2::t2]) -> if h1 + h2 > 9 then a @ x\nin\nlet base = [] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list list * int list list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> 0 | h::t -> if h > 9 then 8 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> 0\n| h::t-> if h > 9 then 8\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (x * x) in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x*x\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a :: x\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x::a\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x\nin\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x\nin\nlet base = 0 in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let a = h :: t in\n      match x with\n      | (x1,x2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet a = h::t in \nmatch x with\n| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)::t2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | (h::t,(x1,x2)::t2) -> if ((x1 + x2) + h) > 9 then 9 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| h -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h1) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h1) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: Variable h1 is bound several times in this matching\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (h2, h1) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> (h2,h1)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\n(add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g)::t ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g::[]) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,[g])-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list -> int * int -> int * int\n       but an expression was expected of type\n         int * 'a list -> int * int -> int * 'a list\n       Type int is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newcarry, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newcarry, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value newcarry\nHint: Did you mean carry?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit =\n        match x with | (f,g) -> ((f + g) + carry) mod 10 | [] -> carry in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\n| []   -> carry\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g::h)-> g\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, newc::digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (newc, digit::q)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (newc, digit::q)\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (0, newc::digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (0, newc::digit::q)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f, []) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p::q) -> (0, newc::digit::q)\n| (o,p) -> (0, newc::digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else\n    (let a = [i] in bigAdd ((mulByDigit i) - (1 l)) ((mulByDigit i) - (1 l)));;\n", "in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = bigAdd a x in\nlet base = [] in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd a x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd a x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin List.rev unzeroed", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ =\n  let unzeroed =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n    constructargs [] [1; 2; 3] (List.rev [4; 5; 6]) in\n  let rec addZeroes num somelist =\n    match num with\n    | 0 -> somelist\n    | _ -> addZeroes (num - 1) (List.append somelist 0) in\n  let rec addZeroesWhole acc a =\n    match a with\n    | [] -> acc\n    | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n  addZeroesWhole [] unzeroed;;\n", "in": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist 0)\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l1)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then 0 else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "in": "let rec mulByDigit i l = \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed\nin\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
