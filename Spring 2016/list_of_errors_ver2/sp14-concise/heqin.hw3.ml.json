{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a*a + xs in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = a in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = a in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x inner = (y |> a) |> x in\n  let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun inner -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a t)) in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a t in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type (string list -> string) -> 'a -> string\n       but an expression was expected of type\n         (string list -> string) -> 'a -> string list -> string\n       Type string is not compatible with type string list -> string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^h in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map f l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map f l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" List.map f l;;\n", "in": "let stringOfList f l = sepConcat \"[\" List.map f l", "type": "type", "out": "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"[\" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \" \" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = let st = sepConcat \";\" (List.map f l) in \"[\" ^ st ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = let st = sepConcat \"; \" (List.map f l) in \"[\" ^ st ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map f l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = let mid = List.map f l in \"[\" ^ (mid \"]\");;\n", "in": "let stringOfList f l = let mid = List.map f l in \"[\" ^ mid \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "in": "let stringOfList f l = sepConcat \"; \" List.map f l", "type": "type", "out": "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = let mid = sepConcat \"; \" (List.map f l) in \"[\" ^ mid ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x::clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let f a l = a + (1 l) in let base = a in List.fold_left f base;;\n", "in": "let padZero l1 l2 = \nlet f a l = a+1 l in \nlet base = a\nin List.fold_left f base", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) acc l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) acc l2 in\n  if length1 < length2 then true else false;;\n", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in\nif length1 < length2 then true\nelse false", "type": "scope", "out": "Error: Unbound value acc\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2-length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1 - length2) 0", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone 0 (length2 - length1)\n  else if length2 < length1 then clone 0 (length1 - length2);;\n", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone 0 (length2 - length1) \nelse if length2 < length1\nthen clone 0 (length1 - length2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with\n  | [] -> 0\n  | x::l' -> if x = 0 then List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l;;\n", "in": "let rec removeZero l = match l with\n| [] -> 0\n| x::l' -> if x = 0\nthen List.fold_left (fun acc x -> acc+1) 0 l", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| x::l' -> \nif x=0 \nthen removeZero l'\nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, a) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet l = dig :: a in\ncarry, l in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet l = dig :: acc in\ncarry, l in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch acc with\n| []   -> (carry2, carry2 :: dig :: [])\n| h::t -> (carry2, carry2 :: dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch acc with\n| []   -> (carry2, dig :: [])\n| h::t -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> [carry2; dig] | h::t -> carry2 :: dig :: t in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| []   -> (carry2::dig :: [])\n| h::t -> (carry2::dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> (carry2, [dig]) | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| []   -> (carry2, dig :: [])\n| h::t -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in match a with | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| h::t -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| (x,y) -> (carry2, dig :: t) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| (x,y) -> (carry2, dig :: y) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet mid = dig::acc in\n(carry, mid) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet mid = dig::acc in\n(carry2, mid) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet mid = dig::acc in\n(carry2, carry2::mid) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, (carry2 :: dig)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carry2, carry2::dig) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carry2, carry2::dig::[]) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch acc with\n| []   -> (carry2, carry2::dig::[])\n| x::y -> (carry2, carry2::dig::y) in \nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (d1,d2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in (carryOut, (dig :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value x1\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet r = dig::acc in\n(carryOut, r) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\nlet r = dig::acc in\n(carryOut, r) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| _ -> bigAdd l (mulByDigit (i-1) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd prod acc in ((i + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value i\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value i\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ (clone 0 carry) in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ (clone 0 carry) in\nlet result = bigAdd acc prod in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet y = mulByDigit dig l1 @ (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append mulByDigit dig2 l1 (clone 0 carry) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append mulByDigit dig2 l1 (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value carry\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value carry\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd (y) (acc)) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd y acc) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd y acc) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd y acc) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
