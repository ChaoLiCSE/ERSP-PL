{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (2)\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then 0 else 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (h :: seen) in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if mem h l then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (mem h l) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value mem\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not l.mem h then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (l.mem h) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if not (l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound record field mem\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(l.mem h) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound record field mem\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a ref\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!(List.mem h seen)) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a ref\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::[]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [2] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([2]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a ref\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (int, bool) -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if (b) then wwhile (f, a) else a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f with\n| (a, b) -> if (b) then wwhile (f, b) else a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if (b) then wwhile (f, b) else a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if (b) then wwhile (f, a) else a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint (f, b)),b)", "type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (((fixpoint f), b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint f,b),b)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "in": "let fixpoint (f,b) = wwhile (b,b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "in": "let fixpoint (f,b) = wwhile (b,b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile (f,f b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f a), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f a),b)", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f ),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b)", "type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint ((f b), b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b))", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, (f b))), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b))", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, (f b))), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)))", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (not (f b)) = b then b else fixpoint (f, b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))))", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((fixpoint (f, b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b))", "type": "scope", "out": "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else wwhile (f, (f b)));;\n", "in": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b))", "type": "type", "out": "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         (('a -> 'a * bool) * 'a) * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (b, b));;\n", "in": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), a);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a)", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then 1 else 0)), b);;\n", "in": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = f x in ((x, (x = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> x), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun x -> x ), b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\" VarX", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\"", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> printf \"%s\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> printf \"%s\"", "type": "scope", "out": "Error: Unbound value printf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "in": "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "in": "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> sprintf \"%s\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> sprintf \"%s\" s", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> printf \"%s\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> printf \"%s\" s", "type": "scope", "out": "Error: Unbound value printf\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.printf \"%s\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.printf \"%s\" s", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%s\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%s\" VarX", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%VarX\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%VarX\" VarX", "type": "type", "out": "Error: invalid format \"%VarX\": at character number 1, invalid conversion \"%V\"\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf VarX", "type": "type", "out": "Error: This variant expression is expected to have type\n         ('a, Format.formatter, unit) format\n       The constructor VarX does not belong to type CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.print VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.print VarX", "type": "scope", "out": "Error: Unbound value Format.print\nHint: Did you mean printf?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%expr\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%expr\" VarX", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%float\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"%float\" VarX", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.sprintf \"%float\" VarX;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Format.sprintf \"%float\" VarX", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" Sine;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%expr\" Sine", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%expr\" s", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%expr\" s", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.142 * e));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * e));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3 * 2));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0));;\n", "in": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (s ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ s ^ \")\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%expr\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" s ^ \")\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" 1.0 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%_\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%_\" s  ^ \")\"", "type": "type", "out": "Error: invalid format \"%_\": at character number 2, unexpected end of format\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%\" s  ^ \")\"", "type": "type", "out": "Error: invalid format \"%\": at character number 1, unexpected end of format\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%\" s  ^ \")\"", "type": "type", "out": "Error: invalid format \"%\": at character number 1, unexpected end of format\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%f\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%f\" s  ^ \")\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%i\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%i\" s  ^ \")\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%expr\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%expr\" s  ^ \")\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%e\" s) ^ \")\");;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%e\" s  ^ \")\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \" ? \" ^ (exprToString h3) ^ \" : \" ^ (exprToString h4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \n\" ? \" ^ (exprToString h3) ^ \" : \" ^ (exprToString h4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \n\"?\" ^ (exprToString h3) ^ \":\" ^ (exprToString h4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (2.0, 4.0);;\n", "in": "let mine = buildAverage(2.0, 4.0)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mine = buildAverage(VarX, VarY)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mine = buildAverage(VarX, VarY)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> let vx = x in vx\n  | VarY  -> let vy = y in vy\n  | Average  -> buildAverage (vx, vy);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in vx \n| VarY -> let vy = y in vy\n| Average -> buildAverage(vx,vy)", "type": "type", "out": "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> eval (VarX, a1, a2);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval (VarX,a1,a2))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> a1 + a2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (a1 + a2)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, a1, a2)) + (eval (VarY, a1, a2));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) + (eval (VarY, a1, a2));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, a1, a2));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin s1\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (e,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) / 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval(s1,x,y))\n| Cosine (c1) -> cos (eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = rand (1,4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) = rand (1, 4);;\n\nlet _ = build (rand, 4);;\n", "in": "build (rand, 4)", "type": "scope", "out": "Error: Unbound value rand\nHint: Did you mean land?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "build (makeRand (10,39), 4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = rand (1,4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = rand (1,7)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> 1\n| 2 -> 2\n| 3 -> 3\n| 4 -> 4\n| 5 -> 5\n| 6 -> 6\n| 7 -> 7", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "build (makeRand (10,39), 4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> 11\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> VarX\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX (buildY ())\n  | 2 -> buildY ()\n  | 3 -> buildX ()\n  | 4 -> buildY ()\n  | 5 -> buildX ()\n  | 6 -> buildY ()\n  | 7 -> buildX ();;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildSine(buildX())\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))\n| 1 -> buildSine(buildX())\n| 2 -> buildSine(buildX())\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))\n| 1 -> buildSine(buildX())\n| 2 -> buildSine(buildX())\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine()\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ ->\n      buildTimes\n        ((buildCosine (buildSine (buildX ()))),\n          (buildCosine (buildSine (buildX ()))))\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildSine ()\n  | 4 -> buildSine (buildX ())\n  | 5 -> buildSine (buildX ())\n  | 6 -> buildSine (buildX ())\n  | 7 -> buildSine (buildX ());;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())", "type": "type", "out": "Error: This variant expression is expected to have type expr\n       The constructor () does not belong to type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(build(rand, depth))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( if (depth = 0) then buildX() else build(rand, depth - 1), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        (if depth = 0\n         then buildX ()\n         else\n           ((build (rand, (depth - 1))),\n             (if depth = 0 then buildY () else build (rand, (depth - 1)))))\n  | 6 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n  | 7 ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ( (if (depth = 0) then buildX() else build(rand, depth)), (if (depth = 0) then buildY() else build(rand, depth)))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> Format.printf \"%f\" rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> Format.printf \"%f\" rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildX()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine (VarX, VarY)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine(VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildSine(VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine(Average(VarX,VarY))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine(VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildCosine()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildAverage(VarX,VarY)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX,VarY)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildTimes VarX\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let myexpr = Cosine (VarX)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand (1,5)) with\n| 1 -> buildX()\n| 2 -> buildX()\n| 3 -> buildX()\n| 4 -> buildX()\n| 5 -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,6)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,5)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,4)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1) * buildY())\n| 2 -> buildCosine(build(rand, depth - 1) * buildX())\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 5) with\n     | 1 -> buildSine ((build (rand, (depth - 1))) * (buildY ()))\n     | 2 -> buildCosine ((build (rand, (depth - 1))) * (buildX ()))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,2)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,5)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Divide3   of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif (depth = 0) \nthen match (rand(1,3)) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse match (rand(1,7)) with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildDivide3(build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildMyOp(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f 3, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet _ =\n  let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile ((f 3), 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "type", "out": "Error: This expression has type int * bool\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = f 2;;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = f 2;;\n", "in": "let fixpoint (f,b) = wwhile ((f,b), b)", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f,b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f, b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ( (let f x =  in f), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != 100)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != 100)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != 100)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let xx = x*x*x in (xx, xx != 100)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != f x)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != f x)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = let x = b in (x, x != f x)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let f x = let x = b in (x, (x != (f x))) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let h x = let x = b in (x, (x != (f x))) in wwhile (h, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = let h x = (b, (b != (f b))) in wwhile (h, b);;\n", "in": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = let h x = (b, (b != (f b))) in wwhile (h, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = let h b = (b, (b != (f b))) in wwhile (h, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (h, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = let f x = (x, (x != (f x))) in wwhile (h, b);;\n", "in": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (f, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = let f x = (x, (x != (f x))) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, x)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, x);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "in": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (g, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nlet a x = let xx = (f x) in (xx, xx != x)  in\nwwhile (a, b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let a x = let xx = f x in (xx, (xx != x)) in wwhile (a, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
