{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left ( + ) 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left ( + ) 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else a :: (digitsOfInt n);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: digitsOfInt n", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else n % 10;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n%10", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse n mod 10", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else h :: ((digitsOfInt n) mod 10);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse h:: digitsOfInt n mod 10", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else (digitsOfInt n) mod 10;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt n mod 10", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [(digitsOfInt (n / 10)) mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) mod 10 :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then n\nelse digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then n\nelse digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then 1\nelse digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then 1\nelse digitsOfInt (n mod 10) in\ndigitsOfInt [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n", "in": "let digitsOfInt n = \nlet rec digit acc d =\nif d < 10 then d::acc\nelse digit ((d mod 10)::acc) (d/10) in\ndigit [] d", "type": "scope", "out": "Error: Unbound value d\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "scope", "out": "Error: Unbound value d\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit (n/10) ((n mod 10)::acc) in\ndigit [] n", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "type", "out": "Error: This expression has type char but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nn [] digit", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] digit", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| n < 10 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n == 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n == 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n = 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n = 0 then acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> []\n| _ -> digit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec dig n =\nif n < 10 then n\nelse 1+ dig ((n mod 10) + dig (n/10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\ndigitalRoot n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot n\nelse n in digitalRoot n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot n else n in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse n in digitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "in": "let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse n in digitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot x", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then 1 + digitalRoot x\nelse 1 in \ndigitalRoot n", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then 1 + (digitalRoot x) else 1 in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "in": "let digitalRoot n = \nif n < 10 then n\nelse \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10) in\nlet x = digits n in\nif x > 9 then digitalRoot x\nelse 1 in \ndigitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits(n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = \nif n < 10 then n\nelse (n mod 10) + digitalRoot (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse (n mod 10) + digitalRoot (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "in": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse 1 in\naddTimes n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n =\nif n < 10 then n\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then n\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n =\nif n < 10 then n\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then addTimes x\nelse x in\naddTimes n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l);;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::l' -> 1 + listReverse l'", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l');;\n", "in": "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse _", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> _ + listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "in": "let rec listReverse l = match l with\n| 0 -> []\n| _::tl -> listReverse tl + tl", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> listReverse l\n| _::tl -> listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper a l = match l with\n| [] -> a\n| _::tl -> reverseHelper a tl\nin reverseHelper 0 l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper l tl = match l with\n| [] -> []\n| _::tl -> reverseHelper tl l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> 0\n| hd::l -> listReverse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper acc = \nif [] then acc\nelse h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper acc = if [] then acc else reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "in": "let listReverse l = \nlet rec reverseHelper acc = \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "type": "type", "out": "Error: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "in": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| e :: l -> e + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if w = (listReverse w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n", "in": "let palindrome w = \nif explode w = listReverse w then true\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "in": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd :: l -> hd + sumList l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "in": "let listReverse l = \nlet rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::acc) in\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper ln lo =\n    match ln with | [] -> lo | h::t -> reverseHelper t (h :: acc) in\n  reverseHelper l [];;\n", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "type": "scope", "out": "Error: Unbound value acc\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper lst newList =\nmatch lst with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper lst newList =\nmatch lst with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper lst []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper lst newList =\n    match lst with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper lst [];;\n", "in": "let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []", "type": "scope", "out": "Error: Unbound value lst\nHint: Did you mean fst, lsl or lsr?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
