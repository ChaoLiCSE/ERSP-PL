{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = False then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(h,seen) = False then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound constructor False\nHint: Did you mean false?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(h,seen) = false then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen @ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen @ h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then seen @ [h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen= false then [h]@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then seen@ [h] else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) = match f with | (x,true ) -> f x | (x,false ) -> x;;\n", "in": "let rec wwhile (f,b) = match f with\n| (x,true) -> f x\n| (x,false) -> x", "type": "type", "out": "Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f with | (x,true ) -> wwhile (f x) | (x,false ) -> x;;\n", "in": "let rec wwhile (f,b) = match f with\n|(x,true) -> wwhile(f x)\n| (x,false) -> x", "type": "type", "out": "Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) = match f with | (n,boo) -> f b;;\n", "in": "let rec wwhile (f,b) = match f with\n(n,boo) -> f b", "type": "type", "out": "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f with\n| (x,false)->x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f with\n| (x,false)->x\n| (x,true) -> wwhile(f,x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "type": "type", "out": "Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = fixpoint (collatz, 1);;\n", "in": "\nlet _ = fixpoint (collatz, 1) ", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x != b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((\nlet (x,y) = f b in (x!=b)),b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x <> b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((\nlet (x,y) = f b in (x<>b)),b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x > b) or (x < b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((\nlet (x,y) = f b in (x>b or x<b)),b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, y) else if x = b then (x, false)),\n      b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y) = f b in\nif x<>b && y=true then (x,y)\nelse if x=b then ( x,false)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, true) else if x = b then (x, false)),\n      b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y) = f b in\nif x<>b && y=true then (x,true)\nelse if x=b then ( x,false)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = fixpoint (collatz, 1);;\n", "in": "\nlet _ = fixpoint (collatz, 1) ", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = fixpoint (collatz, 1);;\n", "in": "\nlet _ = fixpoint (collatz, 1) ", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = fixpoint (collatz, 1);;\n", "in": "\nlet _ = fixpoint (collatz, 1) ", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = ((f b) - 1)) then (b, false) in\n      f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = (f (b - 1))) then (b, false) in\n      f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x <> b) && ((x, y) <> (f (b - 1)))))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x <> b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x > b) || (x < b)))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x < 100))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx<>x)in a),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY @ (\"/\" @ VarX)\n  | Cosine  -> VarX @ (\"/\" @ VarY);;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY@\"/\"@VarX\n| Cosine -> VarX@\"/\"@VarY", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY ^ (\"/\" ^ VarX)\n  | Cosine  -> VarX ^ (\"/\" ^ VarY);;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY^\"/\"^VarX\n| Cosine -> VarX^\"/\"^VarY", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString VarX\n  | Cosine  -> exprToString e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString VarX\n| Cosine -> exprToString e", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine  -> exprToString e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine -> exprToString e", "type": "type", "out": "Error: The constructor Cosine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "type": "type", "out": "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((\"<\" exprToString e2) ^\n              (\" ? \" ^\n                 ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\"))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarX, VarY);;\n", "in": "let aa = exprToString Average(VarX, VarY)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarX, VarY);;\n", "in": "let aa =exprToString Average(VarX, VarY)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let aa =exprToString VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarY, VarX);;\n", "in": "let aa =exprToString Average(VarY,VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"((\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine  -> buildSine e;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine -> buildSine(e)", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine e;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(e)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine x;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(x)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> 0.34 * e;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> 0.34*e", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> build (pi * e);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX * 1.0 | VarY  -> buildY * 1.0;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX * 1.0\n| VarY -> buildY * 1.0", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX * 1.0;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX * 1.0", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> (buildX ()) * 1.0;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX() * 1.0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x * 1.0;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x * 1.0", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> pi * e;;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> pi*e", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> buildSine(e)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine e -> buildSine(e)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine e -> buildSine(e)\n| Cosine e -> buildCosine (e)\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine e -> buildSine(e)\n| Cosine e -> buildCosine (e)\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e -> buildSine e\n  | Cosine e -> buildCosine e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}, {"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> buildSine(e)\n| Cosine e -> buildCosine (e)\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x * 1.00\n  | VarY  -> y * 1.00\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x*1.00\n| VarY -> y*1.00\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float * x\n  | VarY  -> float * y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> float*x\n| VarY -> float*y\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "type": "type", "out": "Error: This expression has type int -> float\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*e\n| Cosine e -> pi*e\n| Average (e1,e2) -> buildAverage(e1,e2)\n| Times (e1,e2) -> buildTimes(e1,e2)\n| Thresh (e1,e2,e3,e4) -> buildThresh(e1,e2,e3,e4)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1+.e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (float (e1 + e2)) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float)(e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((float_of_int e1) +. (float_of_int e2)) / 2\n  | Times (e1,e2) -> (float_of_int e1) *. (float_of_int e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((float_of_int e1) < (float_of_int e2 ?float_of_int e3) : float_of_int\n                                                                  e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2\n| Times (e1, e2)-> float_of_int e1*.float_of_int e2\n| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2) -> (e1+e2)/2 \n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (e1+.e2)/2 \n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> buildAverage(e1,e2)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2) -> buildAverage(e1,e2)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) + (e2 * 1.00)) /. 2.0;;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) +. (e2 * 1.00)) /. 2.0;;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (evail (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (evail (e2, x, y));;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)", "type": "scope", "out": "Error: Unbound value evail\nHint: Did you mean eval?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> eval(e,x,y)\n| VarY -> eval(e,x,y)\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = eval ((Sine VarX), (pi /. 2.0), 0.0);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.e\n| Cosine e-> pi*.e\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "scope", "out": "Error: Unbound value eval\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = eval ((Sine VarX), (pi /. 2.0), 0.0);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,VarX,VarY)\n| Cosine e-> pi*.eval(e,VarX,VarY)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "scope", "out": "Error: Unbound value eval\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, VarX, VarY))\n  | Cosine e -> pi *. (eval (e, VarX, VarY))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.eval(e,x,y)\n| Cosine e-> pi*.eval(e,x,y)\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "scope", "out": "Error: Unbound constructor VarX\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = eval ((Sine VarX), 0.5, (-0.5));;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "scope", "out": "Error: Unbound value eval\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "scope", "out": "Error: Unbound value buildCosine\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n", "in": "let rec build (rand, depth) = match build with\n| buildX()\n| buildY()", "type": "scope", "out": "Error: Unbound value emitGrayscale\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse helper(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse helper(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"}, {"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match rand depth with | (1,d) -> (d = (d - 1)) && (buildX ());;\n", "in": "let rec build (rand, depth) = match rand depth with", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (1,d) -> (d = (d - 1)) && (buildX ())\n  | (2,d) -> (d = (d - 1)) && (buildY ());;\n", "in": "let rec build (rand, depth) = \nmatch rand depth with\n| (1,d) -> d=(d-1) && buildX()\n| (2,d) -> d=(d-1) && buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) =\n  match rand depth with | (r,0) -> build (r, 0) | (r,d) -> (r, (d - 1));;\n", "in": "let rec build (rand, depth) = match rand depth with", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a * int\n       The type variable 'a occurs inside 'b -> 'a * int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand, depth) with", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet build(rand) = if rand=1 then buildX() else buildY()\nin (depth-1,depth>0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let build r = if r = 1 then buildX () else buildY () in\n    ((depth - 1), (depth > 0)) in\n  build r;;\n", "in": "let rec build (rand, depth) = \nlet build(r) = if r=1 then buildX() else buildY() in (depth-1,depth>0)\nin build(r)", "type": "scope", "out": "Error: Unbound value r\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let build r = if r = 1 then buildX () else buildY () in\n    ((depth - 1), (depth > 0)) in\n  build r;;\n", "in": "let rec build (rand, depth) = match rand depth with\nif r=1 then buildX() else buildY() in (depth-1,depth>0)", "type": "scope", "out": "Error: Unbound value r\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((depth - 1), (depth > 0)) in\n  buildd (rand, depth);;\n", "in": "let rec build (rand, depth) = \nlet buildd(r,d) = if r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(build(r,d))\nelse if r=4 then buildCosine(build(r,d))\nelse if r=5 then buildTimes(build(r1,d1),build(r2,d2))\nelse buildThresh(build(r1,d1), build(r2,2), build(r2,d2), build(r2,d2)) in (depth-1,depth>0)\nin buildd(rand,depth)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((depth - 1), (depth > 0)) in\n  buildd (rand, depth);;\n", "in": "let rec build (rand, depth) = \nlet buildd(r,d) = \nif r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(build(r,d))\nelse if r=4 then buildCosine(build(r,d))\nelse if r=5 then buildTimes(build(r1,d1),build(r2,d2))\nelse buildThresh(build(r1,d1), build(r2,2), build(r2,d2), build(r2,d2)) in (d-1,d>0)\nin buildd(rand,depth)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "in": "let rec build (rand, depth) = \nlet buildd(r,d) = \nif r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(buildd(r,d))\nelse if r=4 then buildCosine(buildd(r,d))\nelse if r=5 then buildTimes(buildd(r1,d1),buildd(r2,d2))\nelse buildThresh(buildd(r1,d1), buildd(r2,2), buildd(r2,d2), buildd(r2,d2)) in (d-1,d>0)\nin buildd(rand,depth)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (buildd (r, d))\n          else\n            if r = 4\n            then buildCosine (buildd (r, d))\n            else\n              if r = 5\n              then buildTimes ((buildd (r1, d1)), (buildd (r2, d2)))\n              else\n                buildThresh\n                  ((buildd (r1, d1)), (buildd (r2, 2)), (buildd (r2, d2)),\n                    (buildd (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "in": "let rec build (rand, depth) = \nlet rec helper (r,d) = \nif r=1 then buildX()\nelse if r=2 then buildY()\nelse if r=3 then buildSine(helper(r1,d1))\nelse if r=4 then buildCosine(helper(r1,d1))\nelse if r=5 then buildAverage (helper(r1,d1),helper(r2,d2))\nelse if r=6 then buildTimes(helper(r1,d1),helper(r2,d2))\nelse buildTresh(helper(r1,d1),helper(r2,d2),helper(r3,d3),helper(r4,d4))\nin (d,d>=0)\nin helper(rand,depth)", "type": "scope", "out": "Error: Unbound value buildd\nHint: Did you mean build, buildY or buildX?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let rec helper (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (helper (r1, d1))\n          else\n            if r = 4\n            then buildCosine (helper (r1, d1))\n            else\n              if r = 5\n              then buildAverage ((helper (r1, d1)), (helper (r2, d2)))\n              else\n                if r = 6\n                then buildTimes ((helper (r1, d1)), (helper (r2, d2)))\n                else\n                  buildTresh\n                    ((helper (r1, d1)), (helper (r2, d2)), (helper (r3, d3)),\n                      (helper (r4, d4))) in\n    (d, (d >= 0)) in\n  helper (rand, depth);;\n", "in": "let rec build (rand, depth) = ", "type": "scope", "out": "Error: Unbound value r1\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let rec helper (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (helper (r, d))\n          else\n            if r = 4\n            then buildCosine (helper (r1, d1))\n            else\n              if r = 5\n              then buildAverage ((helper (r1, d1)), (helper (r2, d2)))\n              else\n                if r = 6\n                then buildTimes ((helper (r1, d1)), (helper (r2, d2)))\n                else\n                  buildTresh\n                    ((helper (r1, d1)), (helper (r2, d2)), (helper (r3, d3)),\n                      (helper (r4, d4))) in\n    (d, (d >= 0)) in\n  helper (rand, depth);;\n", "in": "let rec build (rand, depth) = \nlet buildd(r,d) = \nif r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(buildd(r1,d1-1))\nelse if r=4 then buildCosine(buildd(r1,d1-1))\nelse if r=5 then buildTimes(buildd(r1,d1),buildd(r2,d2))\nelse buildThresh(buildd(r1,d1), buildd(r2,2), buildd(r2,d2), buildd(r2,d2)) in (d-1,d>0)\nin buildd(rand,depth)", "type": "scope", "out": "Error: Unbound value r1\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (buildd (r1, (d1 - 1)))\n          else\n            if r = 4\n            then buildCosine (buildd (r1, (d1 - 1)))\n            else\n              if r = 5\n              then buildTimes ((buildd (r1, d1)), (buildd (r2, d2)))\n              else\n                buildThresh\n                  ((buildd (r1, d1)), (buildd (r2, 2)), (buildd (r2, d2)),\n                    (buildd (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if !List.mem h seen then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value buildd\nHint: Did you mean build, buildY or buildX?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,seen)=false then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(seen,h)=false then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (seen, h)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(h,seen) then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem(seen h) then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (seen h) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value seen'\nHint: Did you mean seen?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@ seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then [h]@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then h@[seen] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ [seen] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen @ h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen @ [h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen[] @ [h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then (seen []) @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then [seen]@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [seen] @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)=false then seen@[h] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (r,depth) ->\n      (match r (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (r, (depth - 1)))\n       | 3 -> buildCosine (build (r, (depth - 1)))\n       | 4 ->\n           buildAverage ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 5 -> buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (r, (depth - 1))), (build (r, (depth - 1))),\n               (build (r, (depth - 1))), (build (r, (depth - 1)))));;\n", "in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match rand depth with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "type": "scope", "out": "Error: Unbound value depth\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 7) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "type": "scope", "out": "Error: Unbound value depth\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 7) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "type": "scope", "out": "Error: Unbound value depth\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (_,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (rand, (depth - 1)))\n         | 3 -> buildCosine (build (rand, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         | 5 ->\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "scope", "out": "Error: Unbound value depth\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet c3 () = doRandomColor (9, 21, 12);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1/.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1/.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| ArcSine  of expr\n| ArcCosine of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "type", "out": "Error: This variant pattern is expected to have type expr\n       The constructor ArcSine does not belong to type expr\nHint: Did you mean Sine?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| ArcSine e -> \"arcsine(1/sin(pi*\"^ exprToString e^\"))\"\n| ArcCosine e->\"arcCosine(1/cos(pi*\"^ exprToString e^\"))\"\n| Average (e1,e2) ->\"((\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1/.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1/.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1./.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1./.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\n(*\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1./.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1./.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)\n*) \"fail with\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\n\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| ArcSine e -> 1./.sin(pi*.eval(e,x,y))\n| ArcCosine e ->1./.cos(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
