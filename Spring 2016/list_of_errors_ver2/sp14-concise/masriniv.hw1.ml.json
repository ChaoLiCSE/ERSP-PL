{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumfist\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n <= 0 with | true  -> [] | false  -> 1;;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> 1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10]\n  | true  -> [];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| false -> (digitsOfInt n/10) @ [n%10]\n| true -> []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> [(digitsOfInt n) / 10; n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) :: [n%10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10] @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [digitsOfInt n/10] @ [n%10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [n % 10] @ ((digitsOfInt n) / 10);;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [n%10] @ digitsOfInt n/10", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt n div 10; n mod 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "type": "type", "out": "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10; n mod 10];;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 :: [n mod 10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> n mod 10 :: digitsOfInt n/10", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> n mod 10 :: (digitsOfInt n/10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt n/10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) - 10);;\n", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt n - 10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt (n/10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> n mod 10 :: digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| (h :: t) -> h :: listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| (h :: t) -> h :: listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | h::[] -> h | h::t -> [listReverse t; h];;\n", "in": "let rec listReverse l =\nmatch l with\n| (h :: []) -> h\n| (h :: t)  -> listReverse t :: [h]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> h :: listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> [h; listReverse t];;\n", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t::[]", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;\n", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (_ :: h :: [])  -> h :: listReverse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> t :: listReverse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> listReverse (n mod 10 :: digitsOfInt (n/10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> appendLists(listReverse t, [h])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> appendLists(digitsOfInt (n/10), [n mod 10])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> appendLists(digitsOfInt (n/10), [n mod 10])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch arrayLen (digits n) = 1 with\n| true -> 0\n| false -> 1 + additivePersistence (digitSum (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nmatch arrayLen (digits n) = 1 with\n| true -> n\n| false -> digitalRoot (digitSum (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> appendLists(digitsOfInt (n/10), [n mod 10])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif (explode(w)) = (listReverse explode(w))\nthen true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif (explode(w)) = (listReverse explode(w))\nthen true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = palindrome \"myxomatosis\";;\n", "in": "let palindrome w = \nif (explode(w)) = (listReverse (explode(w)))\nthen true\nelse false", "type": "scope", "out": "Error: Unbound value palindrome\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif explode(w) = listReverse (explode(w))\nthen true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif explode(w) = listReverse (explode w)\nthen true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
