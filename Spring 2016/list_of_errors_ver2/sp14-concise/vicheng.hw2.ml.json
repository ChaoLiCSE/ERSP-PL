{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = ((wwhile (wwhile (f, (f b)))), b);;\n", "in": "let fixpoint (f,b) = wwhile(wwhile(f, f b)),b", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}, {"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile(f, f b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}, {"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile(f, f (b))", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}, {"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile(f (f b), b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "in": "let fixpoint (f,b) = wwhile(f,f b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}, {"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile(f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile(f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then helper (seen,t)\nelse h::seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((ffixpoint (f, (f b))), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(ffixpoint(f, f b), b)", "type": "scope", "out": "Error: Unbound value ffixpoint\nHint: Did you mean fixpoint?\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((((fixpoint (f, (f b))) * (f b)) = b), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b)*f b = b, b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b = b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), (f b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),f b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile((fixpoint(f, f b),(f b) = b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(fixpoint(f, f b), b)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec fixpoint (f,b) = wwhile(f, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(f, (f b = b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(f (f b = b), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f * ((f b) = b)), b);;\n", "in": "let rec fixpoint (f,b) = wwhile(f * (f b = b), b)", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile(f (f b = b), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile(f, (f b = b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f (f b = b)), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f :: ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f::(f b = b)), b)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (f, b));;\n", "in": "let fixpoint (f,b) = wwhile(if f b = b then f, b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile(if f b = b then f b, b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) != b then ((fixpoint (f, (f b))), b));;\n", "in": "let fixpoint (f,b) = wwhile(if f b != b then fixpoint(f, f b), b)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f, b);;\n", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f, b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f, f b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "in": "let fixpoint (f,b) = wwhile((f f b), b)", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (((f b), b), b);;\n", "in": "let fixpoint (f,b) = wwhile((f b, b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f, f b = b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile((f, (f b) = b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile(fun x -> (f b, (f b) = b), b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) = b)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile((fun x ->  (f b, (f b) != b)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), ((f b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> (f, ((f b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "in": "let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) = wwhile (fun b  -> ((f b), ((f b) != b), b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "in": "let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)", "type": "scope", "out": "Error: Unbound value removeDuplicates\n"}, {"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)) , b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf\"%s\" e", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> sprintf(%s) e", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Output.sprintf(\"%s\") e", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Output.sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Module.sprintf(\"%s\") e", "type": "scope", "out": "Error: Unbound module Output\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Module.sprintf \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"\"\n| Sine  \n| Cosine   \n| Average  \n| Times    \n| Thresh", "type": "scope", "out": "Error: Unbound module Module\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e \n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e)          -> \"%s\" e \n| Cosine (e)        -> \"%s\" e\n| Average (e,e)     -> \"%s\" e\n| Times (e,e)       -> \"%s\" e\n| Thresh (e,e,e,e)  -> \"%s\" e", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e -> \"%s\" e\n  | Cosine e -> \"%s\" e\n  | Average (e,e) -> \"%s\" e\n  | Times (e,e) -> \"%s\" e\n  | Thresh (e,e,e,e) -> \"%s\" e;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: Variable e is bound several times in this matching\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.printf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.printf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%d\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         string -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%d\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%x\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%x\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type string -> string\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX x             -> x\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type string -> string\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX           -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX           -> \"\"::e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\" :: e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \n\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \nPrintf.sprintf\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"(%s + %s)/2\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s<%s?%s:%s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(pi*%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(pi*%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s<%s?%s:%s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"(sin(pi*%s))\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"(cos(pi*%s))\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"sin(pi*%s)\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"cos(pi*%s)\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"(%s*%s)\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"sin(pi*%s)\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"cos(pi*%s)\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"((%s + %s)/2)\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s*%s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"(%s<%s?%s:%s)\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nSine(eval e0)\n| Cosine e1 ->\nCosine(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*(eval e0))\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi*.(eval e0))\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. e0)\n| Cosine e1 ->\ncos(pi *. e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+(eval (e3,x,y)))/2\n| Times (e4,e5) ->\n(eval (e4,x,y))*(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/2\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| _ -> \"ya dun f*cked up\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> \nif (rand mod 2) = 0 then buildX()\nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then buildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then buildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then buildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 3 then buildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then buildThresh(build(rand, depth -1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then buildAverage (build (rand, (depth - 1)))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then\n            buildTimes\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if (rand mod 5) = 4\n            then\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) =\nfailwith \"ugh\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCos(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else if (rand > 0) & (rand < 20) then buildCos (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCosine(build(rand, depth - 1))", "type": "scope", "out": "Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()\nelse \nbuildY()\nelse if rand > 0 & rand < 20 then\nbuildCosine(build(rand, depth - 1))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) =\nif depth = 0 then\nif (rand mod 2) = 0 then\nbuildX()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand % 2) = 0 then buildX () else buildY ()\n  | 1 ->\n      if (rand % 2) = 0\n      then buildSin (build (rand, (depth - 1)))\n      else buildCos (build (rand, (depth - 1)));;\n", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then buildX()\nelse match rand with \n| 0 -> buildSine(build(makeRand(0,6), depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((makeRand (0, 6)), (depth - 1))));;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then buildX()\nelse match rand with \n| 0 -> buildSine(build(rand(0,6), depth - 1))\n| 1 -> buildCosine(build(rand(0,6), depth - 1))", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((rand (0, 5)), (depth - 1)))\n     | 1 -> buildCosine (build ((rand (0, 5)), (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4)))));;\n", "in": "let rand = \n\nlet rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand depth - 2), build(rand,depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,4) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,6) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 2), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 2))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildX())\n| 6 -> \nbuildCosine(buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,7) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), build(rand, depth - 4))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), buildY())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), build(rand, depth - 2), buildX())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 2), buildSine(build(rand, depth-1)), buildCosine(build(rand,depth - 1)))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildSine(build(rand, depth-1)), buildCosine(build(rand,depth - 1)))\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(build(rand, depth - 1)))\n| 6 -> \nbuildCosine(buildSine(build(rand, depth - 1)))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildX())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,8) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| POS      of expr * expr * expr * expr\n| SOP      of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))\n| SOP (f, g, h) ->\n(eval(f,x,y) + (eval(g,x,y) *. eval(h,x,y)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) + ((eval (g, x, y)) *. (eval (h, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(pi *. eval(e0,x,y))\n| Cosine e1 ->\ncos(pi *. eval(e1,x,y))\n| Average (e2,e3)->\n((eval (e2,x,y))+.(eval (e3,x,y)))/.2.0\n| Times (e4,e5) ->\n(eval (e4,x,y))*.(eval (e5,x,y))\n| Thresh (e6, e7, e8, e9) ->\nif (eval (e6,x,y))<(eval (e7,x,y)) then (eval (e8,x,y))\nelse (eval (e9,x,y))\n| POS (a, b, c, d) ->\n(eval(a,x,y) +. eval(b,x,y)) *. (eval(c,x,y) +. eval(d,x,y))\n| SOP (f, g, h) ->\n(eval(f,x,y) +. (eval(g,x,y) *. eval(h,x,y)))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec helper li = \nmatch li with\n| [] -> d\n| (ki, vi)::t -> \nif ki = k then vi\nelse helper t\nin helper l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildCosine(buildX()))\n| 6 -> \nbuildCosine(buildSine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildSine(buildX()))\n| 6 -> \nbuildCosine(buildCosine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand(0,10) with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 1), buildY())\n| 3 ->\nbuildTimes(build(rand, depth - 1), buildY())\n| 4 ->\nbuildThresh(build(rand, depth - 2), build(rand, depth - 2), buildX(), buildY())\n| 5 -> \nbuildSine(buildSine(buildX()))\n| 6 -> \nbuildCosine(buildCosine(buildX()))\n| 7 -> \nbuildPOS(build(rand, depth - 2), buildX(), build(rand, depth - 2), buildY())\n| 8 ->\nbuildSOP(build(rand, depth - 1), buildX(), buildY())\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
