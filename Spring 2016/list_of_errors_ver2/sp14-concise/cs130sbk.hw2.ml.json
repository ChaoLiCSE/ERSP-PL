{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> if k' = k then v' else acc tl\n| [] -> d\n| _ -> failwith \"to be written\"\nin\nacc l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h :: seen \nelse seen  \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let xx = f x in (x, (f x) = x),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (let xx = f x in ((x, ((f x) = x)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (let xx = f xx in ((xx, ((f xx) = xx)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = in (xx, (f xx) = xx),b)", "type": "scope", "out": "Error: Unbound value xx\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, f xx = xx)),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "*   fixpoint (g,0) should return 739085", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0) should return 739085;;\n", "in": "fixpoint (g,0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd) -> 'a -> 'b -> 'c -> 'd\n       Type int is not compatible with type 'a -> 'b -> 'c -> 'd \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let lam = (xx, (f xx) = xx)),b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = ((wwhile (fun xx  -> (xx, ((f xx) = xx)))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0.5)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g, 700000)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, not ((f xx) = xx))),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g, 700000)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, not ((f xx) = xx))),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, (not ((f xx) = xx)))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\n| b' -> b'\nin\nacc b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' | b' -> b' in\n  acc b;;\n", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 100);;\n", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) != xx))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739085);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739080);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = pi /. (sqrt 2.0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "type": "scope", "out": "Error: Unbound value pi\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = removeDuplicates [\"moo\"; \"cow\"; \"moo\"; \"bar\"];;\n", "in": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "type": "scope", "out": "Error: Unbound value removeDuplicates\n"}, {"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf x\n| VarY y -> sprintf y in\nacc e\n\nexprToString VarX", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf x\n| VarY y -> sprintf y in\nacc e\n\nexprToString VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e\n\nexprToString VarX", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> printf \"x\" \n| VarY -> printf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> printf \"x\" | VarY  -> printf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "scope", "out": "Error: Unbound value printf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> Printf.sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"\n\nexprToString VarX", "type": "type", "out": "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\" exprToString VarX;;\n", "in": "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"", "type": "type", "out": "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.srprintf \"Sine(%s)\" exprToString x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.srprintf \"Sine(%s)\" exprToString x;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.sprintf \"Sine(%s)\" exprToString x", "type": "scope", "out": "Error: Unbound value Printf.srprintf\nHint: Did you mean sprintf?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine\\(%s\\)\" exprToString x", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine\\\\(%s\\\\)\" exprToString x;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString Sine(VarX)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "in": "exprToString Sine(VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "in": "exprToString Sine(VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "in": "| failwith \"Why don't you just make me write a lisp compiler\"\n\n\nexprToString Sine(VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n\nexprToString Sine(VarX)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x ->\n      Printf.sprintf \"Sine(%s)\" (exprToString x) exprToString Sine VarX;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string,\n          'a -> 'b -> 'c -> 'd)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString Sine(VarX)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "in": "exprToString Sine(VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString Sine(VarX)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet _ = exprToString Sine VarX;;\n", "in": "exprToString Sine(VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| \n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine(x) -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average(x, y) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times ()\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times ()|_ -> failwith \"are we writing a lisp compiler now\";;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\nexprToString e1\nexprToString e2\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "type", "out": "Error: The constructor Times expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) -> Printf.sprintf \"%s*%s\" exprToString e1 exprToString e2\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "type", "out": "Error: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*eval(e', x, y))\n| Cosine(e') -> cos(pi*eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc d k tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc d k tl\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a * 'b * ('b * ('c -> 'd -> 'e)) list\n       The type variable 'a occurs inside\n       'a * 'b * ('b * ('c -> 'd -> 'e)) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet rec wwhile (f,b) =\n  let res = f result in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n", "in": "let rec wwhile (f,b) =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'", "type": "scope", "out": "Error: Unbound value result\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> (abs (eval e)) ^. 0.5\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(|%s|)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "scope", "out": "Error: Unbound value ^.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(|%s|)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> abs (eval e) ^. 0.5 \n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> (abs (eval e)) ^. 0.5\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval e))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "scope", "out": "Error: Unbound value ^.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval e))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (absF (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (absF (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "scope", "out": "Error: Unbound value absF\nHint: Did you mean abs?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> 0\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr\n| Quad     of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Quad (e1, e2, e3) -> Printf.sprintf \"(%s + %s)^2 + %s\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "scope", "out": "Error: Unbound value pow\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildSqrt(e)                   = Sqrt(Abs(e))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \nMath.pow ((eval (e1, x, y) + \neval (e2, x, y)), 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "scope", "out": "Error: Unbound value pow\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (Math.pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) +\n        (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \nmath.pow ((eval (e1, x, y) + \neval (e2, x, y)), 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "scope", "out": "Error: Unbound module Math\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (math.pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) +\n        (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) ** 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "scope", "out": "Error: Unbound value math\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) ** 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) **. 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) **. 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) + \neval (e2, x, y)) ** 2)\n+ eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "scope", "out": "Error: Unbound value **.\nHint: Did you mean *. or **?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) +. \neval (e2, x, y)) ** 2)\n+. eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n((eval (e1, x, y) +. \neval (e2, x, y)) ** 2\n+. eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \n(eval (e1, x, y) +. \neval (e2, x, y)) ** 2.0\n+. eval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \neval (e1, x, y) ** 2.0 +.  \neval (e1, x, y) * eval (e2, x, y) +. \neval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e1, x, y)) * (eval (e2, x, y))))\n        +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Quad (e1, e2, e3) -> \neval (e1, x, y) ** 2.0 +.  \neval (e1, x, y) *. eval (e2, x, y) +. \neval (e3, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Quad (e1, e2, e3) -> Printf.sprintf \"(%s^2 + %s*%s + %s\"\n(exprToString e1)\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr\n| Gauss    of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv\n\neval_fn Gauss (1, 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in\n  assert (((-1.0) <= rv) && (rv <= 1.0)); rv eval_fn Gauss (1, 1);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "type", "out": "Error: This expression has type float\n       This is not a function; it cannot be applied.\n"}, {"min": "", "in": "eval_fn Gauss (1.0, 1.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet _ = eval_fn Gauss (1.0, 1.0);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: The constructor Gauss expects 3 argument(s),\n       but is applied here to 0 argument(s)\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: The constructor Gauss expects 3 argument(s),\n       but is applied here to 0 argument(s)\n"}, {"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Gauss (e1, e2, e3) -> Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage  next next\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage next next\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "type": "type", "out": "Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "type": "type", "out": "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "type", "out": "Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\n\ndoRandomGray (7, 150, 200)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next) doRandomGray (7, 150, 200));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "scope", "out": "Error: This function has type expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> match rand (1, 2) with\n| 1 -> buildX\n| 2 -> buildY\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> match rand (1, 2) with\n| 1 -> buildX\n| 2 -> buildY", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}, {"min": "", "in": "| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": ")\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> VarX\n| 2 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "type": "type", "out": "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith Printf.sprintf \n\"Expression %s\" _", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf \"Expression %s\" e;;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith Printf.sprintf  e", "type": "type", "out": "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf e;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "type", "out": "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = abs_float x;;\n", "in": "let buildSqrt(e)                   = Sqrt(e)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildAbs(e)\t\t\t   = Abs(e)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildAbs(e)\t\t\t   = Abs(e)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildGauss(e1,e2,e3)           = Gauss(e1,e2,e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n1 -> VarX\n| 2 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n|1 -> VarX\n| 2 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n| 1 -> VarX\n| 0 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n| 0 -> VarX\n| 1 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n0 -> VarX\n| 1 -> VarY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (0, 1) with\n0 -> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 1) with\n0 -> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 2) with\n0 -> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n|  -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n|1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n|1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> abs next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> abs next);;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> buildAbs next)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp -(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) \n-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((2.0 *. exp) -\n         ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n            (eval (e3, x, y))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (-(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)) )\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float -> float\n       but an expression was expected of type float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (-(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y)))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n-(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (((- ((eval (e1, x, y)) -. (eval (e2, x, y)))) ** 2.0) /.\n              (eval (e3, x, y))));;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp ~-.(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp ~-.(\n(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Gauss (e1, e2, e3) -> Printf.sprintf \"2*(e^(-((%s-%s)/%s)^2) - 1\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0)\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) * sqrt (2 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) * (sqrt (2 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp (~-.(\n((eval (e1, x, y) -. eval (e2, x, y)) \n/. eval (e3, x,y)) ** 2.0)) \n/. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp (~-.(\n((eval (e1, x, y) -. eval (e2, x, y)) \n/. eval (e3, x,y)) ** 2.0)) \n/. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Abs      of expr\n| Logistic   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\"\n(exprToString e1)\n(exprToString e2)\n(exprToString Abs(e3))\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\" (exprToString e1)\n        (exprToString e2) (exprToString Abs e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\"\n(exprToString e1)\n(exprToString e2)\n(exprToString (Abs(e3)))\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1 - exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ^ eval (e3, x, y))\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1 - (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ^ eval (e3, x, y))\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ^ eval (e3, x, y))\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^%s\"\n(exprToString e1)\n(exprToString e2)\n(exprToString (Abs(e3)))\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) *8 eval (e3, x, y))\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        * (8 eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))\n-. 1.0))\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(1.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))))\n| _ -> failwith \"error\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(1/(1 - e^(-%s*%s*%s)))\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\n\n\n\nlet g1 () = failwith \"to be implemented\"  \nlet g2 () = failwith \"to be implemented\"  \nlet g3 () = failwith \"to be implemented\"  \n\nlet c1 () = failwith \"to be implemented\"\nlet c2 () = failwith \"to be implemented\" \nlet c3 () = failwith \"to be implemented\" \n\n\n(******************** Random Number Generators ************)\n\n(* makeRand int * int -> (int * int -> int)\nReturns a function that, given a low and a high, returns\na random int between the limits.  seed1 and seed2 are the\nrandom number seeds.  Pass the result of this function\nto build \n\nExample:\nlet rand = makeRand(10,39) in \nlet x =  rand(1,4) in \n(* x is 1,2,3, or 4 *)\n*)\n\nlet makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n\n(********************* Bitmap creation code ***************)\n\n(* \nYou should not have to modify the remaining functions.\nAdd testing code to the bottom of the file.\n*)\n\n(* Converts an integer i from the range [-N,N] into a float in [-1,1] *)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(* Converts real in [-1,1] to an integer in the range [0,255]  *)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(* ffor: int * int * (int -> unit) -> unit\nApplies the function f to all the integers between low and high\ninclusive; the results get thrown away.\n*)\n\nlet rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)\n\n(* emitGrayscale :  ((real * real) -> real) * int -> unit\nemitGrayscale(f, N) emits the values of the expression\nf (converted to intensity) to the file art.pgm for an \n2N+1 by 2N+1 grid of points taken from [-1,1] x [-1,1].\n\nSee \"man pgm\" on turing for a full description of the file format,\nbut it's essentially a one-line header followed by\none byte (representing gray value 0..255) per pixel.\n*)\n\nlet emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(* doRandomGray : int * int * int -> unit\nGiven a depth and two seeds for the random number generator,\ncreate a single random expression and convert it to a\ngrayscale picture with the name \"art.pgm\" *)\n\nlet doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| Sqrt (e) -> Printf.sprintf \"(%s)^0.5\"\n(exprToString (Abs(e)))\n| Abs (e) -> Printf.sprintf \"|%s|\" \n(exprToString e)\n| Logistic (e1, e2, e3) -> Printf.sprintf \"(1/(1+e^(-%s*%s*%s)))\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n| _ -> failwith \"are we writing a lisp compiler now\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\n\nlet g1 () = (8, 7, 180)\nlet g2 () = (8, 52, 13)\nlet g3 () = (8, 13, 10)\n\nlet c1 () = (8, 2, 17)\nlet c2 () = (8, 5, 43)\nlet c3 () = (8, 83, 4)\n\n\n(******************** Random Number Generators ************)\n\n(* makeRand int * int -> (int * int -> int)\nReturns a function that, given a low and a high, returns\na random int between the limits.  seed1 and seed2 are the\nrandom number seeds.  Pass the result of this function\nto build \n\nExample:\nlet rand = makeRand(10,39) in \nlet x =  rand(1,4) in \n(* x is 1,2,3, or 4 *)\n*)\n\nlet makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n\n(********************* Bitmap creation code ***************)\n\n(* \nYou should not have to modify the remaining functions.\nAdd testing code to the bottom of the file.\n*)\n\n(* Converts an integer i from the range [-N,N] into a float in [-1,1] *)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(* Converts real in [-1,1] to an integer in the range [0,255]  *)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(* ffor: int * int * (int -> unit) -> unit\nApplies the function f to all the integers between low and high\ninclusive; the results get thrown away.\n*)\n\nlet rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)\n\n(* emitGrayscale :  ((real * real) -> real) * int -> unit\nemitGrayscale(f, N) emits the values of the expression\nf (converted to intensity) to the file art.pgm for an \n2N+1 by 2N+1 grid of points taken from [-1,1] x [-1,1].\n\nSee \"man pgm\" on turing for a full description of the file format,\nbut it's essentially a one-line header followed by\none byte (representing gray value 0..255) per pixel.\n*)\n\nlet emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(* doRandomGray : int * int * int -> unit\nGiven a depth and two seeds for the random number generator,\ncreate a single random expression and convert it to a\ngrayscale picture with the name \"art.pgm\" *)\n\nlet doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)\n\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "type": "", "out": ""}], "event": "eval"}
