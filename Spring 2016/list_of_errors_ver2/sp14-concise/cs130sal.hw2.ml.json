{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match d k l with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | hd::tl ->\n             (match hd with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "in": "let rec assoc (d,k,l) = match d k l with\n(d, k, l) -> if l = [] \nthen d\nelse match l with \nhd::tl -> match hd with\n(a, b) -> if a = k\nthen b\nelse assoc (d, k, t)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'c -> 'a * 'd * ('d * 'a) list\n       The type variable 'a occurs inside\n       'b -> 'c -> 'a * 'd * ('d * 'a) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"hue\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((ex s) ^ (\"+\" ^ ((ex t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (ex t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((ex s) ^\n           (\"<\" ^ ((ex t) ^ (\"?\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))));;\n", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(ex s)^\"+\"^(ex t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(ex t))\n| Thresh(s, t, u, v) -> (\"(\"^(ex s)^\"<\"^(ex t)^\"?\"^(ex u)^\":\"^(ex v)^\")\")", "type": "scope", "out": "Error: Unbound value ex\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((expr s) ^ (\"+\" ^ ((expr t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (expr t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((expr s) ^\n           (\"<\" ^ ((expr t) ^ (\"?\" ^ ((expr u) ^ (\":\" ^ ((expr v) ^ \")\")))))));;\n", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "type": "scope", "out": "Error: Unbound value ex\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi(\"^(expr t)^\"))\")\n| Cosine(t)\t  -> (\"cos(pi(\"^(expr t)^\"))\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(a)\t  -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine(a)\t  -> (\"cos(pi*\"^(expr a)^\")\")\n| Average(a, b) -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times(a, b) -> ((expr a)^\"*\"^(expr b))\n| Thresh(a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average(a, b)       -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times(a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh(a, b, c, d)  -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | (Average a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | (Times a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | (Thresh a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average a, b        -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times a, b\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh a, b, c, d   -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "type": "type", "out": "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average (a, b)      -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times (a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh (a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times(a, b)        -> ((eval (a, x, y)) *. (eval (b, x, y)))\n| Thresh(a, b, c, d) -> \nif (eval (a, x, y) < (eval (b, x, y))) \nthen (eval (c, x, y)) \nelse (eval (d, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times(a, b)        -> ((eval (a, x, y)) *. (eval (b, x, y)))\n| Thresh(a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y)\nthen (eval (c, x, y)) \nelse (eval (d, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times(a, b)        -> ((eval (a, x, y)) *. (eval (b, x, y)))\n| Thresh(a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y)\nthen eval (c, x, y)\nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times(a, b)        -> (eval (a, x, y)) *. (eval (b, x, y))\n| Thresh(a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y)\nthen eval (c, x, y)\nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = (f, b') in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = \nlet check = (f, b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = f b' in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = f b' in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (b',y) -> if y = false then b' else wwhile (f, b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "type", "out": "Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "type": "type", "out": "Error: This expression has type bool -> 'a\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "in": "let rec exprToString e = \n(*let expr = exprToString in*)\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"", "type": "scope", "out": "Error: Unbound value expr\nHint: Did you mean exp?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": " sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen@[h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) = false\nthen seen@[h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen@[h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen@[h]\nelse seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen [h]@seen\nelse seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen [h]@seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match dkl with | (d,k,l) -> if l = [] then d else matchl;;\n", "in": "let rec assoc (d,k,l) = \nmatch dkl with (d, k, l) ->\nif l = [] then d else\nmatchl", "type": "scope", "out": "Error: Unbound value dkl\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) = if l = [] then d else matchl;;\n", "in": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatchl", "type": "scope", "out": "Error: Unbound value matchl\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | [] -> 0\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| [] -> 0\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c * 'd\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) > eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times (a, b) -> (eval (a, x, y)) *. (eval (b, x, y))\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "type", "out": "Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', i) -> \nif i = false\nthen x'\nelse wwhile (f, x')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen cons [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen cons [h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen h :: seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', i) -> \nif i = false\nthen x'\nelse wwhile (f, x')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g1 () = build (2, 2);;\n", "in": "let g1 () = build (2, 2)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g2 () = build (2, 5);;\n", "in": "let g2 () = build (2, 5)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g1 () = build ((rand (0, 5)), 2);;\n", "in": "let g1 () = build (rand(0, 5), 2)", "type": "scope", "out": "Error: Unbound value rand\nHint: Did you mean land?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen \nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\nelse \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g1 () = build (makeRand(0, 5), 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g2 () = build (makeRand(0, 5), 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g1 () = build (makeRand(0, 5), 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g1 () = build (makeRand(0, 5), 2) in\nlet g2 () = build (makeRand(0, 5), 2) in\nlet g3 () = build (makeRand(0, 5), 2) in\n(g1, g2, g3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g1 () = build (makeRand(0, 5), 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g2 () = build (3, 4, 5);;\n", "in": "let g2 () = build (3,4,5)", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type (int * int -> int) * int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g3 () = build (6, 7, 8);;\n", "in": "let g3 () = build (6,7,8)", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type (int * int -> int) * int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Not supposed to be here\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*eval (a, x, y))\n| Cosine a -> cos (pi*eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 1)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 1)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 1)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 5) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Poly     of expr * expr * expr\n| Tan      of expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"+\"^(expr b)^\"*\"^(expr c)^\")\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")/cos(pi*\"^(expr a)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (eval ((a, x, y) *. (a, x, y))) + ((b, x, y) *. (c, x, y));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) * (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPoly (e1,e2,e3) = Poly (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 7) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildPoly ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildTan ((build (rand, d)), (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"+\"^(expr b)^\"*\"^(expr c)^\")/2\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")/cos(pi*\"^(expr a)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"+\"^(expr b)^\"*\"^(expr c)^\")/2\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")/cos(pi*\"^(expr a)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y)))/2\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y)))/.2\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) *. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> sin (pi *. eval(a, x, y)) *. cos (pi *. eval(a, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"*\"^(expr b)^\"*\"^(expr c)^\")\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")*cos(pi*\"^(expr a)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"*\"^(expr b)^\"*\"^(expr c)^\")/2\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")*cos(pi*\"^(expr a)^\")/2\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) *. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> (sin (pi *. eval(a, x, y)) *. cos (pi *. eval(a, x, y))) /. 2.0", "type": "", "out": ""}], "event": "eval"}
