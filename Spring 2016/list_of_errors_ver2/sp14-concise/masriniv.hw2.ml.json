{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \n(if List.mem h seen\nthen seen\nelse h :: seen)\nin\nlet rest' = t\nin helper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nmatch f(b) with\n| (_, false) -> b\n| (bb, true) -> wwhile(f, bb)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nmatch f(b-1) with\n| (_, false) -> b\n| (bb, true) -> wwhile(f, bb)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nmatch f(b-1) with\n| (bb, false) -> bb\n| (bb, true) -> wwhile(f, bb)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nmatch f(b) with\n| (bb, false) -> bb\n| (bb, true) -> wwhile(f, bb)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "et f x = let xx = x+x+x in (xx, xx < 100) in\nwwhile (f, 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  wwhile (fun ff  -> fun b  -> (((f b), ((f b) = (f (b - 1)))), b));;\n", "in": "let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  wwhile (fun ff  -> fun b  -> (((f b), ((f b) != (f (b - 1)))), b));;\n", "in": "let ff (b) =\n(f(b), f(b) != f(b-1)\nin\nlet fixpoint (f, b) = wwhile (ff ,b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunc;;\n", "in": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value trunc\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || (b != (f (b - 1))))) in wwhile (ff, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f, b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || (b != (f (b - 1))))) in wwhile (ff, b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f, b) = wwhile((fun b -> (f b, f b != b || b != f b-1)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f (b-1))), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || ((f b) != (f (f b)))))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = trunca;;\n", "in": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value trunca\nHint: Did you mean truncate?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) = f(f(b))))) , b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ (exprToStringx ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ (exprToStringx ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX _ -> \"x\"\n| VarY _ -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"", "type": "scope", "out": "Error: Unbound value exprToStringx\nHint: Did you mean exprToString?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           ((\"<\" exprToString y) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"", "type": "scope", "out": "Error: Unbound value sampleExpr1\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = ring sampleExpr1;;\n", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "scope", "out": "Error: Unbound value ring\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth)=\nmatch depth with\n| 0 -> \n(match rand(1,2) with\n| 1 -> VarX\n| 2 -> VarY\n)\n| _ ->\n(match rand(1,5) with\n| 1 -> Sine(build(rand, depth-1))\n| 2 -> Cosine(build(rand, depth-1))\n| 3 -> Average(build(rand, depth-1),build(rand, depth-1))\n| 4 -> Times(build(rand, depth-1),build(rand, depth-1))\n| 5 -> Thresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth)=\nmatch depth with\n| 0 -> \n(match rand(1,2) with\n| 1 -> VarX\n| 2 -> VarY\n| _ -> VarX\n)\n| _ ->\n(match rand(1,5) with\n| 1 -> Sine(build(rand, depth-1))\n| 2 -> Cosine(build(rand, depth-1))\n| 3 -> Average(build(rand, depth-1),build(rand, depth-1))\n| 4 -> Times(build(rand, depth-1),build(rand, depth-1))\n| 5 -> Thresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| _ -> VarX\n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "build(makeRand(312,385), 15)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth)=\nmatch depth with\n| 0 -> \n(match rand(1,3) with\n| 1 -> VarX\n| 2 -> VarY\n| _ -> VarX\n)\n| _ ->\n(match rand(1,6) with\n| 1 -> Sine(build(rand, depth-1))\n| 2 -> Cosine(build(rand, depth-1))\n| 3 -> Average(build(rand, depth-1),build(rand, depth-1))\n| 4 -> Times(build(rand, depth-1),build(rand, depth-1))\n| 5 -> Thresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| _ -> VarX\n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| SinCos   of expr\n| LimSin   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
