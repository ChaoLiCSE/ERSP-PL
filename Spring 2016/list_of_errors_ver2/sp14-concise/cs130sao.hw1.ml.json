{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = function | [] -> int;;\n", "in": "let rec sumList xs = function [] -> int", "type": "scope", "out": "Error: Unbound value int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + t;;\n", "in": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n", "in": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t in xs", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nList.fold_left (+) xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nList.fold_left (+) xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nList.fold_left (+)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nList.fold_left (+)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::xs -> (List.fold_left x) + xs;;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| x :: xs -> List.fold_left x + xs", "type": "type", "out": "Error: This expression has type 'a -> 'b list -> 'a\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sum t);;\n", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + sum t", "type": "scope", "out": "Error: Unbound value sum\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> int | h::t -> 1;;\n", "in": "let rec sumList xs = match xs with\n[] -> int\n| h::t -> 1", "type": "scope", "out": "Error: Unbound value int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = match n with\nn -> n::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 ::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 :: digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n / 10 with | 0 -> [0] | _ -> digitsOfIn n []);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfIn n []", "type": "scope", "out": "Error: Unbound value digitsOfIn\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n []", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> ::[] digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10) ::[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitOfInt (n/10) :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) :: []", "type": "scope", "out": "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop (n/10) (n mod 10::lis) = match n with\n0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: ((n mod 10) []);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse let rec loop (n/10) (n mod 10::x) in match n with \n0 -> [0]\n| _ -> loop n []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10:: x) in match n with\n0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then [0]\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11] ((1 mod 10) :: 4);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> addPersist n (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> m | _ -> r_digitalRoot n 0);;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digital root m 0\n| _ -> r_digitalRoot n 0", "type": "scope", "out": "Error: Unbound value m\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digital root m 0 | _ -> r_digitalRoot n 0);;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m 0\n| _ -> r_digitalRoot n 0", "type": "scope", "out": "Error: Unbound value r_digital\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot m 0 | _ -> r_digitalRoot n 0);;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m", "type": "scope", "out": "Error: Unbound value m\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n m);;\n", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "scope", "out": "Error: Unbound value m\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse if n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse if n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot \n| _ -> r_digitalRoot n (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot | _ -> r_digitalRoot n (n mod 10));;\n", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m \n| _ -> r_digitalRoot n 0", "type": "type", "out": "Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 6", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n 6", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n -1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> (r_digitalRoot n) - 1);;\n", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n (-1)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n < 0 && m != 0 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n < 0) && (m != 0) then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n < 9) && (m != 0) then n\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 && m != 0 then n + m\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n+m) <= 9 then n + m\nelse if (n+m) > 9 then r_digitalRoot (n+m) 0\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n/10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n + m <= 9 then n + m\nelse if n = 0 && m > 9 then r_digitalRoot m 0\nelse r_digitalRoot (n / 10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 x\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif  n <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif  n <= 9 then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 && x = (-1) then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 && x = (-1) then 0\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) (1 + x)\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 (-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\nif l = [] then []\nelse let rec r_listReverse l x = match l with\n[] -> []\n| h::t -> r_listReverse t []::h", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| h::t -> [] @ h @ digitsOfInt t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | h::t -> [] @ (h @ (digitsOfInt t)));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0, then [0]\nelse _ -> digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse _ -> digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse in n > 0 then digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 0 then digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [n]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) :: (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 @ [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[] \nin match n with \n0 -> [0]\n| _ -> digitsOfInt n @ []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) :: (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet orig_Esplode = esplode w", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w = orig_Esplode = (esplode w);;\n", "in": "let palindrome w = \nif w = [] then true\nelse\nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w in \nlet rec r_palindrome orig_Esplode revserse_Esplode = \nlet h1 = h::orig_Esplode \nand h2 = h::reverse_Esplode\nif h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode\nelse false", "type": "scope", "out": "Error: Unbound value orig_Esplode\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w = if w = [] then true;;\n", "in": "let palindrome w = match w with\n[] -> true\n| _ -> false", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n with\n| [] -> []\n| 0 -> [0]\n| _ -> = digitsOfInt (n / 10) @ (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | 0 -> [0]\n  | _ -> (digitsOfInt (n / 10)) @ (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "type": "type", "out": "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList digitsOfInt n) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList n));;\n", "in": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (n / 10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10 ::[])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nmatch w with\n| []    -> true\n| h1::t1 -> \nmatch listReverse t1 with\n| h2::t2 -> if h1 = h2 then palindrome t2 \nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome w = \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then reverseList t2\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet ex = esplode w \nand let rev_ex = reverseList ex in\nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (esplode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (explode w))", "type": "scope", "out": "Error: Unbound value esplode\nHint: Did you mean explode?\nError: Unbound value esplode\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value esplode\nHint: Did you mean explode?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (explode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (explode w) (reverseList (explode w))", "type": "scope", "out": "Error: Unbound value esplode\nHint: Did you mean explode?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (reverseList (explode w))", "type": "scope", "out": "Error: Unbound value reverseList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (listReverse (explode w))", "type": "scope", "out": "Error: Unbound value reverseList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[])          -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (_,_)    -> false \nin\nr_palindrome (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| []   -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10) (n mod 10 ::[]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10) ) (n mod 10 ::[])", "type": "type", "out": "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ((n mod 10) ::[])", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ([n mod 10])", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) ((n mod 10 ::[]))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> append (listReverse t) [h]", "type": "type", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
