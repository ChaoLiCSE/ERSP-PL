{"ocaml": [{"min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> k\n  | x::xs -> let x = (s, i) in if k = s then i else assoc (d, k, xs);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| x::xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)", "type": "scope", "out": "Error: Unbound value s\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (first,second)::xs -> if k = first then second else assoc (d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n", "in": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f b' else b'", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n", "in": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f (b') else b'", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n", "in": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then (f b') else b'", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet _ = (fixpoint (f, b)) = (wwhile ((f b), b));;\n", "in": " fixpoint (f,b) = wwhile ((f b),b)", "type": "scope", "out": "Error: Unbound value f\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = f x in f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = wwhile (f, x) in f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let f x = wwhile(f,x) in f b),b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let f x = f b in f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let f x = f x in f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> (x,x=b)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> (x,x!=b)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, (x != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=b)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), ((f x) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let rec exprToString e = match e with\n| VarX x -> \"x\"\n| VarY y -> \"y\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> \"x\" | VarY y -> \"y\";;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average x y -> \"((%s+%s)/2)\" x y\n| Times x y -> \"%s*%s\" x y\n| Thresh x y z a -> \"%s<%s?%s:%s\" x y z a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*%s)\" x\n  | Cosine x -> \"cos(pi*%s)\" x\n  | Average (x,y) -> \"((%s+%s)/2)\" x y\n  | Times (x,y) -> \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> \"%s<%s?%s:%s\" x y z a;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> sprintf \"sin(pi*%s)\" x\n| Cosine x -> sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> sprintf \"%s<%s?%s:%s\" x y z a", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> sprintf \"sin(pi*%s)\" x\n  | Cosine x -> sprintf \"cos(pi*%s)\" x\n  | Average (x,y) -> sprintf \"((%s+%s)/2)\" x y\n  | Times (x,y) -> sprintf \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> sprintf \"%s<%s?%s:%s\" x y z a;;\n", "in": "let rec exprToString e = match e with\n| VarX -> Printf.sprintf \"x\"\n| VarY -> Printf.sprintf \"y\"\n| Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n| Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a", "type": "scope", "out": "Error: Unbound value sprintf\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n  | Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ expToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,a) ->\n      (exprToString x) ^\n        (\"<\" ^\n           ((expToString y) ^\n              (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString a))))));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ exprToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a", "type": "scope", "out": "Error: Unbound value expToString\nHint: Did you mean exprToString?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "et sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": " _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (first,second)::xs -> if k = first then second else assoc (d,k,xs)", "type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1 or sampleExpr2?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1 or sampleExpr2?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Tan      of expr\n| Log      of expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Exp      of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let x = rand(0,2) in\nif x=0 then buildX() else buildY()\n| _ -> let y = rand(0,7) in \nmatch y with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n(* | 4 -> buildSqrt(build(rand,depth-1)) *)\n| 5 -> buildExp(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let x = rand(0,2) in\nif x=0 then buildX() else buildY()\n| _ -> let y = rand(0,7) in \nmatch y with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n(* | 4 -> buildSqrt(build(rand,depth-1)) *)\n(* | 5 -> buildExp(build(rand,depth-1),build(rand,depth-1)) *)\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let x = rand(0,2) in\nif x=0 then buildX() else buildY()\n| _ -> let y = rand(0,7) in \nmatch y with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildSqrt(build(rand,depth-1)) \n(* | 5 -> buildExp(build(rand,depth-1),build(rand,depth-1)) *)\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Sqrt     of expr\n| Times3   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
