{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsofInt n) / (10 s));;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s", "type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / (10 s));;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10 :: digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []", "type": "scope", "out": "Error: Unbound value digitsHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n", "in": "let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []", "type": "scope", "out": "Error: Unbound value digitsHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in\n  if n <= 0 then [] else digitsHelper n [];;\n", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l\nin\nif n<=0 then [] else digitsHelper n []", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let rec digHelper n = if n < 10 then n else digHelper (sumList n) in\n  digHelper n;;\n", "in": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList n)\nin\ndigHelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))\nin\ndigHelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> (listHelper t h) :: l2 in\n  listHelper l [];;\n", "in": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t h::l2\nin\nlistHelper l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "in": "let palindrome w = if listReverse explode w = explode w then true else false", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = if (listReverse (explode w)) = explode w then true else false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = function | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = function\n| [] -> 0\n| h::t -> h + sumList t", "type": "type", "out": "Error: This expression has type int list -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
