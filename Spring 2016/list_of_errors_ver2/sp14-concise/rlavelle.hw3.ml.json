{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n < 0 then [] else\nmatch n with\n|0 -> []\n|_ -> clone x (n-1) @  [x]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet num1 = List.length l1 in\nlet num2 = List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (list.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n", "in": "let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - list.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = \nmatch l with\n|[] -> []\n|h::t -> if h = 0 then removeZero t else t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = \nmatch l with\n|[] -> []\n|h::t -> if h = 0 then removeZero t else l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = \nmatch l with\n|[] -> []\n|h::t -> if h = 0 then removeZero t else l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ sum mod 10 in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ (sum mod 10) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = (a @ (sum mod 10)) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = (sum mod 10) :: a in 1 :: result\n          else sum :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x = if x < 10 then x else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then x \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [0;x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x =\n        let rec intlist x =\n          if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n        match x with\n        | (z,y) ->\n            (match a with\n             | [] -> let sum = z + y in intlist sum\n             | h::t -> let sum = (h + z) + y in result = ((intlist sum) @ t)) in\n      if sum < 10 then 0 :: result else result in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nresult = (intlist sum) @ t) in\nif sum < 10 then 0::result else result in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value result\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nlet result = (intlist sum) @ t in\nif sum < 10 then 0::result else result) in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let (_,zeroList) = padZero (t, []) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let (_,zeroList) = padZero(t,[]) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10];;\n\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n\nlet _ =\n  let mult = (intlist h) * i in\n  let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> let (_,zeroList') = padZero (t', []) in zeroList' in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> let (_,zeroList') = padZero(t',[]) in zeroList') in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t', []) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t',[]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t', [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t',[0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t', [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t' [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t' [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero (t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit i t)", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd (res (mulByDigit (i t)));;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd (res (mulByDigit (i t)))", "type": "scope", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd (res mulByDigit (i t));;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd (res mulByDigit (i t))", "type": "scope", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res mulByDigit (i t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd res mulByDigit (i t)", "type": "scope", "out": "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t' [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit i t)", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> [0]\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero t [0] with \n|(a,b) -> b)) in\nlet mult = intlist (h*i) in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit i t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), ((bigAdd bigMul x l2) @ (c a))) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with \n|(b,c) -> b @ [0] , bigAdd bigMul x l2 @ c a in \nlet base = ([],0) in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) a)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with \n|(b,c) -> b @ [0] , bigAdd ((mulByDigit x l2) @ b) a in \nlet base = ([],0) in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list * 'a\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with \n|(b,c) -> b @ [0] , bigAdd ((mulByDigit x l2) @ b) c in \nlet base = ([],0) in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list * int\n       but an expression was expected of type int list * int list\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with \n|(b,c) -> b @ [0] , bigAdd ((mulByDigit x l2) @ b) c in \nlet base = ([],[0]) in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with \n|(b,c) -> b @ [0] , bigAdd ((mulByDigit x l2) @ b) c in \nlet base = ([],[0]) in\nlet args = l1 in\nlet (_,res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
