{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen' @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": " removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     helper ([], l));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nhelper ([],l)", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then h :: seen else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value et\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet helper = (f,b) in\nmatch helper with\n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet helper = (f,b) in\nmatch helper with\n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet helper = (f,b) in\nmatch helper with\n| (x',n) ->\nif n = false then x'\nelse wwhile(f,x')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet helper = (f b) in\nmatch helper with\n| (x',n) ->\nif n = false then x'\nelse wwhile(f,x')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet helper = (f b) in\nmatch helper with\n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \n(*let helper = (f b) in\nmatch helper with*)\nmatch (f b) with \n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nmatch (f b) with \n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile(f,b) =\nmatch (f b) with \n| (v,false) -> v\n| (v,true)  -> wwhile(f,v)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun v -> let b = (f v) in (b, b != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun v -> let x = (f v) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX ->            \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\n\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Var x -> x\n  | Var y -> y\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "in": "let rec eval (e,x,y) = match e with \n| Var(x) ->          x\n| Var(y) ->\t     y\n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "type": "scope", "out": "Error: Unbound constructor Var\nHint: Did you mean VarX or VarY?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX ->            x\n| VarY ->\t     y\n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->            x\n| VarY ->\t     y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"X\"\n| VarY ->            \"Y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi * (eval (v, x, y)))\n  | Cosine v -> cos (pi * (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*eval(v,x,y))\n| Cosine(v) ->       cos(pi*eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(w,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then d = (d - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, d))\n  | 1 -> buildCosine (build (rand, d))\n  | 2 -> buildAverage (build (rand, d))\n  | 3 -> buildTimes (build (rand, d))\n  | 4 -> buildThresh (build (rand, d));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))", "type": "scope", "out": "Error: Unbound value d\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then depth = (depth - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, depth))\n  | 1 -> buildCosine (build (rand, depth))\n  | 2 -> buildAverage (build (rand, depth))\n  | 3 -> buildTimes (build (rand, depth))\n  | 4 -> buildThresh (build (rand, depth));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let d = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| _ -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ ((\"+\" exprToString w) ^ \")\"))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Plus(v,w) ->\t     \"(\"^exprToString(v)^\"+\"exprToString(w)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}, {"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Plus(v,w) ->\t     \"(\"^exprToString(v)^\"+\"^exprToString(w)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(w,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| Plus(v,w) ->       (eval(v,x,y) +. eval(w,x,y))\n| Cube(a,b,c) ->     (eval(a,x,y) *. eval(b,x,y) *. eval(c,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f,b) = wwhile ((let func v =\nlet result = f p in\nif p = result then (p,false)\nelse (p,true) in func),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint(f,b) = wwhile ((let func v =\nlet result = f b in\nif b = result then (result,false)\nelse (result,true) in v),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func v =\n        let result = f b in\n        if b = result then (result, false) else (result, true) in\n      v), b);;\n", "in": "let fixpoint(f,b) = wwhile ((let func v =\nlet result = f b in\nif b = result then (result,false)\nelse (result,true) in func),b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}, {"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func v =\n        let result = f b in\n        if b = result then (result, false) else (result, true) in\n      func), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((fun -> let x = (f v) in (x, x != v)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f v) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let a = (f x) in (a, a != x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,6) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\n| 5 -> buildSquare(build(rand,depth),build(rand,depth))\n| _ -> buildCube(build(rand,depth),build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "(let fixpoint (f,b) = wwhile ((fun -> let x = (f v) in (x, x != v)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Fifth    of expr * expr * expr * expr * expr\n| Cube     of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
