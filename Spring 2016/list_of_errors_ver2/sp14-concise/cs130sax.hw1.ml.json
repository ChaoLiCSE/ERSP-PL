{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nfailwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nfailwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | hd::tl -> sum = ((sum + hd) :: (sumLists tl));;\n", "in": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum = sum + hd :: sumLists tl", "type": "scope", "out": "Error: Unbound value sum\n"}, {"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | hd::tl -> sum = ((sum + hd) :: (sumLists tl));;\n", "in": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl", "type": "scope", "out": "Error: Unbound value sum\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "in": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> hd + (sumList tl)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}, {"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList (1 : xs) =\n  (match xs with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "in": "let rec sumList (1:xs): int =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "scope", "out": "Error: Unbound type constructor xs\n"}, {"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList (1 : int xs) =\n  (match xs with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "in": "let rec sumList (1:int xs): int =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "scope", "out": "Error: Unbound type constructor xs\n"}, {"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList (1 : int list) =\n  (match 1 with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "in": "let rec sumList (1 : int list): int =\nmatch 1 with\n[] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "type", "out": "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type int list\n"}, {"min": "", "in": "failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList (l : int list) =\n  (match l with\n   | [] -> 0\n   | hd::tl -> hd + ((sumList tl) failwith \"TBD:sumList\") : int);;\n", "in": "let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)\nfailwith \"TBD:sumList\"", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList (l : int list): int =\nmatch l with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList (hd::tl) = match hd with | [] -> 0 | hd -> hd + (sumList tl);;\n", "in": "let rec sumList (hd::tl) =\nmatch hd with\n| [] -> 0\n| hd -> hd + (sumList tl)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n acc", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n acc;;\n", "in": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "type": "scope", "out": "Error: Unbound value acc\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse\nmatch n with\n| 0 -> [0]\n| _ -> loop (n/10) (n mod 10::tlist)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nsumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nmatch n in\n| if (n % 10 = n) then n\n| else sumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nmatch n with\n| if (n % 10 = n) then n\n| else sumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nmatch n with\n| if (n mod 10 = n) then n\n| else sumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nmatch n with\n| if n < 10 then n\n| else sumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nmatch n with\n| if (n < 10) then n\n| else sumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nif (n < 10) then n\nelse sumList (digits n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nif (n < 10) then n\nelse additivePersistence (sumList (digits n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n =\nif (n < 10) then n\nelse additivePersistence (sumList (digits n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot n =\nif (n < 10) then n\nelse digitalRoot (sumList (digits n))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 789;;\n", "in": "let rec additivePersistence n =\nlet aPHelper n i =\nif (n < 10) then i\nelse additivePersistence (sumList (digits n) (i+1))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList (digits n) (i+1))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList (digits n)) (i+1)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList (digits n)) (i+1)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper sumList(digits n) (i+1) in \nn", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \nn", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \ni", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \n9", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \naPHelpher n 0", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList(digits n)) (i+1) in \naPHelper n 0", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n =\nif (n < 10) then n\nelse digitalRoot (sumList (digits n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse (hd::tl) =\nmatch tl with\n| if tl = [] then tl\n| else listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse (hd::tl) =\nmatch tl with\n| if (tl = []) then tl\n| else listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then hd\nelse listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then [tl::hd]\nelse listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then (tl::hd)\nelse listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then (tl::hd)\nelse listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse ((listReverse tl)::hd)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse (listReverse tl::hd)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\nif (tl = []) then n\nelse (listReverse tl::hd)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\nif (tl = []) then n\nelse (listReverse tl::hd)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\nif (tl = []) then (n)\nelse (listReverse tl::hd)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse n =\n  match n with\n  | [] -> []\n  | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n", "in": "let rec listReverse n =\nmatch n with\n| hd::tl ->\nif (tl = []) then n\nelse ((listReverse tl)::hd)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\n(listReverse tl) @ (hd)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\n(listReverse tl) @ [hd]", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> (listReverse tl) :: [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nlet rec concat x y = (x::y)\nin\nmatch n with\n| [] -> []\n| hd::tl -> concat (listReverse tl) [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> (listReverse tl)::[hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> listReverse tl::[hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nlet rec insert_at_end l i =\nmatch l with\n[] -> [i]\n| h :: t -> h :: (insert_at_end t i) in\nmatch n with\n| [] -> []\n| hd::tl -> insert_at_end (listReverse tl) [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nlet rec insert_at_end l i =\nmatch l with\n[] -> [i]\n| h :: t -> h :: (insert_at_end t i) in\nmatch n with\n| [] -> []\n| hd::tl -> insert_at_end (listReverse tl) hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse n =\nlet rec add_to_end l i =\nmatch l with\n[] -> [i]\n| h :: t -> h :: (add_to_end t i) in\nmatch n with\n| [] -> []\n| hd::tl -> add_to_end (listReverse tl) hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =\nif explode w = listReverse (explode w) then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
