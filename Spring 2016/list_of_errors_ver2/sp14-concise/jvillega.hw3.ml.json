{"ocaml": [{"min": "\nlet sqsum xs = let f a x = (+.) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float -> float -> float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs = let f a x = (+.) in let base = 0. in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         float -> float -> float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs = let f a x = (+.) in let base = 0. in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         float -> float -> float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs = let f a x = (+) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = ( + ) in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = List.map f x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = List.map f x in\nlet base = 0 in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = List.map x in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = List.map x in\nlet base = 3 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.append (List.append a sep) h in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.append (List.append a sep) h in\nlet base = t in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append h sep in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.append h sep in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a @ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a @ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a @ sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a @ sep in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = t in let l = h in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a @ sep in\nlet base = t in\nlet l = h in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = base in let base = base in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = base in\nlet base = base in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x = f x a in let base = f x a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = f x a in\nlet base = f x a in\nList.fold_left f base fs", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet pipe fs = let f a x = x a in let base = f x a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f x a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a' in let base = a' in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a' in\nlet base = a' in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value a'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = f a x in\nlet base = 3 in\nList.fold_left f base fs", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = pipe fs in\nlet base = 3 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe base in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = pipe base  in\nlet base = 3 in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = pipe fs  in\nlet base = 3 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base a = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base a = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a x-> x  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = pipe [] in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x x = a in let base = pipe [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x a = x in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x a-> x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x a-> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x d x = g in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun d x -> g in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value g\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x d x = a in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun d x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x a = d in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x a -> d in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value d\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x a -> fun d -> d in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "in": "let base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "in": "let base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "in": "let base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "in": "let base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "in": "let base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "in": "let base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun b -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a ->  x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a ->  x a in\nlet base = fun d b-> d b in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x ->  a x in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a x -> a x  in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a -> a x  in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a -> x a  in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a x -> x in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a x = a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x d = a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun d -> a in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d ->  x a in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g ->  x a in\nlet base = fun d-> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x d x = a x in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun d x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'c -> 'a -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> fun s a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> fun b -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> fun b -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> fun d -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> (fun d -> a x) in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x (x a) in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x (x a) in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x (x (x a)) in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a-> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a-> x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a-> a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a-> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p a-> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base p = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = a in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = list.rev x in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = list.rev x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = List.rev x in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = List.rev x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type ('b -> 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type ('b -> 'b) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ =\n  let pipe fs = let f a x = x in fun x  -> x in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "in": "let pipe fs = \nlet f a x = x in fun x-> x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x fs in let base p = p in List.fold_left f base (List.rev fs);;\n", "in": "let pipe fs = \nlet f a x = x fs in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b -> 'b) list\n       The type variable 'a occurs inside 'a list -> 'b -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x  in\nlet base = a in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x  in\nlet base = 0 in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d a-> x a in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d a-> a x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d-> a x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x d = a x d in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "in": "let pipe fs = \nlet f a x = fun d-> a x d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "type", "out": "Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d-> x a d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d-> d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d-> a d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d-> x d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun d-> x (a d) in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x in let base p = x p in List.fold_left f base (List.rev fs);;\n", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> x p in\nList.fold_left f base (List.rev fs)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = 20;;\n\nlet pipe fs =\n  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;\n", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p ->a  p in\nList.fold_left f base (List.rev fs)", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun a' -> a' in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base (List.rev fs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x  in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x p' = a in let base a' = a' in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun p' -> a  in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> a x  in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a  in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p' -> x a  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  x a  in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x =  a x in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun p -> a x in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun p -> x a in\nlet base = pipe [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> a x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a  in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x l x = a in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x l x = a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x l x = a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x l x = x a in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun l -> fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x l = l (x a) in let base p = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun l -> l(x a) in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun l -> x (a l) in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat l)) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^ List.map f (sepConcat l) ^\"]\"", "type": "type", "out": "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat \"; \" l)) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\"^ List.map f (sepConcat \"; \" l) ^\"]\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n > 0 then x @ ((clone x n) - 1) else [];;\n", "in": "let rec clone x n = \nif n > 0 then \nx @ clone x n-1\nelse \n[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n > 0 then x @ ((clone x n) - 1) else [];;\n", "in": "let rec clone x n = \nif n > 0 then \nx @ (clone x n-1)\nelse \n[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x (n-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "in": "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\n(l1)@(l2)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 @ l2;;\n", "in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then\nl1 @ l2", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "in": "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\nl1 @ l2", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "in": "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\n(l1 @ l2)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if List.l1 > List.l2\n  then\n    let x = List.l1 - List.l2 in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if List.l1 < List.l2\n    then\n      (let x = List.l2 - List.l1 in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n", "in": "let padZero l1 l2 = \nif List.l1 > List.l2 then\nlet x = List.l1 - List.l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.l1 < List.l2 then\nlet x = List.l2 - List.l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "type": "scope", "out": "Error: Unbound value List.l1\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t ->\nif h == 0 then \nremoveZero t\nelse \nl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  let carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ initsum)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ initsum) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nList.rev removeZero (add (padZero l1 l2))", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nList.rev (removeZero (add (padZero l1 l2)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (List.rev (add (padZero l1 l2)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - initKeep) mod 100 in\n        (helpy p List.rev t carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "type": "scope", "out": "Error: Unbound value numList\nHint: Did you mean numsList?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - initKeep) mod 100 in\n        (helpy p List.rev t carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "type": "scope", "out": "Error: Unbound value initKeep\nHint: Did you mean intKeep?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        (helpy p List.rev t carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "type": "scope", "out": "Error: Unbound value initKeep\nHint: Did you mean intKeep?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ intKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@intKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ [intKeep] in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ [intKeep] in\n  removeZero (List.rev (helpy i l 0 [(0, 0)]));;\n", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0,0]))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = ((initMul-intKeep) mod 100)/10 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> [carry]@accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep)/10 in\nlet v = List.rev(t) in \nhelpy p v carrying [intKeep]@accList in\nremoveZero(List.rev(helpy i l 0 []))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> [carry]@accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep)/10 in\nlet v = List.rev(t) in \nhelpy p v carrying [intKeep]@accList in\nremoveZero(helpy i l 0 [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (List.rev (add (padZero l1 l2)));;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> [carry] @ accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) / 10 in\n        let v = List.rev t in (helpy p v carrying [intKeep]) @ accList in\n  removeZero (helpy i l 0 []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bottom_mult,total) = a in\n    match bottom_mult with\n    | [] -> total\n    | h::t ->\n        let newTotal = mulByDigit h x in\n        let updateTotal = bigAdd newTotal total in (t, updateTotal) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
