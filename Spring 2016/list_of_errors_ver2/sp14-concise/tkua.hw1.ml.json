{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList", "type": "type", "out": "Error: This expression has type int list -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList", "type": "type", "out": "Error: This expression has type int list -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> [((digitsOfInt n) / (10 n)) % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 n%10 :: []", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [digitsOfInt n];;\n", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n", "in": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> [digitsOfInt n/10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n%10]", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n_  -> digitsOfInt (n/10) @  [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> n mod 10::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> n mod (10 * (n/10))::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> n mod 10::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (hDigitsofInt n) =\n      ((match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10)));;\n", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "scope", "out": "Error: Unbound value hDigitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n = 0 then [0] else hDigitsofInt n;;\n", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n", "type": "scope", "out": "Error: Unbound value hDigitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n_  -> cat (digitsOfInt (n/10)) (n mod 10)\n| 0  -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [0] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (fun help  ->\n       fun n  -> match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10));;\n", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse fun help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\nint list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse help n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\nadditivePersistence (sumList (digits n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "digitalRoot", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n mod 10\nelse\nadditivePersistence (sumList (digits n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\n0 + additivePersistence (sumList (digits n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\n0 + additivePersistence (sumList (digits n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n/10 = 0 then n\nelse\n0 + digitalRoot (sumList (digits n) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat l h) :: t;;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> (cat l h)::t", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t h) :: l;;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> (cat t h)::l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse ((cat l h) :: t);;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h)::t)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (t :: (cat l h));;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse (t::(cat l h))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse (cat l h)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat ( listReverse l) t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat h (listReverse (t))", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat h (listReverse t);;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat l (listReverse (t) h)", "type": "scope", "out": "Error: Unbound value cat\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat l (listReverse t h);;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat listReverse (t) h", "type": "scope", "out": "Error: Unbound value cat\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> cat listReverse t h;;\n", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat (listReverse(t)) h", "type": "scope", "out": "Error: Unbound value cat\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet reverse = listReverse w", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet reverse = listReverse l;;\n", "in": "let palindrome w = \nlet l = explode w", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet reverse = listReverse l;;\n", "in": "let palindrome w = \nlet l = explode w", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nexplode w = listReverse (explode w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nexplode w = listReverse (explode w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse help n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> cat (listReverse(t)) h", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs =\nmatch xs with\n[]   -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
