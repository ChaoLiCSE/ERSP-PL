{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else 0;;\n", "in": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n0", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> l\n| (h::t) -> listReverse (h::l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nl [] list", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  l [] list;;\n", "in": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nlistReverse [] l", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  listReverse [] l;;\n", "in": "let rec listReverse l = match l with\n| [] -> l\n| [_::tail::[]] -> l", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "in": "let rec listReverseHelper l ans = \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = listReverseHelper l [];;\n", "in": "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "type": "scope", "out": "Error: Unbound value listReverseHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans)\n\nlistReverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper l ans = match l with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec listReverseHelper dec acc = match dec with\n| [] -> acc\n| h::t -> listReverseHelper t (h::acc) in \n\nlistReverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = if n > 0\nthen\nlistReverse (n mod 10) :: (digitsOfInt (n/10))\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n", "in": "let rec digitsOfInt n = if n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet rec digitsOfIntHelper n1 = \nif n > 0\nthen\n(n mod 10) :: (digitsOfIntHelper (n/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nlet rec digitsOfIntHelper n1 = \nif n1 > 0\nthen\n(n1 mod 10) :: (digitsOfIntHelper (n1/10))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n\n(* uncomment and run AFTER you have implemented additivePersistence  \n\nlet _ = additivePersistence 9876\n\n*)\n\n(* NOTE: assume that digitalRoot is only called with positive numbers *)\n\nlet rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n\n(* uncomment and run AFTER you have implemented additivePersistence  \n\nlet _ = additivePersistence 9876\n\n*)\n\n(* NOTE: assume that digitalRoot is only called with positive numbers *)\n\nlet rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \nn mod 10 + digitalRoot n\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n( n mod 10 )+ digitalRoot n/10\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n( n mod 10 )+ digitalRoot (n/10)\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot( n mod 10 )+ (n/10)\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (n mod 10 + n/10)\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec sumDigits n1 =\n    if n < 10 then n else (n1 % 10) + (sumDigits (n1 / 10)) in\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n", "in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n < 10 then \nn \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10)\nin \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec digitalRoot n = if n > 10 then digitalRoot sumDigits n else n;;\n", "in": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (sumDigits n)\nelse\nn", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = (explode w) = (explode (listReverse w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n", "in": "let palindrome w = (explode w) = (listReverse (explode w))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = (explode w) = (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = (explode w) = (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) % 9\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) mod 9\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n > 10) then \n1 + (n - 1) mod 9\nelse\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = 1 + (n - 1) mod 9", "type": "", "out": ""}], "event": "eval"}
