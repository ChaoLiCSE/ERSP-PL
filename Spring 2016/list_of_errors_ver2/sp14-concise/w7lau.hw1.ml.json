{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl ->\nhd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "sumList[1;-2;3;5]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "sumList[1;3;5;7;9;11]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | hd::tl -> hd :: (digitsOfInt tl));;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| hd::tl ->\nhd :: (digitsOfInt tl)", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] :: (n mod 10));;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [digitsOfInt (n mod 10)]);;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(digitsOfInt(n mod 10))]", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> (n mod 10) :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n) :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt n]);;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n) :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n % 10)]);;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n % 10) :: []", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> reduceADigit(n) mod 10 :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> reduceADigit(n) mod 10 :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10) in addDigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10) in ;\naddDigit [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 10 then n::next\nelse addDigit ((n mod 10)::next) (n/10)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| n -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nif n <= 0 then []\nelse let rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| n -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> addDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with | [] -> count | _ -> sumList (digitsOfInt n) (count + 1);;\n", "in": "let rec additivePersistence n count= \nmatch n with\n| [] -> count\n| _ -> additivePersistence(sumList(digitsOfInt(n)) (count+1))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence (sumList (digitsOfInt n) (count + 1));;\n", "in": "let rec additivePersistence n count= \nmatch n with\n| [] -> count\n| _ -> additivePersistence((sumList(digitsOfInt(n))) (count+1))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n", "in": "let rec additivePersistence n count= \nmatch n with\n| 0 -> count\n| _ -> additivePersistence((sumList(digitsOfInt(n))) (count+1))", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | 0 -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n", "in": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList digitsOfInt n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList (digitsOfInt n)", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence (sumList (digitsOfInt n))", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nmatch n with\n| _ -> (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nmatch n with\n| _ -> additivePersistence(sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList digitsOfInt n = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList digitsOfInt n) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n)) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n)) count+1\nelse count", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n)) count+1\nelse count", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n)) count+1\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence (sumList (digitsOfInt n)) count) + 1\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n) count+1)\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence ((sumList (digitsOfInt n) count) + 1)\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence((sumList (digitsOfInt n)) count+1)\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence (((sumList (digitsOfInt n)) count) + 1)\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumList (digitsOfInt n) count+1\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence sumList (digitsOfInt n) count) + 1\n        else count in\n  count = 0;;\n", "in": "let sumDigits = fun x -> sumList digitsOfInt x", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = sumDigits 123;;\n", "in": "let sumDigits = fun x -> sumList (digitsOfInt x)", "type": "scope", "out": "Error: Unbound value sumDigits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = sumDigits 123;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n count+1\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value sumDigits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence sumDigits n count) + 1\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n (count+1)\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence sumDigits n (count + 1)\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence (sumDigits n) count+1\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence (sumDigits n) count) + 1\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence sumDigits n count+1\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additiveSequence sumDigits n count) + 1\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count\nin count = 0", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additiveSequence (sumDigits n) count) + 1\n        else count in\n  count = 0;;\n", "in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumDigits n) i+1 in\nmatch n with\n| _ -> sequence n 0", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumDigits n) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence sumList (digitsOfInt x) i+1 in\nmatch n with\n| _ -> sequence n 0", "type": "scope", "out": "Error: Unbound value sumDigits\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence sumList (digitsOfInt x) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt x)) i+1 in\nmatch n with\n| _ -> sequence n 0", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt x)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1\nthen n\nelse digitalRoot (sumList (digitsOfInt n)) in\nmatch n with\n| digitalRoot n", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1\nthen n\nelse digitalRoot (sumList (digitsOfInt n)) in\nmatch n with\n| _ -> digitalRoot n", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| hd::tl -> reverse l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec reverse l acc = \nreverse l hd::acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse tl []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverse l acc = (reverse l hd) :: acc in\n  match l with | [] -> [] | hd::tl -> reverse tl [];;\n", "in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse accReverse tl hd::acc in \nmatch l with\n| [] -> []\n| hd::tl ->", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 352663;;\n", "in": "let digits n = digitsOfInt (abs n)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}, {"min": "", "in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | l -> accReverse l [];;\n", "in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse accReverse tl hd::acc in \nmatch l with\n| [] -> []\n| hd::tl -> accReverse l []", "type": "scope", "out": "Error: Unbound value tl\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | hd::tl -> accReverse l [];;\n", "in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse accReverse tl hd::acc in \nmatch l with\n| [] -> []\n| hd::tl -> accReverse hd::tl []", "type": "scope", "out": "Error: Unbound value tl\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | hd::tl -> (accReverse hd) :: (tl []);;\n", "in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse\nmatch l with\n| [] -> []\n| hd::tl -> accReverse tl hd::acc", "type": "scope", "out": "Error: Unbound value tl\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}, {"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let listReverse l = \nlet rec accReverse l acc =\nmatch l with\n| [] -> acc\n| hd::tl -> accReverse tl (hd::acc)", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l acc;;\n", "in": "let listReverse l = \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []", "type": "scope", "out": "Error: Unbound value accu\nHint: Did you mean acc?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) \nin lastDigit n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = at 3 [1; 3; 4; 5; 1];;\n", "in": "let palindrome w = fun x -> (explode s = listReverse(explode s))", "type": "scope", "out": "Error: Unbound value at\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n\nlet palindrome w x = (explode s) = (listReverse (explode s));;\n", "in": "let palindrome w = fun x -> (explode w = listReverse(explode w))", "type": "scope", "out": "Error: Unbound value s\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = (explode w = listReverse(explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n =\nmatch n with\nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let listReverse l = \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl ->\nhd + (sumList tl)", "type": "", "out": ""}], "event": "eval"}
