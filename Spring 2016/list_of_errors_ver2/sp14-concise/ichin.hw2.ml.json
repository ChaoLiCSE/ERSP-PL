{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nif f b = false then [] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f b') else c';;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f b')\nelse c'", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse c'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse c'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (neg b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f (neg b)),b)", "type": "scope", "out": "Error: Unbound value neg\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (not b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type bool -> bool -> bool * bool\n       Type int is not compatible with type bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ( (f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ( (f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "in": "let fixpoint (f,b) = wwhile ( (f b) <> b,b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( let ans = f b in (ans, ans <> b) ,b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ( let ans = f b in (ans, ans <> b),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "in": "let rec exprToString e = match e with \n| VarX -> VarX\n| VarY -> VarY\n| Sine (e1) -> exprToString e1\n| Cosine (e1) -> exprToString e1\n| Average (e1, e2) -> exprToString e1 ^ exprToString e2\n| Times (e1, e2) -> exprToString e1 ^ exprToString e2\n|Thresh (e1, e2, e3, e4) -> exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"\"\n| VarY -> \"\"\n| Sine (e1) -> exprToString e1\n| Cosine (e1) -> exprToString e1\n| Average (e1, e2) -> exprToString e1 ^ exprToString e2\n| Times (e1, e2) -> exprToString e1 ^ exprToString e2\n|Thresh (e1, e2, e3, e4) -> exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2\"\n| Times (e1, e2) -> \"Times\" ^ exprToString e1 ^ exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ exprToString e2 ^ exprToString e3 ^ exprToString e4 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| _ -> eval(buildX(), buildY(), y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | _ -> eval ((buildX ()), (buildY ()), y);;\n\nlet _ = eval ((Sine VarX), 1, 1);;\n", "in": "eval(Sine(VarX), 1,1)", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         expr\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| _ -> eval(buildX(), x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval(Sine(VarX), 11,22)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "eval(Sine(VarX), 1,22)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x *. 1.0\n  | VarY  -> y *. 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x *. 1.0\n| VarY -> y *. 1.0\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "eval(Sine(VarX), 1,22)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> 1.0\n| VarY -> 1.0\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (2 * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> 1.0\n| VarY -> 1.0\n| Sine(e1) -> sin(2* eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "eval(Sine(VarX), 1,22)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi* eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "eval(Sine(VarX), 1.0 ,22.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n\nlet _ = eval ((Sine VarY), 11.0, 0);;\n", "in": "eval(Sine(VarY), 11.0 ,0)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval(Sine(VarY), 11.0 ,0.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval(Sine(VarY), 1.0 ,0.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi*eval(e1,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "eval(Sine(VarY), 1.0 ,0.0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(a < b) then eval(a_less, x, y)\nelse eval(b_less, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if a < b\n      then (Printf.snprintf \"hi\"; eval (a_less, x, y))\n      else eval (b_less, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(a < b) then begin Printf.snprintf \"hi\"; eval(a_less, x, y); end\nelse eval(b_less, x, y)", "type": "scope", "out": "Error: Unbound value Printf.snprintf\nHint: Did you mean sprintf?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(a < b) then begin Printf.sprintf \"hi\"; eval(a_less, x, y); end\nelse eval(b_less, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y);", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(a_less, x, y);\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Print.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let x = sin(pi *. eval(e1,x,y)) in Print.sprintf \"sine is %d \" x\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "scope", "out": "Error: Unbound module Print\nHint: Did you mean Printf?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let x = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %d \" x\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %d \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %d \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %lf \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %lf \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" 2.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.printf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is %f \" 2.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.fprintf \"sine is %f \" 2.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         out_channel\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.fprintf \"sine is %f \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         out_channel\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is %f \" ans\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      if 1 then (sin (pi *. (eval (e1, x, y))); Printf.printf \"sine is \")\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand with\n|_ -> 1.0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand with\n|1 -> 1\n|2 -> 2\n|3->3\n|_ -> 4", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (r, d) with\n  | (_,0) -> if (r mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "in": "let rec build (rand, depth) = match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "type": "scope", "out": "Error: Unbound value r\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (r mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "in": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "type": "scope", "out": "Error: Unbound value r\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build (rand * 3)), (depth - 1)),\n          (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))));;\n", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuild(rand + 1, depth - 1)\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine( build(rand + 1, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) =\nmatch (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX()\n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) \nthen \nbegin \nPrintf.printf \"HIIIIIIIII!!!!!!!\";\nbuildSine( build(rand, depth - 1) )\nend\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) \nthen \nbegin \nPrintf.printf \"HIIIIIIIII!!!!!!!\";\nbuildSine( build(rand, depth - 1) );\nend\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.sprintf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) \nthen \nbegin \nPrintf.sprintf \"HIIIIIIIII!!!!!!!\";\nbuildSine( build(rand, depth - 1) );\nend\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> if rand > 1 then buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\nelse buildSine( build(rand + 1, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(1, 2) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build(rand, depth) = match rand with\n| (x,y) -> buildX()\n| (_,_) -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(1, 2) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand(1,z)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = match depth with | 0 -> let z = rand in rand in\n  if z > 1 then buildX () else buildY ();;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()", "type": "scope", "out": "Error: Unbound value z\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth) )\nelse buildCosine( build(rand, depth) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))\n| _ -> buildTimes( build(rand, depth), build(rand, depth) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))\n| _ -> buildTimes( build(rand, depth), build(rand, depth) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> buildTimes( build(rand, depth), build(rand, depth) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> buildTimes( build(rand, depth - 1), build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> buildTimes( build(rand, depth - 1), build(rand, depth - 1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 5) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> buildTime ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTime(build(rand, depth - 1 ), build(rand, depth - 1))", "type": "scope", "out": "Error: Unbound value buildTime\nHint: Did you mean buildTimes?\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTimes(build(rand, depth - 1 ), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTimes(build(rand, depth - 1 ), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(rand, depth - 1))\n\n\n| _ -> build(rand, depth - 1 )", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildCosine (rand, (depth - 1)))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(rand, depth - 1) ))\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(rand, depth - 1) ))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (buildCosine (rand, (depth - 1)))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildCosine(rand, depth - 1)  )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(rand, depth - 1) ))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(build(rand, depth - 1) )) )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(rand, depth - 1) ))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(build(rand, depth - 1) )) )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(build(rand, depth - 1) )))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth num));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth num )", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | 9 ->\n      let num = rand (1, 7) in\n      if (num mod 2) = 0\n      then\n        buildAverage\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildAverage\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - num));;\n", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n| 9 -> let num = rand(1,7) in\nif(num mod 2 = 0) then \nbuildAverage( buildSine(build(rand, depth - 1)), build(rand, depth - 1))\nelse\nbuildAverage( buildCosine(build(rand, depth - 1)), build(rand, depth - 1))\n\n| _ -> build(rand, depth - num )", "type": "scope", "out": "Error: Unbound value num\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n| 9 -> let num = rand(1,7) in\nif(num mod 2 = 0) then \nbuildAverage( buildSine(build(rand, depth - 1)), build(rand, depth - 1))\nelse\nbuildAverage( buildCosine(build(rand, depth - 1)), build(rand, depth - 1))\n\n| _ -> build(rand, depth - 1 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n|_ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 5) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( (num mod 2 ) = 0) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), buildCosine(build(rand, depth - 1)))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), buildCosine(build(rand, depth - 1)),\nbuildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), buildCosine(build(rand, depth - 1)))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), buildCosine(build(rand, depth - 1)),\nbuildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 7) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 6) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 6) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 6) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (10, 8, 270);;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine( buildSine(build(rand, depth - 1)))\n| 2 -> buildCosine(buildCosine(build(rand, depth - 1)))\n| 3 -> buildAverage(buildSine(build(rand, depth - 1)), buildCosine(build(rand, depth - 1)))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (10, 8, 270);;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 5) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildSine(build(rand, depth - 1))", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (10, 8, 270);;\n", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 6) in match num with\n| 1 -> buildSine(build(rand, depth - 1))\n| 2 -> buildCosine(build(rand, depth - 1))\n| 3 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 4 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (10, 270, 2);;\n", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 || 2 -> buildSine(build(rand, depth - 1))\n| 3 || 4 -> buildCosine(build(rand, depth - 1))\n| 5 || 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 || 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 || 4 -> buildCosine(build(rand, depth - 1))\n| 5 || 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 || 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "scope", "out": "Error: Unbound value ffor\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomColor (11, 23, 1993);;\n", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Percent  of expr\n| Negate   of expr\n| SumSquared of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) * (-1)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) * (eval (e1, x, y))) +\n         ((eval (e2, x, y)) * (eval (e2, x, y))))\n        + ((eval (e3, x, y)) * (eval (e3, x, y)));;\n", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y)\n| Percent(e1) -> eval (e1, x, y) *. 0.01\n| Negate(e1) -> eval (e1, x, y) *. (-1.0)\n| SumSquared(e1, e2, e3) -> eval(e1, x, y) * eval(e1, x, y) \n+ eval(e2, x, y) * eval(e2, x, y)\n+ eval(e3, x, y) * eval(e3, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y)\n| Percent(e1) -> eval (e1, x, y) *. 0.01\n| Negate(e1) -> eval (e1, x, y) *. (-1.0)\n| SumSquared(e1, e2, e3) -> eval(e1, x, y) *. eval(e1, x, y) \n+. eval(e2, x, y) *. eval(e2, x, y)\n+. eval(e3, x, y) *. eval(e3, x, y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != f xx) in g,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != (f xx))) in (g, b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Percent  of expr\n| Negate   of expr\n| SumSquared of expr * expr * expr", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Percent(e) -> \"(\" ^ exprToString e ^ \"*.01)\"\n| Negate(e) -> \"(-\" ^ exprToString e ^ \")\"\n| SumSquared(e1, e2, e3) -> \"((\" ^ exprToString e1 ^ \"^2)\" ^ \"(\" ^ exprToString e2 ^\n\"^2)\" ^ exprToString e3 ^ \"^2))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 15) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then buildPercent(rand, depth - 1)\nelse if(num mod 3 = 0) then buildNegate(rand, depth - 1)\nelse buildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then buildPercent(build(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 11) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then buildPercent(build(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7  -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> \nif(num mod 2 = 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 3 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse if(depth > 8) then begin\nlet num = rand(1,10) in\nif((num mod 3) == 0) then\nbuildSumSquared( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1))\nelse if(num mod 2 = 0) then buildNegate(build(rand, depth - 1))\nelse buildPercent(build(rand, depth - 1))\nend\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (12, 617, 321);;\n", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (12, 126, 3023);;\n", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildSumPercent(e)\t           = SumPercent(e1, e2, e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildSumPercent(e1, e2, e3)\t           = SumPercent(e1, e2, e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildSumPercent(e1, e2, e3)\t   = SumPercent(e1, e2, e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
