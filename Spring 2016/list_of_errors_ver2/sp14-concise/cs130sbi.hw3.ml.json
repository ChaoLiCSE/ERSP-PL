{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = match x with\n|[] -> a\n|h::t -> h*h\nin\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x\nin\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a\nin\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 1 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = f 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = f in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a s-> a*s in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a-> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a-> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y-> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y-> 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun a -> a in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun a -> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a x -> x a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun a-> f a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun a-> f a in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> f a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a-> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a -> a in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  \"\" in\nlet l =  h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = f in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  f in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string -> string -> string\n       but an expression was expected of type string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep [] in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep [] in\nlet l =  \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  \"\" in\nlet l =  \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  sepConcat sep t in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  \"\" in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep^a in\nlet base =  \"\" in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t then \"\" else \"a\" in\n      let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t then \"\" else \"a\" in\nlet l =  sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else \"\" in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else t in\n      let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else t in\nlet l =  sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h ^ sep in\n      let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=sep then sep else h^sep in\nlet l =  sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=sep then sep else h in\nlet l =  sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = \"\" then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=\"\" then sep else h in\nlet l =  sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h^sep in\nlet l =  sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  \"\"  in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h  in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat f l;;\n", "in": "let stringOfList f l = failwith List.map sepConcat f l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat l;;\n", "in": "let stringOfList f l = failwith List.map sepConcat l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map;;\n", "in": "let stringOfList f l = failwith List.map", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \"\") l;;\n", "in": "let stringOfList f l = failwith List.map (sepConcat \"\") l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "in": "let stringOfList f l = failwith List.map (sepConcat \" \") l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "in": "let stringOfList f l = failwith List.map (sepConcat \" \") (l)", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map ~l;;\n", "in": "let stringOfList f l = failwith List.map ~ l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (fun x  -> sepConcat \"\" x) l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> sepConcat \"\" x) l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map (fun x  -> x ^ x) l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> x^x) l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> x) l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "in": "let stringOfList f l = failwith List.map (fun x-> x) (l)", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = failwith List.map asd l;;\n", "in": "let stringOfList f l = failwith List.map asd l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = List.map asd l;;\n", "in": "let stringOfList f l = List.map asd l", "type": "scope", "out": "Error: Unbound value asd\nHint: Did you mean asd_ or asr?\nError: Unbound value asd\nHint: Did you mean asr?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value asd\nHint: Did you mean asd_ or asr?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat \"\") l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat \" \") l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \" \") l.string;;\n", "in": "let stringOfList f l = List.map (sepConcat \" \") l.string", "type": "scope", "out": "Error: Unbound record field string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat \"\") l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (fun x-> sepConcat x []) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun x  -> sepConcat x.string []) l;;\n", "in": "let stringOfList f l = List.map (fun x-> sepConcat x.string []) l", "type": "scope", "out": "Error: Unbound record field string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (fun x->x) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (fun x-> Printf.sprintf \"%s\" x) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (fun x-> Printf.sprintf \"%d\" x) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat f) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (f) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let acc = [] in if x = 0 then acc else acc :: ((clone x n) - 1);;\n", "in": "let rec clone x n =\nlet acc = [] in\nif x=0\nthen acc\nelse acc::clone x n-1", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "in": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "type": "type", "out": "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "in": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "type": "type", "out": "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x ne;;\n", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x ne", "type": "scope", "out": "Error: Unbound value ne\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: (accum (n - 1));;\n", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x::accum (n-1)", "type": "type", "out": "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone (x::accum) (n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "in": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone (x::accum) (n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nlet helper x n =\nif n<1\nthen accum\nelse (x::accum) in\nhelper x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nlet helper accum n=\nif n<1\nthen accum\nelse (x::accum) in\nhelper accum (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse (x::accum) in\nhelper accum (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse helper (x::accum)(n-1) in\nhelper accum n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = match (l1,l2) with\n| ([],[]) -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = (l1,l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = ((clone 0 2)::l1,l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = ((clone (clone 0 1)::l1 2),l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = ((clone 0::l1 2),l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2));;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen ((List.append (clone 0 (b-a)) l1),l2)\nelse if(b<a)\nthen (l1,(List.append (clone 0 (a-b)) l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 1) l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if 1 then List.append (clone 0 1) l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append (clone 0 1) l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append l1 l1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen a", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then \"\";;\n", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen \"\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = List.length l1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = let a = List.length l1 in\na", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if a < b then a;;\n", "in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;\n", "in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then clone 0 1;;\n", "in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen ((List.append (clone 0 (b-a)) l1),l2)\nelse if(b<a)\nthen (l1,(List.append (clone 0 (a-b)) l2))\nelse \n(l1,l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h=0 then removeZero t else l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (f) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (f) l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map f l));;\n", "in": "let stringOfList f l = sepConcat(\" \" (List.map (f) l))", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \",\" (List.map (f) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"\" (List.map (f) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \";\" (List.map (f) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"[;\" (List.map (f) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.append \"[\") ::\n  ((sepConcat \";\" (List.map f l)) \"]\");;\n", "in": "let stringOfList f l = List.append \"[\"::(sepConcat \";\" (List.map (f) l)) \"]\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" :: (sepConcat \";\" (List.map f l));;\n", "in": "let stringOfList f l = \"[\"::(sepConcat \";\" (List.map (f) l))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = (sepConcat \";\" (List.map (f) l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse helper (x::accum)(n-1) in\nhelper accum n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = ([],[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ((t, (h + x)) :: a) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(t,(h+x))::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = (l1, (h + x)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(l1,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int -> int -> bool\n       but an expression was expected of type\n         int list * int -> int -> int list * int\n       Type bool is not compatible with type int list * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in x + h in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\nx+h\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * 'a -> int -> int\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list * 'a \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ((x + h), []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * 'a -> int -> int * 'b list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([h],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in (0, 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(0,0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type (int * int) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in 0 :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [0; 0] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[0;0]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [[0]; [0]] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[[0];[0]]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * 'd list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [([], 0)] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[([],0)]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], (0 :: a)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[],0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list -> int -> bool\n       but an expression was expected of type\n         int list * int list -> int -> int list * int list\n       Type bool is not compatible with type int list * int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, b) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b -> 'c -> 'a list * 'b\n       Type bool is not compatible with type 'a list * 'b \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (l1, []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(l1,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,x+h::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,(x+h::b)))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3, asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3,asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3 asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3 asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 asd2))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, ((padZero asd3 asd2) :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2::b)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 0)\nthen\nlet asd= 1 in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet asd3=1::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet asd3=1::t in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if t = []\n        then\n          (let asd2 = (x + h) - 10 in\n           let asd3 = t in let asd3 = (h2 + 1) :: t2 in ([], (asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n([],asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value h2\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] & (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = (((List.rev 0) :: l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev 0::l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::5::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,5::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,5::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([1],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([1;1;1],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (1::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (1::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if((t=[]) && ((x+h)>9))\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif((t=[]) && ((x+h)>9))\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i ~=0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "type": "scope", "out": "Error: Unbound value ~=\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i != 0\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i != 0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit (helper i l accum);;\n", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\n(helper i l accum)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nhelper i l accum", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(l1,mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(l1,mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n((+)1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type\n         int list * 'a -> int -> (int -> int) * int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int -> int is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit (x*q) l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit (x*q) l1) in \nlet base = (1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q*10,mulByDigit (x*q) l1) in \nlet base = (1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q*10,(bigAdd w (mulByDigit (x*q) l1))) in \nlet base = (1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
