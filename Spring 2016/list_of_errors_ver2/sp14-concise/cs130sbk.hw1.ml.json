{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) @ (helper (n / 10)) in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) @ (helper (n / 10)) in\nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  (helper n).reverse;;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\n(helper n).reverse", "type": "scope", "out": "Error: Unbound record field reverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> xs | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> xs\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> [] | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> []\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) (n mod 10) in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append (helper (n / 10)) (n mod 10) in\nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [n mod 10] in\nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append [helper (n / 10)] [(n mod 10)]) in\nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append helper (n / 10) [n mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append helper (n / 10) [(n mod 10)]) in\nhelper n", "type": "type", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> helper (append [m / 10] [m mod 10]) in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  helper (append [(m / 10)] [(m mod 10)]) in\nhelper n", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs2 with | [] -> xs1 | hd::tl -> append (xs1 :: hd) tl in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs2 with \n| [] -> xs1\n| hd :: tl -> (append (xs1 :: hd) tl) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: append tl xs2 in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x <  10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x <  10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)\ndigits (-23422) is [2,3,4,2,2]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n) digits (-23422) is [(2, 3, 4, 2, 2)];;\n", "in": "let digits n = digitsOfInt (abs n)", "type": "scope", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = (digits - 23422) = [(2, 3, 4, 2, 2)];;\n", "in": "let digits n = digitsOfInt (abs n)", "type": "type", "out": "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = import math;;\n", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "type": "scope", "out": "Error: Unbound value import\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin (helper 0 n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then x else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 2) then x else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 2) then x else  (helper (count + 1) (sumList (digits x)))\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 2 then x else helper (count + 1) (sumList (digits x)) in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then x else  (helper (count + 1) (sumList (digits x)))\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumlist (digits x)) in\nif (next < 10) then x else  (helper (count + 1) next)\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumlist (digits x) in\n    if next < 10 then x else helper (count + 1) next in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then x else  (helper (count + 1) next)\nin (helper 0 n)", "type": "scope", "out": "Error: Unbound value sumlist\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if next < 10 then count else helper (count + 1) next in\n  helper 0 n;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (next < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec additivePersistence n = \nlet rec helper count x =\nlet next = (sumList (digits x)) in\nif (x < 10) then count else  (helper (count + 1) next) in \n(helper 0 n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper sumList digits x in\nhelper n", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper sumList digits x in\n  helper n;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList digits x) in\nhelper n", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList digits x) in\n  helper n;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n", "type": "scope", "out": "Error: Unbound value sumList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> tl (hd :: result) in\n  helper xs [];;\n", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "type": "scope", "out": "Error: Unbound value xs\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "in": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper l []", "type": "scope", "out": "Error: Unbound value xs\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = ((explode w) = listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList l = \nlet rec iter xs result = \nmatch xs with \n| [] -> result\n| hd :: tl -> iter tl (hd + result) in\niter l 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec append l1 l2 = \nlet rec helper xs1 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> helper tl (hd :: result) in\nhelper (listReverse l1) l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "type": "", "out": ""}], "event": "eval"}
