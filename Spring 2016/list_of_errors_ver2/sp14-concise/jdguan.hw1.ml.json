{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (* reaching the end of one list before the other *)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (* reaching the end of one list before the other *)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse explodeNum n;;\n", "in": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse explodeNum n", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "in": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> [listReverse l'; x];;\n", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "in": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> (r e l') :: x :: e\nin r [] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "in": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> e\n| (x::l') -> (r e l') :: x :: e\nin r [] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "in": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "type": "scope", "out": "Error: Unbound value explodeNum\nHint: Did you mean explode?\nError: Unbound value explodeNum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value explodeNum\nHint: Did you mean explode?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "in": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "type": "scope", "out": "Error: Unbound value explodeNum\nHint: Did you mean explode?\nError: Unbound value explodeNum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value explodeNum\nHint: Did you mean explode?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n = \nlet rec explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) @ [(n mod 10)]\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n / 10); n mod 10] else 0;;\n", "in": "let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) :: (n mod 10) :: []\nelse 0", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n", "in": "let listReverse l = \nlet rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []", "type": "scope", "out": "Error: Unbound value rev\nHint: Did you mean ref?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec rev o = function\n| [] -> []\n| h::t -> rev (h::o) t\nin rev [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec rev o a = \nmatch a with \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digitsOfInt ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n", "in": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digitsOfInt ((a mod 10)::o) (a/10)\nelse []\nin digits [] n", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse []\nin digits [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse o\nin digits [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
