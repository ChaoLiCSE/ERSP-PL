{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| hd::tl -> hd + sumList tl", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| hd::tl -> hd + sumList tl", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: ((digitsOfInt n) / 10);;\n", "in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt n/10", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse (n - (n/10) * 10) :: digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append digitsOfInt (n / 10) (n - ((n / 10) * 10));;\n", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append digitsOfInt (n/10) (n - (n/10) * 10)", "type": "type", "out": "Error: This function has type 'a list -> 'a -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse addIntToList (digitsOfInt (n/10)) (n - (n/10) * 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [(n - (n/10) * 10)]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [(n - (n/10) * 10)]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [n - (n/10) * 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = match digits (n) with\n| [] -> -1\n| hd::tl -> 1 + additivePersistence (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = match digits (n) with\n| [] -> -1\n| hd::tl -> 1 + additivePersistence (sumList tl)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList n));;\n", "in": "let rec additivePersistence n = \nif n < 10\nthen 0\nelse 1 + additivePersistence (sumList n)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10\nthen 0\nelse 1 + additivePersistence (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10\nthen n\nelse digitalRoot (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n <= 0\nthen []\nelse append (digitsOfInt (n/10)) [n - (n/10) * 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (hd (listReverse w))\n      then palindrome (tl (listReverse tail))\n      else false;;\n", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = (hd (listReverse w)) \nthen palindrome (tl (listReverse tail))\nelse false", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (hd (listReverse w))\n      then palindrome (tl (listReverse tail))\n      else false;;\n", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = hd (listReverse w)\nthen palindrome (tl (listReverse tail))\nelse false", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse w))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse w)\nthen palindrome (List.tl (listReverse tail))\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse [w]))\n      then palindrome (List.tl (listReverse [tail]))\n      else false;;\n", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse [w])\nthen palindrome (List.tl (listReverse [tail]))\nelse false", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         char\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | hd::[] -> true\n  | hd::tl ->\n      (match listReverse tl with\n       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;\n", "in": "let palindrome w = match (explode w) with\n| [] -> true\n| hd::[] -> true\n| hd::tl -> match (listReverse tl) with\n| hdr::tlr ->\nif hdr = hd\nthen palindrome tlr\nelse false", "type": "type", "out": "Error: This expression has type char list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "in": "let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palindrome tlr\nelse false\nin \npalHelper (explode w)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "in": "let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palindrome tlr\nelse false\nin \npalHelper (explode w)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palHelper tlr\nelse false\nin \npalHelper (explode w)", "type": "", "out": ""}], "event": "eval"}
