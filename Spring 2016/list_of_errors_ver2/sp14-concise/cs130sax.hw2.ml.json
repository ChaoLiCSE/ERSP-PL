{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen::h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = (seen::h) in\nlet rest' = (t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [hd]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl [hd] = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl (hd) = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [2]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl [2] = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem h tl) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem h tl = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem h seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem h seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd tl = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"NO IDEA\") ,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ (eTShelper p1 expr) \n| Cosine(p1) -> expr ^ (eTShelper p1 expr)\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\nin\neTShelper e \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\nin\neTShelper e \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper buildSine(p1) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type expr -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper buildSine(p1) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type expr -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper (buildSine p1) x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper (buildSine(p1)) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type expr -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper Sine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper Sine(p1) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi * (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi * evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (float evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. float evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "type": "type", "out": "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type int -> int -> float\n       but an expression was expected of type float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type int -> int -> float\n       but an expression was expected of type float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) / 2 in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y * evalhelper p2 x y) / 2\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y * evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y *. evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y +. evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\nin\nevalhelper e x y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> p1 *. p2\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n| Times(p1, p2) -> p1 *. p2\n| Thresh(p1, p2, p3, p4) ->\nif ((evalhelper p1 x y) < (evalhelper p2 x y))\nthen (evalhelper p3 x y)\nelse (evalhelper p4 x y)\nin\nevalhelper e x y", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n| Times(p1, p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n| Thresh(p1, p2, p3, p4) ->\nif ((evalhelper p1 x y) < (evalhelper p2 x y))\nthen (evalhelper p3 x y)\nelse (evalhelper p4 x y)\nin\nevalhelper e x y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "type": "type", "out": "Error: This expression has type string -> string\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "type": "type", "out": "Error: This expression has type string -> string\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (eTShelper p2 expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "type": "scope", "out": "Error: Unbound value eTShelper\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand (0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand (0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand (0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nlet temprand = makeRand(0,1) in\nmatch num with\n| 0 ->\nif (temprand = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet num =  rand(1,4) in \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper num depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand (1, 4) depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\n(*let num =  rand(1,4) in*) \nbuildhelper rand(1,4) depth \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 (depth-1))\nelse buildCosine(buildhelper 0 (depth-1))\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\n| 3 -> buildhelper (num-1) (depth) expr\n| 4 ->\nbuildThresh(buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr)\nin\nbuildhelper rand(1,4) depth \"\"", "type": "type", "out": "Error: This expression has type 'a -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine((buildhelper 0 (depth-1)))\nelse buildCosine(buildhelper 0 (depth-1))\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\n| 3 -> buildhelper (num-1) (depth) expr\n| 4 ->\nbuildThresh(buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr)\nin\nbuildhelper rand(1,4) depth \"\"", "type": "type", "out": "Error: This expression has type 'a -> expr\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildCosine (buildhelper 0 (depth - 1) expr)\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n(*\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildCosine(buildhelper 0 (depth-1) expr)\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         string\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper (depth - 1) (depth - 1) expr)\n        else buildCosine (buildhelper 0 (depth - 1) (depth - 1) expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "in": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "type", "out": "Error: This function has type int -> int -> 'a -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "in": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (rand(1,4)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,4)) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (rand(1,4)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,4)) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(1,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(1,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(0,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(0,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(0,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(1,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((fun k x -> f x != x), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x != x), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x != k), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != b in k b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in k b), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "in": "let fixpoint (f,b) = wwhile((fun k x = f x = x), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "in": "let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((fun k  -> fun x  -> (f x) = x), b);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x", "type": "type", "out": "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in k b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in f b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f b), b);;\n", "in": "let fixpoint (f,b) = wwhile({let k x = f x = x in k b), b", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b \nin\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile({let k x = f x in (b, b != b)), b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, ((k b) != b))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "in": "let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, (b != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let k x = f x in ((b, (b != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = y in ((x, (y != x)), b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let k x = let y = f x in (x, y!=x), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) = x in ((g b), b));;\n", "in": "let fixpoint (f,b) = wwhile(let g x = (f x) in g b, b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile(let g x = (f x != x) in g b, b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) != x in ((g b), b));;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != b), b));;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b), ((g b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile((let g f x = let y = f x in (y,y != x)), b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = f x !=x), b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in g b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = f x in g b), b)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (b, (xx != b)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g b = let xx = f x in (xx, (xx != b)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f b in (xx, (xx != b)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f xx in (xx, (xx != b)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g xx = let xx = f x in (xx, (xx != b)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in ((inwwhile b), ((inwwhile b) != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in (x, ((inwwhile b) != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in ((f b), (res != (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in (b, (res != (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in ((f b), (res != b)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in (res, (res != b)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in \nprintf(\"%d\\n\", helper)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in\n      printf (\"%d\\n\", helper)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = (f x) != (f b) in helper b)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = ((wwhile (let helper x = (f x) != (f b) in helper)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x != (f b)) in helper), b", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) != (f b))) in helper)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper), b", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) = (f b))) in helper)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b), b", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = (f b)) in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, (f x)=(f b)) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), ((f x) = (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=f b) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b!=f b) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b != (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=f x) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b != (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in (helper b)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f x) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f x))) in helper), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f b) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f b))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b < 10) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((let helper x = ((f x), (b < 10)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = b)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper b), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=(f x)) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b != (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (x != (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let xx = f x in ((f x), (x != (f x))) in helper), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let xx = f x in (xx, (x != xx)) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\nin\neTShelper e \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Thresh2  of expr * expr\n| Thresh3  of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/.2.0)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\n| Thresh2(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?1.0:0.0)\"\n| Thresh3(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \">\" ^ (eTShelper p2 expr) ^ \"?0.0:-1.0)\"\nin\neTShelper e \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\n| Thresh2(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?1:0)\"\n| Thresh3(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \">\" ^ (eTShelper p2 expr) ^ \"?0:-1)\"\nin\neTShelper e \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(1,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(1,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(0,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(0,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "type": "", "out": ""}], "event": "eval"}
