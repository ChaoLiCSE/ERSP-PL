{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a * a + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a * a) + x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = f in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = (+) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value p\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs p =\n  let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "in": "let pipe fs p = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'b\n       The type variable 'a occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun x->x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun p->p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ h in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  sepConcat sep t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" List.map f l ^ \"]\"", "type": "type", "out": "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\"", "type": "type", "out": "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) ) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1) in\n  helper n;;\n", "in": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1\nin \nhelper n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: (clone x (n - 1)) in\n  helper n;;\n", "in": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x (n-1)\nin \nhelper n", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "in": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "type": "scope", "out": "Error: Unbound value helper\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "in": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "in": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: (helper n-1)\nin \nhelper n", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "in": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec helper n = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "in": "let rec clone x n = \nlet rec helper n = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n > 0 then\nx :: (clone x (n-1) )\nelse\n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = (l1 @ (clone (List.length l2 - List.length l1) 0 ),\nl2 @ (clone (List.length l1 - List.length l2) 0 ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = (l1 @ (clone ((List.length l2) - (List.length l1)) 0 ),\nl2 @ (clone (List.length l1 - List.length l2) 0 ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = (l1 @ (clone 0 ((List.length l2) - (List.length l1)) ),\nl2 @ (clone 0 ((List.length l1) - (List.length l2)) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = ((clone 0 ((List.length l2) - (List.length l1)) @ l1 ),\n(clone 0 ((List.length l1) - (List.length l2)) ) @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = ((clone 0 ((List.length l2) - (List.length l1)) @ l1 ),\n(clone 0 ((List.length l1) - (List.length l2)) @ l2 ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| []    ->  []\n| h::t  ->  if h = 0 \nthen\nremoveZero t\nelse\nl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| []    ->  []\n| h::t  ->  if h = 0 \nthen\nremoveZero t\nelse\nl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (List.rev l1) (List.rev l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x1,x2) = failwith \"tbd\" in\nlet base = failwith \"to be implemented\" in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (0::l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = match i with\n| 0 ->  [0]\n| 1 ->  l\n| _ ->  bigAdd l (mulByDigit (i-1) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2 ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet mul (l1,l2) = \nlet f (a1,a2) (x1,x2) = failwith \"\" in\nlet base = (0,[]) in\nlet args =  List.combine (List.rev l1) l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (mul (padZero l1 (l2) ))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone a1 0)) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 ((mulByDigit x l2) @ (clone a1 0) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone a1 0)) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone 0 a1)) ) )  in\nlet base = (0,[]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f (a1,a2) x = (a1+1, bigAdd a2 (mulByDigit x (l2 @ (clone 0 a1)) ) )  in\nlet base = (0,[0]) in\nlet args =  List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun p -> p in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
