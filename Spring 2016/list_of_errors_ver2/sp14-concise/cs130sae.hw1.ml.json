{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t -> sum(xs, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t -> sum(xs, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y mod 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsofInt n));;\n", "in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsofInt(n)))", "type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitsofInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> reverse(l, [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if rev = (revexp ((explode w), \"\")) then true else false;;\n", "in": "let palindrome w = \nif rev = revexp(explode(w), \"\") then true else false", "type": "scope", "out": "Error: Unbound value rev\nHint: Did you mean ref?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "in": "let palindrome w = \nif w = revexp(explode(w), \"\") then true else false", "type": "type", "out": "Error: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "in": "let palindrome w = \nif w = revexp(explode(w), \"\") then true else false", "type": "type", "out": "Error: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec getap (n, x) = \nif n < 10 then x else getap(sumList(digitsOfInt(n)), x + 1)", "type": "", "out": ""}], "event": "eval"}
