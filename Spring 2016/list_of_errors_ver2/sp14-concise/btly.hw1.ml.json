{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| a::b -> a + sumList b", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt n []", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt (n/10) []", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt (n/10) []", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt (n/10) []", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = hd + (sumList tl);;\n", "in": "let rec sumList xs = hd + sumList(tl)", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = xs.hd + (sumList xs.tl);;\n", "in": "let rec sumList xs = xs.hd + sumList(xs.tl)", "type": "scope", "out": "Error: Unbound record field hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = (hd []) + (sumList (tl []));;\n", "in": "let rec sumList xs = hd[] + sumList(tl[])", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = (hd xs) + (sumList (tl xs));;\n", "in": "let rec sumList xs = hd xs + sumList(tl xs)", "type": "scope", "out": "Error: Unbound value hd\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10)::[n mod 10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10)::[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10) (n mod 10)::[]", "type": "type", "out": "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10) (n mod 10)::[]", "type": "type", "out": "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10)::[] (n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| _ -> digitsOfInt (n/10)::(n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@(n mod 10)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n == 0 then [0]\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match (n*10) with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::[n mod 10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse if n > 0 then myAppend [digitsOfInt(n/10)] (n mod 10)\nelse []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse if n > 0 then myAppend [digitsOfInt(n/10)] (n mod 10)\nelse []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse getDigits n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence sumList digits n);;\n", "in": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence sumList digits n", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence (sumList digits n));;\n", "in": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList digits n)", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n/10) = 0 then 1\nelse 1 + additivePersistence (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n/10) = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listCompare l k =\n  if ((List.hd l) = []) && ((List.hd k) = [])\n  then true\n  else\n    if (List.hd l) = (List.hd k)\n    then listCompare (List.tl l) (List.tl k)\n    else false;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = listCompare (explode w) (listReverse (explode w));;\n", "in": "let palindrome w = listCompare (explode w) (listReverse (explode w))", "type": "type", "out": "Error: This expression has type char list\n       but an expression was expected of type 'a list list\n       Type char is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
