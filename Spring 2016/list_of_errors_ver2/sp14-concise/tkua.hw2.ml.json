{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> let age = assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> let age = assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec assoc (d,k,l) = match l with | [] -> d | h::t -> assoc (d, k, l) in\n  if k = h then 10 else assoc (d, k, t);;\n", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "type": "scope", "out": "Error: Unbound value k\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> \nif k = h then 10 else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list list -> bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h , t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h @ [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h@[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then [] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then (h::[]) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not(List.mem h seen) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match b with\ntrue  -> f\n| false -> wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) = match b with | true  -> f | false  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "type", "out": "Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | () -> if b00l then num else wwhile (f, num);;\n", "in": "let rec wwhile (f,b) = match f b with\n()-> if b00l then num else wwhile (f, num)", "type": "scope", "out": "Error: Unbound value b00l\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if not(b00l) then num else wwhile (f, num)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f b,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)", "type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f b,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "in": "let fixpoint (f,b) = wwhile (b,b)", "type": "type", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint (f,b),b)", "type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (wwhile(f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type\n         int ->\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool)\n       Type int is not compatible with type\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool) \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (match f with num -> num,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "in": "let fixpoint (f,b) = wwhile ((),b)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = (f, x) in (y, (y != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Thresh (a,b,c,d) -> exprToString a b c d;;\n", "in": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         expr -> expr -> expr -> 'a\n       The type variable 'a occurs inside expr -> expr -> expr -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      ((exprToString a), (exprToString b), (exprToString c),\n        (exprToString d));;\n", "in": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> \n(exprToString a, exprToString b,exprToString c,exprToString d)", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c * 'd\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> \"x\"\n  | VarY y -> \"y\"\n  | Sine s -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "in": "let rec exprToString e = match e with\nVarX x -> \"x\"\n| VarY y -> \"y\"\n| Sine s -> \"sin (pi*\" ^ exprString e ^\")\"", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprString e ^\")\"", "type": "scope", "out": "Error: Unbound value exprString\nHint: Did you mean exprToString?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Averages  ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times  -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX     -> \"x\"\n| VarY     -> \"y\"\n| Sine e   -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times    -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh   \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "type": "type", "out": "Error: This variant pattern is expected to have type expr\n       The constructor Averages does not belong to type expr\nHint: Did you mean Average?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times e -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh e ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e   -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e  \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "type": "type", "out": "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*e)\n| Cosine e         -> cos(pi*e)\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.e)\n| Cosine e         -> cos(pi*.e)\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x +. y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average e -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average e    -> (x +. y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "type": "type", "out": "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\"", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      ((eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y)) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )", "type": "scope", "out": "Error: Unbound type constructor e4\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )", "type": "type", "out": "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| _  -> failwith \"rainbow\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| _  -> failwith \"rainbow\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| 2  -> buildCosine(build(rand, depth) )\n| 3  -> buildAverage(buildX(),buildY())\n| 4  -> buildTimes(buildX(),buildY())\n| 5  -> \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| 2  -> buildCosine(build(rand, depth) )\n| 3  -> buildAverage(buildX(),buildY())\n| 4  -> buildTimes(buildX(),buildY())\n| _  -> \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand % 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand %. 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "scope", "out": "Error: Unbound value %.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "type", "out": "Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 100) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 100) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = Format.sprintf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "in": "let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "scope", "out": "Error: Unbound value depth\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "in": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = if depth > 0 then Format.printf \"%d\" depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "type", "out": "Error: This expression has type unit but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" 5 in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet _ = Format.printf \">0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet _ = Format.printf \"0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet _ = Format.printf \">0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet _ = Format.printf \"0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (2, 13, 312);;\n", "in": "let play = \"(cos(pi*(x*y))<cos(pi*(x*y))?sin(pi*(x*y)):sin(pi*((x*y)/2)))\";\nlet _ = emitGrayscale (eval_fn play, 150, \"play\")", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = exprToString sampleExpr1;;\n", "in": "let buildX()                       = VarX", "type": "scope", "out": "Error: Unbound value exprToString\n"}, {"min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)", "type": "scope", "out": "Error: Unbound constructor VarY\n"}, {"min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)", "type": "scope", "out": "Error: Unbound constructor Sine\n"}, {"min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Cosine\n"}, {"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Average\n"}, {"min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "scope", "out": "Error: Unbound constructor Times\n"}, {"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = doRandomGray (2, 13, 312);;\n", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "scope", "out": "Error: Unbound value doRandomGray\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr * expr *expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}, {"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(sin(pi*\" ^ exprToString e1 ^\")/\"^\"cos(pi*\" ^ exprToString e2 ^\"))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) / (cos (pi *. (eval (e, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) -. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))-.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(eval(e,x,y))/.cos(eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> cos(pi*.eval(e,x,y))/.sin(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> cos(pi*.eval(e,x,y))/.sin(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(sin(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\"))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))*.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))*.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/3", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/.3.0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (eval(e,x,y)-.eval(e,x,y))/.3.0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (eval(e,x,y)+.eval(e,x,y))/.3.0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(\" ^ exprToString e1 ^\"+\"^\"cos\" ^ exprToString e2 ^\")/3\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(\" ^ exprToString e1 ^\"+\" ^ exprToString e2 ^\")/2\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"((\" ^ exprToString e1 ^\"+\" ^ exprToString e2 ^\")/2)\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 8) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"((sin(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e3 ^\")\"\n| Timmy2 (e1,e2)       ->\"(sin(pi*\" ^ exprToString e1 ^\")*\"^\"(sin(pi*\" ^ exprToString e2 ^\")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in match rnd with\n0 -> buildSine (build(rand, depth-1) )\n| 1 -> buildCosine(build(rand, depth-1) )\n| 2 -> buildAverage(build(rand, depth-1), build(rand,depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\n| 5 ->\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n| 6 ->\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\n| _ -> buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\n\nbuildSine (build(rand, depth-1) )\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))** cos(eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))** cos(pi *. eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth) ,build(rand, depth-depth))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))*. cos(pi *. eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))", "type": "type", "out": "Error: The constructor Timmy1 expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildTimmy1(e1,e2)          = Timmy1(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse \nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr\n| Timmy2   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildTimmy2(e1,e2)             = Timmy2(e1,e2,e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildTimmy2(e1,e2,e3)             = Timmy2(e1,e2,e3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^3(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))\n| Timmy2 (e1,e2,e3)       -> \n(sin(pi*.eval(e1,x,y)) ** 0.5) *. ((cos(pi*.eval(e2,x,y)) ** 2.0) *. cos(eval(e3,x,y)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))\n| Timmy2 (e1,e2,e3)       -> \n(sin(pi*.eval(e1,x,y)) ** 0.5) *. ((cos(pi*.eval(e2,x,y)) ** 2.0) *. cos(eval(e3,x,y)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1), build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
