{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n", "in": "let rec digitsOfInt n = match n with \n[] -> t\n| h::t -> [h]::digistOfInt(t)", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n", "in": "let rec digitsOfInt n = match n with \n[] -> h\n| h::t -> [h]::digistOfInt(t)", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digistOfInt t);;\n", "in": "let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digistOfInt(t)", "type": "scope", "out": "Error: Unbound value digistOfInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitstOfInt t);;\n", "in": "let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digitstOfInt t", "type": "scope", "out": "Error: Unbound value digitstOfInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digitsOfInt t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> [n % 10] :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = match n with \n0 -> []\n| n -> [n % 10]::digitsOfInt (n/10)", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10)::n mod 10\nelse []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt n/10::n mod 10\nelse []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (n / 10) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n >0 then n/10::n mod 10\nelse []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n >0 then digitsOfInt n/10::[n mod 10]\nelse []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n >0 then (digitsOfInt n/10)::[n mod 10]\nelse []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n >0 then (digitsOfInt n/10)@[n mod 10]\nelse []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n >0 then digitsOfInt n/10@[n mod 10]\nelse []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then [[(digitsOfInt n) / 10]; n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n >0 then [digitsOfInt n/10]::[n mod 10]\nelse []", "type": "type", "out": "Error: This expression has type 'a list list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n >0 then n::[n mod 10]\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> t::[listReverse h]", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> h + (additivePersistence t);;\n", "in": "let rec additivePersistence n = match n with\n| [] -> []\n| h :: t -> h + additivePersistence t", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10];;\n", "in": "let rec digitsOfInt n = \n\nif n >0 then n::[n mod 10]", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \n\nif n > 0 then digitsOfInt n :: n mod 10", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \n\nif n > 0 then (n mod 10) :: digitsOfInt (n/10)", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \n\nif n > 0 then (n mod 10) :: (digitsOfInt (listReverse(n/10)))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \n\nif n > 0 then listReverse (n mod 10) :: (digitsOfInt (n/10))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n", "in": "if n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: listReverse (digitsOfInt (n/10))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then (digitsOfInt (n/10)) :: [n mod 10]\nelse []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsofInt (n / 10)) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsofInt(n/10) :: (n mod 10) \nelse []", "type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) :: (n mod 10) \nelse []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ (n mod 10) \nelse []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > -1 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> t + (digitsOfInt (additivePersistence h));;\n", "in": "let rec additivePersistence n = match n with\n| [] -> []\n| h :: t -> t + digitsOfInt (additivePersistence h)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  if n < 10 then count else ((sumList (digitsOfInt n)), (count + 1));;\n", "in": "let additivePersistence n = \nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "type": "scope", "out": "Error: Unbound value count\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else ((sumList (digitsOfInt n)), (count + 1));;\n", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else (sumList (digitsOfInt n) count) + 1;;\n", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList (digitsOfInt n) count + 1", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif listReverse(explode(w))  = explode(w) then true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> t::[listReverse h]", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + (sumList t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n(* | h::t -> t::[listReverse h] *)\n| h::t -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n(* | h::t -> t::[listReverse h] *)\n| h::t -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n(* | h::t -> t::[listReverse h] *)\n| h::t -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else count + (1 sumList (digitsOfInt n));;\n", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 sumList(digitsOfInt n)", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ =\n  let additivePersistence n =\n    let count = 0 in if n < 10 then count else count + 1 in\n  sumList (digitsOfInt n);;\n", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 in sumList(digitsOfInt n)", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \n1 + sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \n1 + sumList(digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence sumList (digitsOfInt n));;\n", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence sumList(digitsOfInt n)", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let sum = 0 in\n  if n < 10 then n + sum else sum = (digitalRoot (sumList (digitsOfInt n)));;\n", "in": "let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n + sum\nelse sum = digitalRoot(sumList(digitsOfInt n))", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n < 10 then 0\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
