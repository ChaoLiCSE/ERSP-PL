{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n", "in": "let rec sumList xs = \nif xs::1 = 1 then 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n", "in": "let rec sumList xs = \nif xs::1 = 1 then 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}, {"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then 0;;\n", "in": "let rec sumList xs = \nif length xs = 0 then 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then xs = 0;;\n", "in": "let rec sumList xs = \nif length xs = 0 then xs = 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match list with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match list with\n| [] -> 0\n| head::tail -> head + sumList tail", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| [] -> 0\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| [ ] -> 0\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| [ ] -> 0\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| [] -> 0\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| [] -> 0\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs = match sumList with\n| head::tail -> head + sumList tail", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}, {"min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = sum xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = sum xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = h :: t;;\n", "in": "let rec sumList xs = h::t", "type": "scope", "out": "Error: Unbound value h\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match int with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = match int with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "scope", "out": "Error: Unbound value int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = match sumList with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match sumList with | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = match sumList with\n| h::t -> h + sumList t", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []", "type": "type", "out": "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \ndigits n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \ndigits n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = let digits n = x in sumList x;;\n", "in": "let additivePersistence n = \nlet digits n = x in\nsumList x", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n", "in": "let additivePersistence n = \ndigits n\nsumList n", "type": "type", "out": "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \ndigits n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = (digits n) = n;;\n", "in": "let additivePersistence n = \ndigits n = n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nsumList (digits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = if (sumList (digits n)) > 9 then 0;;\n", "in": "let additivePersistence n = \nif sumList (digits n) > 9 then 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet additivePersistence n = sumList (digits n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  if (sumList (digits n)) > 9 then additivePersistence (sumList (digits n));;\n", "in": "let additivePersistence n = \nif sumList (digits n) > 9\nthen additivePersistence (sumList (digits n))", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList digits n;;\n", "in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList digits n", "type": "scope", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits (n))", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "in": "let digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n"}, {"min": "", "in": "let listReverse l = failwith \"TBD\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "in": "let digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "in": "let rec digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec aux acc = function | [] -> acc | h::t -> aux (h :: acc) t in\n  aux [] list;;\n", "in": "let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] list", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif listReverse (explode w) = explode w\nthen true\nelse false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper n = function\n| [] -> n\n| hd::tl -> helper (hd::n) tl in\nhelper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper n = function\n| [] -> n\n| hd::tl -> helper (hd::n) tl in\nhelper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    (digitalRoot n) =\n      (if (sumList (digits n)) > 9\n       then helper (sumList (digits n)) (count + 1)\n       else count) in\n  helper n 0;;\n", "in": "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "type": "scope", "out": "Error: This expression has type bool but an expression was expected of type\n         int\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec helper xs =\n    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "in": "let listReverse l = \nlet rec helper xs = match xs with\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) \nin helper [] l", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "in": "let listReverse l = \nlet rec helper xs n  = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec helper xs l =\n    match n with | [] -> [] | hd::tl -> helper (hd :: xs) l in\n  helper [] l;;\n", "in": "let listReverse l = \nlet rec helper xs l  = match n with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper xs list  = match list with\n| [] -> []\n| hd::tl -> helper (hd::xs) list\nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = reverse [] list", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = reverse [] list", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec reverse res list =\n  match list with | [] -> [] | hd::tl -> reverse (hd :: res) list;;\n\nlet listReverse l = reverse [] list;;\n", "in": "let listReverse l = reverse [] l", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = reverse [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper n = function\n| [] -> n\n| hd::tl -> helper (hd::n) tl \nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits n (mylength n) list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength tl);;\n\nlet digitsOfInt n =\n  let rec digits n x list =\n    if n < 10\n    then n :: list\n    else\n      digits ((n / 10) + (n mod 10)) (((mylength n) / 10) + (n mod 10)) list in\n  digits n (mylength n) [];;\n", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(10** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(int_of_float 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::\n      l\n    else numdig :: 1 in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: 1 in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: l\nin digits n []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits x/10 l)\nelse numdig :: l\nin digits n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: ((digits x) / (10 l))\n    else numdig :: l in\n  digits n [];;\n", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) l)\nelse numdig :: l\nin digits n []", "type": "type", "out": "Error: This expression has type 'a -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen match l with\n| [] -> []\n| hd::tl -> \nx/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) tl)\nelse numdig :: l\nin digits n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen match l with\n| hd::tl -> \nx/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) tl)\nelse numdig :: l\nin digits n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [(digitsOfInt n) / 10;\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [digitsOfInt (n / 10);\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10];;\n", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]", "type": "scope", "out": "Error: Unbound value numdig\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits x) - 1)))))\n         mod 10];;\n", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]", "type": "scope", "out": "Error: Unbound value x\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int ((num_of_digits n) -1)) mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n = if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse (digitsOfInt (n/10))\nmatch n with\n| hd::tl -> hd\n:: [n mod 10]", "type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else (match n with | hd::tl -> [hd (digitsOfInt (n / 10)); n mod 10]);;\n", "in": "let digitsOfInt n =\nif n < 10 then n :: []\nelse match n with\n| (digitsOfInt (n/10)) :: [n mod 10]", "type": "scope", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n = if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [n mod 10]\nin recurse n []", "type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [x mod 10]\nin recurse n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec helper n = fun x-> match n with\n| [] -> n\n| hd::tl -> helper (hd::n) tl \nin helper [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =\nif n < 0 then []\nelse\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) (x mod 10 :: l)\nin recurse n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl hd::xs\nin recurse l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in\n  recurse l [];;\n", "in": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> xs\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
