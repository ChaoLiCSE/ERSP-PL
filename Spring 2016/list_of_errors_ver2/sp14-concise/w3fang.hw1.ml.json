{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n|[]->0\n|x :: xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n", "in": "let rec digitsOfInt n = \nif n<=0 then []\nelse int_of_char explode (string_of_int n)", "type": "type", "out": "Error: This function has type char -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n|[]->0\n|x :: xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList digitOfInt n;;\n", "in": "let rec additivePersistence n = sumList digitOfInt n", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList (digitOfInt n);;\n", "in": "let rec additivePersistence n = \n\nsumList (digitOfInt n)", "type": "scope", "out": "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \n\nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else n = (sumList (digitsOfInt n));;\n", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  n=sumList (digitsOfInt n)", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else n = (sumList (digitsOfInt n)) in\n  match n with | 0 -> 0 | _ -> n;;\n", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  n=sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else sumList (digitsOfInt n) in\n  match n with | 0 -> 0 | _ -> n;;\n", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n a =\n    if n < 10 then a else sumList (digitsOfInt n) in\n  match n with | 0 -> 0 | _ -> n;;\n", "in": "let rec additivePersistence n a= \nif n<10 then a\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif n<10 then n\nelse  additivePersistence (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n<10 then n\nelse  digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n<10 then n\nelse  digitalRoot (sumList (digitsOfInt n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet c=0 in\nlet rec break(num,count)=\nif num>9 then\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n<=0 then[]\nelse let rec loop n a =\nif n=0 then a\nelse loop(n/10)(n mod 10::a)in\nmatch n with\n|0->[0]\n|_->loop n[]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec a acc = function | [] -> acc | h::t -> a (h :: acc) t in a [] list;;\n", "in": "let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] list", "type": "scope", "out": "Error: Unbound value list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false", "type": "", "out": ""}], "event": "eval"}
