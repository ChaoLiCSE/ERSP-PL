{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x f _ = a * a in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (fun f _ -> a*a) in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int -> 'a -> 'b -> 'c -> int\n       but an expression was expected of type int -> 'a -> int\n       Type 'b -> 'c -> int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a*a+x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs = let f a x = () in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = () in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a*a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = x in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = x in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = 0 in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = 0 in\nlet base = fs in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = a + x in let base = base in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = base in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = 0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base = f in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = f in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base a = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = () in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = () in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a+x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x x = f (a x) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun x -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f -> (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f -> (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f -> (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f = f (a x) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun f -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x f = f x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun f -> f (x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f = a (f x) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun f -> a(f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a (f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (0) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x)a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet x _ f = f;;\n\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (x) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = () in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (x x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> a (x y)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun y -> y (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun y -> y (a y)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in\n      let base = \"\" in let l = h ^ t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = h ^ t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = t in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = t in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = h in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = l in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = [\"hello\"] in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep :: (sepConcat (sep t))) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep::sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat (sep t))) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ t) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat (sep t) in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat(sep t) in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sepConcat (h ^ (sep t)) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat(h^sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat h) ^ (sep t) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat h^sep t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list -> string\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"\";;\n", "in": "let stringOfList f l = List.map sepConcat \"\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map sepConcat", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat l \"\") f;;\n", "in": "let stringOfList f l = List.map (sepConcat l \"\") f", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l) f;;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" l) f", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l);;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l));;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" (f l))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l));;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" (f l))", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "in": "let stringOfList f l = List.map (sepConcat) f l", "type": "type", "out": "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) (f l);;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (f l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n", "in": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "in": "let stringOfList f l = List.map (sepConcat) f(l)", "type": "type", "out": "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (sepConcat) (f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map f l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"\" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \", \" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \", \" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\"^sepConcat \"; \" (List.map f l)^\"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone ((x n) - 1));;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone (x n-1)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else (clone x n) - 1;;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else ((helper x n) - (1 x)) :: acc in\n  helper x n [];;\n", "in": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x::acc\nin helper x n []", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif List.length l1 < List.length l2 then\nList.append [(clone 0 (List.length l2 - List.length l1) @ l1)] [l2]\nelse List.length l2 < List.length l1\nList.append [l1] [(clone 0 (List.length l1 - List.length l2) @ l2)]", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif List.length l1 < List.length l2 then\nList.append [(clone 0 (List.length l2 - (List.length l1)) @ l1)] [l2]\nelse List.length l2 < List.length l1\nList.append [l1] [(clone 0 (List.length l1 - List.length l2) @ l2)]", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif List.length l1 < List.length l2 then\nList.append [(clone 0 (List.length l2 - (List.length l1)) @ l1)] [l2]\nelse List.length l2 < List.length l1\nList.append [l1] [(clone 0 ((List.length l1) - List.length l2) @ l2)]", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif List.length l1 < List.length l2 then\nList.append [(clone 0 (List.length l2 - (List.length l1)) @ l1)] [l2]\nelse List.length l2 < List.length l1\nList.append [l1] [(clone 0 ((List.length l1) - (List.length l2)) @ l2)]", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif List.length l1 < List.length l2 then\nList.append [(clone 0 ((List.length l2) - (List.length l1)) @ l1)] [l2]\nelse List.length l2 < List.length l1\nList.append [l1] [(clone 0 ((List.length l1) - (List.length l2)) @ l2)]", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse (List.length l2) < (List.length l1)\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l1) >\n      ((List.length l2) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse (List.length l1) > (List.length l2)\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "type": "type", "out": "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| x::xs -> \nif x = 0 then removeZero xs\nelse xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| x::xs -> \nif x = 0 then removeZero xs\nelse x::xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = [] in\nlet args = [l1,l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\n0 0 9 9 + 1 0 0 2", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [l1] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = [l1] in\nlet args = [l1,l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\n0 0 9 9 + 1 0 0 2", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet x x = x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [x] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = [x] in\nlet args = [l1,l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\n0 0 9 9 + 1 0 0 2", "type": "type", "out": "Error: This expression has type ('a -> 'a) list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [1] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = [1] in\nlet args = [l1,l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\n0 0 9 9 + 1 0 0 2", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = 0 in\nlet args = [l1,l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\n0 0 9 9 + 1 0 0 2", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = 0 in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))\n\n0 0 9 9 + 1 0 0 2", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = 0 in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let x = padZero [9;9] [1;0;0;2]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let x = padZero [9;9] [1;0;0;2]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: res in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (q,w)::t -> q+w :: res\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value res\nHint: Did you mean ref?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: base in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (q,w)::t -> q+w :: base\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (q,w)::t -> q+w :: a\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (q,w)::t -> q+w :: a\n| _ -> a\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [(1, 2)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = [(1,2)] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (1, 2) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (1,2) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2)::t -> [h1+h2] in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2)::t -> h1+h2 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) acc = \nlet f a x = match x with\n| (h1,h2)::t -> h1+h2 :: acc  in\nlet base = acc in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) []);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) acc = \nlet f a x = match x with\n| (h1,h2)::t -> h1+h2 :: acc  in\nlet base = acc in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2) [])", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = [] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = [] in\nlet args = l1@l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a,a in\nlet base = [] in\nlet args = l1@l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (a1,a2)::aa -> a1+a2::x in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (a1,a2)::aa -> a1+a2 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> 'a -> int\n       but an expression was expected of type\n         (int * int) list -> 'a -> (int * int) list\n       Type int is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x1,x2)::xs -> x1+x2 :: x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x1,x2)::xs -> x1+x2 :: x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x1,x2)::xs -> x1+x2 :: x in\nlet base = [] in\nlet args = List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x1,x2)::xs -> x1+x2 :: x in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x1,x2)::xs -> x1+x2 :: x in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (a1,a2)::aa -> (a1+a2,0) :: x in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (a1,a2)::aa -> (a1+a2) :: x in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (a1,a2)::aa -> (a1+a2) :: a in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (a, b) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (a,b) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * 'c list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0,List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a\n       but an expression was expected of type (int * 'b list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a\n       but an expression was expected of type (int * 'b list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * 'b list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [(l1, l2)])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [l1,l2])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int list * int list) list\n       but an expression was expected of type int list\n       Type int list * int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [((l1 + l2), [])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (l1+l2, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (3, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, [l1]) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, [l1]) in\nlet args = [ (3, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = (0, []) in\nlet args = [ (0, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\n(add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x::xs -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x::xs -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [[ (h, l2 ) ]] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c+1,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c, c::d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c, c::d) in\nlet base = (1, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b * 'c -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c -> 'a\n       The type variable 'a occurs inside 'b * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [(1, 1)]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1,1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d::a,l2) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list -> int * int list -> int list * 'a\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int list * 'a is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c + d in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d)::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type (int * 'a list) list * 'b list\n       Type int is not compatible with type int * 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c,d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, [a]) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,[a]) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a list\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,c+t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,c+t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t::a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         'a list list -> 'b * 'a list -> 'b * 'a list list\n       but an expression was expected of type\n         'a list list -> 'b * 'a list -> 'a list list\n       Type 'b * 'a list list is not compatible with type 'a list list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b * 'a list -> 'b * 'a list\n       but an expression was expected of type 'a -> 'b * 'a list -> 'a\n       The type variable 'a occurs inside 'b * 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a) in\nlet base = (0, []) in\nlet args =  List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (h1,h2)::t -> h1+h2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (h1,h2)::t -> h1+h2::a in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::(t1,t2) -> t1 + t2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| h::(t1,t2) -> t1+t2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (h1,h2)::t -> h1+h2::a in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (h1,h2)::t -> h1+h2 @ a in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (h1,h2)::t -> [h1+h2] @ a in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (h1,h2)::t -> h1+h2::x in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (h1,h2)::t -> (h1+h2, h1+h2::x) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         (int * int) list -> int list -> int * int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int * int list is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (h1,h2)::t -> h1+h2, h1+h2::x in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         (int * int) list -> int list -> int * int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int * int list is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (h1,h2)::t -> (h1+h2,h1+h2)in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int * int) list -> 'a -> int * int\n       but an expression was expected of type\n         (int * int) list -> 'a -> (int * int) list\n       Type int * int is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (h1,h2)::t -> (h1+h2,h1+h2)::x in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (c,(d1,d2)::ds) -> d1+d2::x in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * (int * int) list -> int list -> int list\n       but an expression was expected of type\n         'a * (int * int) list -> int list -> 'a * (int * int) list\n       Type int list is not compatible with type 'a * (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (c,(d1,d2)::ds) -> (d1+d2 mod 10, d1+d2::x) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         int * (int * int) list -> int list -> int * int list\n       but an expression was expected of type\n         int * (int * int) list -> int list -> int * (int * int) list\n       Type int is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (c,(d1,d2)::ds) -> (d1+d2 mod 10, d1+d2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * (int * int) list -> 'a -> int * int\n       but an expression was expected of type\n         int * (int * int) list -> 'a -> int * (int * int) list\n       Type int is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (c,(d1,d2)::ds) -> (d1+d2 mod 10, x) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with \n| (c,(d1,d2)::ds) -> (d1+d2 mod 10, x) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> () in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> () in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2, ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2 mod 10, a::ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         int * int -> (int * int) list -> int * (int * int) list\n       but an expression was expected of type\n         int * int -> (int * int) list -> int * int\n       Type (int * int) list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1,d2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1,d2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1,d2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2,a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2,a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2,a::x) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         int * int -> (int * int) list -> int * (int * int) list\n       but an expression was expected of type\n         int * int -> (int * int) list -> int * int\n       Type (int * int) list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2,a::x in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type\n         int * int -> (int * int) list -> int * (int * int) list\n       but an expression was expected of type\n         int * int -> (int * int) list -> int * int\n       Type (int * int) list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2,a in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2, [] in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2, []) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = [List.rev (List.combine l1 l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2, a) in\nlet base = (0, []) in\nlet args = [List.rev (List.combine l1 l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> (d1+d2, a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list -> int * int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int * int list is not compatible with type int list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, (d1+d2 mod 10)::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2 mod 10, (d1+d2 mod 10)::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> ((d1+d2) mod 10, (d1+d2) mod 10::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/ 10, (d1+d2) mod 10::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (((((d1 + d2) mod 10) - (d1 + d2)) / 10),\n            (((d1 + d2) mod 10) + ((match a with | (a1,a2) -> a1))))\n          :: a2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)->a1)::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value a2\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10 +o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, ((d1+d2) mod 10) +o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2)/10, ((d1+d2) mod 10)+o ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1 + 1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2 + 1)) l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = let h::t = List.rev l in\nh*i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = let h::t = List.rev l in (mulByDigit h) * i;;\n", "in": "let rec mulByDigit i l = let h::t = List.rev l in\nmulByDigit h*i", "type": "type", "out": "Error: This expression has type 'a list -> 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l = let h::t = List.rev l in mulByDigit (h * i);;\n", "in": "let rec mulByDigit i l = let h::t = List.rev l in\nmulByDigit (h*i)", "type": "type", "out": "Error: This expression has type int list -> 'a\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int list -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> (h*i) :: acc \nin helper i l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (t * i)) :: acc in\n  helper i l [];;\n", "in": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(t*i) :: acc \nin helper i l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (h * i)) :: acc in\n  helper i l [];;\n", "in": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(h*i) :: acc \nin helper i l []", "type": "type", "out": "Error: This expression has type int list -> 'a list -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int list -> 'a list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> h*i :: acc \nin helper i l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;\n", "in": "let rec mulByDigit i l = mulByDigit i-1 (bigAdd l l)", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = mulByDigit (i-1) (bigAdd l l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> (bigAdd l l)\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 2 -> (bigAdd l l)\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 3 -> (bigAdd l l)\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 9 -> (bigAdd l l)\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 8 -> (bigAdd l l)\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 9 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 8 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = match i with\n| 7 -> l\n| _ -> mulByDigit (i-1) (bigAdd l l)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let mulByDigit i l = \nlet rec helper i l hold = \nmatch i with\n| 0 -> hold\n| _ -> helper (i-1) (bigAdd l hold) hold", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 0 [1; 1];;\n", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let a::t = l1 in\nmulByDigit a l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a::t = l1 in mulByDigit a l2;;\n", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a1 l2) (mulByDigit a2 l2)", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in bigAdd (mulByDigit a1 l2) (mulByDigit a2 l2);;\n", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ =\n  let a1::a2::t = l1 in\n  bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2));;\n", "in": "let a1::a2::t = l1 in\nList.rev (bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2)))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ =\n  let a1::a2::t = l1 in\n  List.rev (bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2)));;\n", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ =\n  let a1::a2::t = l1 in\n  bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2));;\n", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 (mulByDigit a1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in bigAdd (mulByDigit a2 (mulByDigit a1 l2));;\n", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 (mulByDigit a1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 (mulByDigit a1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in bigAdd (mulByDigit a2 (mulByDigit a1 l2));;\n", "in": "let a1::a2::t = l1 in\n(mulByDigit a2 (mulByDigit a1 l2))", "type": "scope", "out": "Error: Unbound value bigAdd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in mulByDigit a2 (mulByDigit a1 l2);;\n", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 l2) (mulByDigit a1 l2)@[0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 l2) (mulByDigit a1 l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 l2) ((mulByDigit a1 l2)@[0])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let clone x n = \nlet rec helper x n acc =\nif n < 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), ((bigAdd (mulByDigit h l2) p) @ (clone 0 b))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), (bigAdd (mulByDigit h l2) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let (h::t,y) = x in\n    ((o + 1), (bigAdd (mulByDigit h y) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = (l1, l2) in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, l1 ) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), (bigAdd (mulByDigit h y) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = [l1] in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value y\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet [h::t] = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet [h::t] = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), (bigAdd (mulByDigit h l2) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 l2) ((mulByDigit a1 l2)@ clone 0 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l3 = let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 l2) ((mulByDigit a1 l2)@ clone 0 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l4 = let a1::t = l3 in\nbigAdd (mulByDigit 9 l2) ((mulByDigit 9 l2) @ clone 0 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l4 = let a1::t = l3 in\nbigAdd (mulByDigit 9 l2) ((mulByDigit 9 l3) @ clone 0 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l4 = let a1::t = l3 in\nbigAdd (mulByDigit 9 l2) (l3 @ clone 0 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l2 = (mulByDigit 9 l1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l2 = bigAdd (mulByDigit 9 l1) ([] @ clone 0 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l3 = bigAdd (mulByDigit 9 l1) (l2 @ clone 0 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l4 = bigAdd (mulByDigit 9 l1) (l3 @ clone 0 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let l5 = bigAdd (mulByDigit 9 l1) (l4 @ clone 0 3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2 @ clone 0 o) (p)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
