{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> [1] \n| false -> [2]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []", "type": "scope", "out": "Error: Unbound value digOfIntHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n % 10] | false  -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n % 10] \n| false -> []", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::3::[n mod 10] \n| false -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | 0::[] -> []\n  | 1 -> []\n  | true  -> [digOfIntHelper n; []; n mod 10]\n  | false  -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n with\n| 0    -> []\n| [0]   -> []\n| 1     -> []\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; []; n mod 10] | false  -> [];;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> (digitsOfInt n) mod 10);;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt n mod 10", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt (n / 10)\n| true  -> digitsOfInt (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (digitsOfInt (n mod 10)));;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> (n / 10) :: digitsOfInt (n mod 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) ::  (n mod 10)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n / 10 :: digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> 1 :: digitsOfInt( n mod 10 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n/10 :: digitsOfInt( n mod 10 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n/10)\n| true  -> n/10 :: digitsOfInt( n mod 10 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with | false  -> n :: (digitsOfInt (n / 10)) | true  -> 1);;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 1);;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 1", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 2);;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 2", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [digitsOfInt (n / 10); n mod 10]);;\n", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> digitsOfInt ( n / 10 ) :: [n mod 10]", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "in": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in\n  reverseHelper [] l;;\n", "in": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t (h::revd )\nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "in": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse[] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [];;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse [] l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let rec reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "in": "let rec listReverse l =\nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper l [];;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper l []", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  r;;\n", "in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr", "type": "scope", "out": "Error: Unbound value r\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n", "in": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "type": "scope", "out": "Error: Unbound value reverseHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> r\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "in": "let listReverse l =\nlet rec reverseHelper l rl = \nfunction\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "type": "type", "out": "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nreverse (\nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \n(\nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlistReverse (\nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "in": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "in": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "in": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "in": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "in": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "in": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "type": "scope", "out": "Error: Unbound value n\n"}, {"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n = listReverse (digOfInt n);;\n", "in": "let rec digitsOfInt n = listReverse (digOfInt n)", "type": "scope", "out": "Error: Unbound value digOfInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n =  (digOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: l\n| true  -> digOfIntHelper (n / 10) ((n mod 10)::l)\nin\ndigOfIntHelper n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| h::t  -> addPerHelper (n + 1) t\nin\naddPerHelper 0 (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | [] -> 0\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumlist l)) in\n  addPerHelper 0 (digitsOfInt n);;\n", "in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumlist l))\nin\naddPerHelper 0 (digitsOfInt n)", "type": "scope", "out": "Error: Unbound value sumlist\nHint: Did you mean sumList?\nError: Unbound value sumlist\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sumlist\nHint: Did you mean sumList?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 1;;\n", "in": "let digits n = digitsOfInt (abs n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet digits n = digitsOfInt (abs n);;\n", "in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}, {"min": "\nlet _ = additivePersistence 9;;\n", "in": "let rec digitalRoot n = \nlet rec digRtHelper n l =\nmatch l with\n| [a]   -> a\n| _     -> digRtHelper (0) (digitsOfInt(sumList l))\nin\ndigRtHelper 0 (digitsOfInt n)", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 98763;;\n", "in": "let rec digitalRoot n = \nmatch digitsOfInt(l) with\n| [a]   -> a\n| _     -> digitalRoot (digitsOfInt(sumList l))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 98763;;\n", "in": "let rec digitalRoot n = \nmatch digitsOfInt(n) with\n| [a]   -> a\n| _     -> digitalRoot (sumList(digitsOfInt l))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 98763;;\n", "in": "let rec digitalRoot n = \nmatch digitsOfInt(n) with\n| [a]   -> a\n| _     -> digitalRoot (sumList(digitsOfInt n))", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n = \nmatch digitsOfInt(n) with\n| [a]   -> a\n| _     -> digitalRoot (sumList(digitsOfInt n))", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "scope", "out": "Error: Unbound value digitalRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nif (n > 0)\nthen (\nif (n > 9)\nthen (\ndigOfIntHelper (n / 10) ((n mod 10)::l) )\nelse (\nn :: l ) )\nelse ( \n[] )\nin\ndigOfIntHelper n []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h1)\nthen (\npalindrome t )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h1 then palindrome t else false);;\n", "in": "let palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "type": "scope", "out": "Error: Unbound value h1\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n", "in": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "type": "scope", "out": "Error: Unbound value palindrome\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"myxomatosis\";;\n", "in": "let palindrome w = palind (explode w)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}, {"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = palind (explode w);;\n", "in": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "type": "scope", "out": "Error: Unbound value palind\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\ntrue ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t2 )\nelse (\nfalse ) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  -> w = (listReverse w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = palind (explode w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  -> w = (listReverse w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = reverseHelper l [];;\n", "in": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "type": "scope", "out": "Error: Unbound value reverseHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = lReverse (l, [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let listReverse l = lReverse (l, [])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "type": "", "out": ""}], "event": "eval"}
