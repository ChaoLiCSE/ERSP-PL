{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n < 0)\nthen []\nelse (n mod 10 :: digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n < 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n <= 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n <= 0)\nthen []\nelse (n mod 10 :: digitsOfInt (n mod 10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n/10 :: []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10] @ digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10)@ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList n in num + (additivePersistence num));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList n in\nnum + additivePersistence num", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet counter = counter + 1 in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let counter = 0 in\n     counter = ((counter + (1 num)) + (additivePersistence num)));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = 0 in\ncounter = counter + 1\nnum + additivePersistence num", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\n(*let num = sumList myList in*)\nmyList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     counter = ((additivePersistence num) + 1));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\ncounter = additivePersistence num + 1", "type": "type", "out": "Error: This expression has type bool but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\n1 + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\n1 + additivePersistence num", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence sumList (digits n)", "type": "type", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence (sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nlet number = additivePersistence ( sumList (digits n)) in\nn", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then digRoot = n else additivePersistence (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif (n < 10)\nthen digRoot = n\nelse\nadditivePersistence ( sumList (digits n))", "type": "scope", "out": "Error: Unbound value digRoot\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digRoot\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "type": "scope", "out": "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value root\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "in": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "type": "scope", "out": "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value root\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\ndigitalRoot ( additivePersistence n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\ndigitalRoot(sumList(digits n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: [n mod 10]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10]::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10::digitsOfInt (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> 0;;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse t :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> (listReverse t) :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse ( append ( t [h] ) )", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse append (t [h]);;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse append ( t [h] )", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append ( t [h] ))", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append [h] t )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append (listReverse t :: [h])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append [listReverse t; h];;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append ( t [h])", "type": "scope", "out": "Error: Unbound value append\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> append (t [h]);;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append t [h]", "type": "scope", "out": "Error: Unbound value append\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h])", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> append t [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append (listReverse t) [h]", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlet myList = n mod 10::digitsOfInt (n/10) in\nlistReverse myList", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = digitsOfInt 3124;;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlet myList = n mod 10::digitsOfInt (n/10) in\nmyList", "type": "scope", "out": "Error: Unbound value digitsOfInt\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (n mod 10::digitsOfInt (n/10) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([n mod 10] append digitsOfInt (n/10) )", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ([n mod 10] append digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] digitsOfInt (n/10) )", "type": "scope", "out": "Error: Unbound value listReverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \n(append  (digitsOfInt (n/10)) [n mod 10] )", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  match w with\n  | \"\" -> true\n  | _ ->\n      let myString = explode w in\n      let reverseString = reverseList myString in\n      if myString = reverseString then true else false;;\n", "in": "let palindrome w = match w with \n| \"\" -> true\n| _ -> \nlet myString = explode w in\nlet reverseString = listReverse myString in\nif myString = reverseString\nthen true\nelse false", "type": "scope", "out": "Error: Unbound value reverseList\n"}], "event": "eval"}
