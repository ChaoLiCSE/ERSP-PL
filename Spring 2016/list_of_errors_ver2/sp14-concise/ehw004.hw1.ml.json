{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (n mod 10) :: (digitsofInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)", "type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10)::n mod 10", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (digitsOfInt n.length) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif digitsOfInt(n).length = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "type": "scope", "out": "Error: Unbound record field length\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif List.length digitsOfInt(n) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length digitsOfInt(n)) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "type": "type", "out": "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else inc count additivePersistence (addList (digitsOfInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\ninc count\nadditivePersistence(addList(digitsOfInt(n)))", "type": "scope", "out": "Error: Unbound value inc\nHint: Did you mean incr?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr count\nadditivePersistence(addList(digitsOfInt(n)))", "type": "type", "out": "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))", "type": "type", "out": "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))\n)", "type": "type", "out": "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1 then count else incr count;;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nincr(count)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int ref\n"}, {"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = additivePersistence (addList (digitsOfInt n));;\n", "in": "additivePersistence(addList(digitsOfInt(n)))", "type": "scope", "out": "Error: Unbound value n\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else count = (count + (1 additivePersistence (addList (digitsOfInt n))));;\n", "in": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \ncount = count + 1\nadditivePersistence(addList(digitsOfInt(n)))", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = additivePersistence addList digitsOfInt n;;\n", "in": "additivePersistence addList digitsOfInt n", "type": "scope", "out": "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "in": "addList digitsOfInt 5", "type": "type", "out": "Error: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "in": "addList digitsOfInt 5", "type": "type", "out": "Error: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "in": "addList (digitsOfInt,5)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "in": "addList (digitsOfInt,5)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum = if n < 10 then n else addList (digitsOfInt n);;\n", "in": "let rec addNum = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \naddNum n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = addNum n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse\ndigitalRoot(addList(digitsOfInt(n)))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse l @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let l = explode s in if (listReverse l) = l then true else false;;\n", "in": "let palindrome w = \nlet l = explode s in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "type": "scope", "out": "Error: Unbound value s\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \naddHelp(0, n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = List.fold_left(fun sum x -> sum + x) 0 xs", "type": "", "out": ""}], "event": "eval"}
