{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type (('a -> 'b) * ('b -> 'a)) list\n       but an expression was expected of type ('b -> 'b) list\n       Type ('a -> 'b) * ('b -> 'a) is not compatible with type 'b -> 'b \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h t\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| h::t -> f (fun x -> 0) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> 1) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> 0) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f  h\n| [] -> fun x -> x in \nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'a) list\n       but an expression was expected of type (('b -> 'a) -> 'b -> 'a) list\n       The type variable 'a occurs inside 'b -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = h in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = h in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in\n  List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f h t in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in\n  List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f t h in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x\n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> 0\n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x * 1\n| h::t -> f (fun x -> x * 1) h in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x/x\n| h::t -> f (fun x -> x/x) h in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> 1\n| h::t -> f (fun x -> 1) h in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> 1\n| h::t -> f h (fun x -> 1) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> 1\n| h::t -> f (fun x -> 1) h in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in\n      let base = f h in let x = f t in List.fold_left g base x;;\n", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = f t in\nList.fold_left g base x", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nList.fold_left g base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nList.fold_left g base t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m b = \"[\" ^ (b ^ \"]\") in\n      let n a x = a ^ (\" ;\" ^ x) in let base = f h in List.fold_left g base t;;\n", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left g base t", "type": "scope", "out": "Error: Unbound value g\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left n base t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ ((\";\" b) ^ \"]\")) in\n      let base = f h in List.fold_left m base l;;\n", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base h", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"]\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base t;;\n", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x\n| h::t -> f (fun x -> x) h in\nList.fold_left f base t", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left top helper;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left top helper", "type": "scope", "out": "Error: Unbound value top\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with \n| [] -> 0\n| h::t -> f (-1) h in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t -> \nlet g a x = a ^ \"; \" ^ x in\nlet base = f h in\nlet l = t in\nList.fold_left g base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" f l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" f l) ^ \"]\"", "type": "type", "out": "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse [x]::clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x::clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = if l1 < l2 then 0;;\n", "in": "let padZero l1 l2 = \nif l1 < l2 then 0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif List.length l1 < List.length l2 then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif (List.length l1) < (List.length l2) then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nif (List.length l1) < (List.length l2) then\n(clone 0 ((List.length l2) - (List.length l1))::l1),l2\nelse if (List.length l2) > (List.length l2) then\nl1, (clone 0 ((List.length l1) - (List.length l2))::l2)\nelse \nl1, l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1),l2\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (clone 0 (sec - first)) :: l1\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n", "in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1)\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then List.append l1 ((clone 0 (first - sec)) :: l2)\n    else (l1, l2);;\n", "in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nList.append l1 ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec removeZero l = match l with | 0 -> removeZero t | _ -> l;;\n", "in": "let rec removeZero l = match l with\n| 0 -> removeZero t\n| _ -> l", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.combine (List.rev l1) (List.rev l2) in\n    let args = List.split base in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = List.combine (List.rev l1) (List.rev l2) in\nlet args = \nList.split base in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = \nlet combo = List.combine (List.rev l1) (List.rev l2) in\nmatch combo with \n| (i,j) -> if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> (0,0) in \nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = \nlet combo = List.combine (List.rev l1) (List.rev l2) in\nmatch combo with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = \nlet combo = List.combine (List.rev l1) (List.rev l2) in\nmatch combo with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = 0 in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = 0 in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)-> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| _ -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          if (i + j) > 9 then a :: (1, ((i + j) - 10)) else a :: (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (i,j)-> \nif (i + j) > 9 then a::(1, (i + j - 10)) else a::(0 , i + j)\n| _ -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (i,j)-> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> a in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j) in\nlet base = [] in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) % 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\n((i+j+a)/10, (i+j+a)%10) in \nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\n((i+j+a)/10, (i+j+a) mod 10) in \nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> int * int -> int * int\n       but an expression was expected of type int -> int * int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \na::((i+j)/10, (i+j) mod 10) in\n\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\na::((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\na::((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (s, t) ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n(s,t)::((i+j+s+t)/10, (i+j+s+t) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \na::((i+j)/10, (i+j) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in (((i + j) mod 10), (a :: ((i + j) / 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \n((i+j) mod 10, a::((i+j)/10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) = a in\n(((i+j)/10), t::(i+j) mod 10) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), ((i + j) mod 10)) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t ) =  a in \n((i+j)/10, ((i+j) mod 10)) = a in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int -> int * int -> bool\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type bool is not compatible with type int * int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t ) =  a in \n((i+j)/10, t::((i+j) mod 10)) = a in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t ) =  a in \n((i+j+s)/10, t::((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t @ (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, t@((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, t::((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      a = ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \na = ((i+j+s)/10, t::((i+j+s) mod 10)) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int list -> int list * int list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev l2) :: 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1::0) (List.rev l2::0) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1::0) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev [0]::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev [0]) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev [0]::l1) (List.rev [0]::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type (int list * int list) list\n       but an expression was expected of type (int * int) list\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mul (i1,l1) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.rev (0 :: l1)) (List.rev (clone (List.length l) i)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul l);;\n", "in": "let rec mulByDigit i l = \nlet mul (i1, l1) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (clone (List.length l) i)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (mul l)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b * int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (clone (List.length l) i)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone (List.length l) i) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length + 1) l)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i ((List.length+1) l)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a list -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i (List.length l+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), (((mulByDigit x) * ((10 ** i) l2)) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), ((mulByDigit (x * (10 ** i)) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), ((mulByDigit (x * ((float_of_int 10) ** i)) l2)\n      :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1),\n      ((mulByDigit (x * (int_of_float ((float_of_int 10) ** i))) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1),\n      ((mulByDigit (x * (int_of_float ((float_of_int 10) ** i))) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1), ((mulByDigit (x * (int_of_float (m ** i))) l2)\n        :: n)) in\n    multipler (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultipler (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value multipler\nHint: Did you mean multiplier?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1), ((mulByDigit (x * (int_of_float (m ** i))) l2)\n        :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1),\n        ((mulByDigit (x * (int_of_float (m ** 10))) l2) :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int (List.length l1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1) - 1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1) - 1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1.0), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m-1.0, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (((mulByDigit x l2) * (int_of_float (10 ** m))) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n = ((i - 1), ((mulByDigit x l2) :: (clone 0 m) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (bigAdd ((mulByDigit x l2) :: (clone 0 m)) n)) in\n    multiplier ((List.length l1) - 1) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, bigAdd ((mulByDigit x l2)::(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m-1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = ((List.length - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = (List.length - 1 , []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: This expression has type 'a list -> int\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list -> int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1 , []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1), []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> []\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> []\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> (0,[])\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> (0,[0])\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, [0]) in\nlet args = 0::l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, [0]) in\nlet args = l1@[0] in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier i j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier i j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier i j in\nlet base = (List.length l1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 (List.length l1))) n) in\nmultiplier i j in\nlet base = (List.length l1 - 1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 (List.length l1 - 1))) n) in\nmultiplier i j in\nlet base = (List.length l1 - 1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m-1, bigAdd ((mulByDigit x l2)@(clone 0 (List.length l1 - 1))) n) in\nmultiplier i j in\nlet base = (List.length l1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
