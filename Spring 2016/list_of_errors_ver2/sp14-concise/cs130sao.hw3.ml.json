{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = f a in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = f a in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f a -> f x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f a f x = f z in let base y = z in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> z in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value z\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f a f x = f w in let base y = z in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun f a -> fun f x -> f w in\nlet base = fun y -> z in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value w\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y z = z in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y z-> z in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'b\n       but an expression was expected of type\n         'a -> 'b -> ('c -> 'b -> 'd) -> 'c -> 'd\n       The type variable 'b occurs inside ('c -> 'b -> 'd) -> 'c -> 'd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x f x = f (x a) in let base z = z in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun f x -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('c -> 'd) -> ('a -> 'c) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('c -> 'd) -> ('a -> 'c) -> 'd\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x z = f (x a) in let base z = z in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun z -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value f\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a x in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h ^ sep in let l = h in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = h ^ sep in\nlet l = h in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"mao\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = t in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base ", "type": "type", "out": "Error: This expression has type string list -> string\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^sep ^ a in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = a in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = a in\nlet l = sl in\nList.fold_left f base l", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"\" ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.map \"[\") ^ ((sepConcat l) ^ \"]\");;\n", "in": "let stringOfList f l = List.map \"[\" ^ sepConcat l ^ \"]\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map sepConcat l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"\" l;;\n", "in": "let stringOfList f l = List.map sepConcat \"\" l", "type": "type", "out": "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "in": "let stringOfList f l = List.map f (sepConcat \"\" l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "in": "let stringOfList f l = List.map f (sepConcat l)", "type": "type", "out": "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "in": "let stringOfList f l = List.map f (sepConcat \"\" l)", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map (f (sepConcat \"\" l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n", "in": "let stringOfList f l = sepConcat (List.map f l)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"\" (List.map f l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if x <= 0 then [] else [clone x];;\n", "in": "let rec clone x n = \nif x <= 0 then []\nelse\nclone x::[] (n-1)", "type": "type", "out": "Error: This expression has type 'a -> 'b list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if x <= 0 then [] else clone [x] (n - 1);;\n", "in": "let rec clone x n = \nif x <= 0 then []\nelse\nclone (x::[]) (n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else clone [x] (n - 1);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x::[]) (n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then x else clone [x] (n - 1);;\n", "in": "let rec clone x n = \nif n <= 0 then x\nelse\nclone (x::[]) (n-1)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec clone x n = if n <= 0 then [] else clone x (n - 1) in clone [] n;;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)\nin clone [] n", "type": "scope", "out": "Error: Unbound value n\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone h) :: (x (n - 1)));;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone t (n - 1)) :: h);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n", "in": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h ::[]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0 then (((clone (-1)) * (l l2)), l2) else (l1, (clone l l2));;\n", "in": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone (-1)* l l2), l2)\nelse (l1, clone l l2)", "type": "type", "out": "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) :: l2));;\n", "in": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l :: l2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) :: l2));;\n", "in": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l :: l2)", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n", "in": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)", "type": "scope", "out": "Error: Unbound value clone\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value clone\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t-> \nif h = 0 then removeZero t\nelse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t-> \nif h = 0 then removeZero t\nelse t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t-> \nif h = 0 then removeZero t\nelse h::t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (a+x) mod 10 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (a + x) mod 10 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = 0 in\nlet args = 1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = 0 in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = 0 in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failWith in\nlet base = failWith in\nlet args = failWith in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith in\nlet base = failwith in\nlet args = failwith in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith in\n    let base = failwith in\n    let args = failwith in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = failwith \"\" in\nlet args = failwith \"\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type string -> 'a\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = failwith \"\" in\nlet args = failwith \"\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = (a + x) mod 10 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = (a + x) mod 10 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = x mod 10 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = x mod 10 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: t in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | _ -> [a mod 10] | h::t -> ((a + h) mod 10) :: t in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: [] in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> [a mod 10] | h::t -> [(a + h) mod 10] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [0] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in macth x", "type": "type", "out": "Error: This expression has type int list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> add1 + add2 + a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> add1 + add2 + a in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a) mod 10 :: t in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (add1,add2) -> (((add1 + add2) + a) mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a) mod 10 in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value t\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a) mod 10 in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a) mod 10 in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a) mod 10 ::[]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> [((add1 + add2) + a) mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) ->\nlet carry = (add1 + add2 + a) mod 10 in\nlet digit = (add1 + add2 + a) / 10 in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> int * int -> int list\n       but an expression was expected of type int -> int * int -> int\n       Type int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> ((add1 + add2 + a) mod 10,(add1 + add2 + a) / 10)  in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (add1,add2) ->\n          ((((add1 + add2) + a) mod 10), (((add1 + add2) + a) / 10)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a)/ 10  in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int -> int * int -> int * int\n       but an expression was expected of type int -> int * int -> int\n       Type int * int is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a)/ 10  in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> ((add1 + add2 + a)/ 10,(add1 + add2 + a)/ 10)   in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a)/ 10   in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + a) / 10), ((((add1 + add2) + a) mod 10) ::\n                 reest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: reest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value reest\nHint: Did you mean rest?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)\n| (x,y) -> ((carry/10), (carry mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)\n| () -> ((carry/10), (carry mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))\n           | () -> ((carry / 10), ((carry mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)\n| (_,_) -> ((carry/10), (carry mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type unit\n       but a pattern was expected which matches values of type 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| () -> (carry::rest)\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (,) -> (carry::rest)\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (_,_) -> carry :: rest\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = () then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = ()\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = [] then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (,) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = (Nil, Nil)\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (,) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound constructor Nil\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length x = List.length l1 or List.length x = List.length l2 then\ncarry::rest\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length x) = (List.length l1)) or\n                   ((List.length x) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\ncarry::rest\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length rest) = (List.length l1)) or\n                   ((List.length rest) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 || List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> \nif List.length rest = List.length l1 || \nList.length rest = List.length l2 \nthen\n(0, carry::rest)\nelse match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> \nif List.length rest => List.length l1 || \nList.length rest => List.length l2 \nthen\n(0, carry::rest)\nelse match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          if\n            ((List.length rest) => (List.length l1)) ||\n              ((List.length rest) => (List.length l2))\n          then (0, (carry :: rest))\n          else\n            (match x with\n             | (add1,add2) ->\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> \nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, carry::rest)\nelse match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value =>\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) \nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10,)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x =\n        match a with\n        | (carry,rest) ->\n            (match x with\n             | (add1,add2) ->\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n      if\n        ((List.length rest) >= (List.length l1)) ||\n          ((List.length rest) >= (List.length l2))\n      then (0, ((((add1 + add2) + carry) / 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value rest\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) && carry > 0 then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "et _ = bigAdd [5;0] [5;0]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) && new_carry > 0 then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) && new_carry = 1 then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = ((add1 + add2 + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = ((add1 + add2 + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = ((add1 + add2 + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        (match x with\n         | (mul1,mul2) ->\n             let new_carry = ((mul1 * mul2) + carry) / 10 in\n             let result = (((add1 + add2) + carry) mod 10) :: rest in\n             if\n               (((List.length result) = (List.length l1)) ||\n                  ((List.length result) = (List.length l2)))\n                 && (new_carry = 1)\n             then (0, (new_carry :: result))\n             else (new_carry, result)) in\n  let base = (0, []) in List.fold_left f base (List.rev l);;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "type": "scope", "out": "Error: Unbound value add1\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        (match x with\n         | (mul1,mul2) ->\n             let new_carry = ((mul1 * mul2) + carry) / 10 in\n             let result = (((mul1 * mul2) + carry) mod 10) :: rest in\n             if\n               (((List.length result) = (List.length l1)) ||\n                  ((List.length result) = (List.length l2)))\n                 && (new_carry = 1)\n             then (0, (new_carry :: result))\n             else (new_carry, result)) in\n  let base = (0, []) in List.fold_left f base (List.rev l);;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "type": "scope", "out": "Error: Unbound value l1\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (1,[]) in\nList.fold_left f base (List.rev l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (1,[]) in\nlet (_, res) = List.fold_left f base (List.rev l) in res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_left f base (List.rev l) in res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base l in res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in let (_,res) = List.fold_right f base l in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res", "type": "type", "out": "Error: This expression has type int * int list -> int -> int * int list\n       but an expression was expected of type int * int list -> int -> int\n       Type int * int list is not compatible with type int \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) ->\n        ((index + 1), (bigAdd (padZero (mulByDigit x l1) rest))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res", "type": "scope", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) -> ((index + 1), (bigAdd (padZero rest mulByDigit x l1))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res", "type": "scope", "out": "Error: This function has type int list -> int list -> int list * int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int list -> int list * int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) ->\n        ((index + 1), (bigAdd (padZero rest (mulByDigit x l1)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res", "type": "scope", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) ->\n        ((index + 1), (bigAdd (padZero rest (mulByDigit x l1)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res", "type": "scope", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_left f base (List.rev l) in res", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet _ = bigAdd (padZero [] (mulByDigit 9 [9; 9; 9; 9]));;\n", "in": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_left f base (List.rev l) in res", "type": "scope", "out": "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = ((add1 + add2 + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| h::t-> \nif h = 0 then removeZero t\nelse h::t", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index+1, bigAdd rest (mulByDigit x l1)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index+1, bigAdd rest ((mulByDigit x l1)@clone 0 index)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index + 1, \nbigAdd rest ((mulByDigit x l1)@clone 0 index)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> \nlet new_index = index + 1 in\nlet results = bigAdd rest ((mulByDigit x l1)@clone 0 index)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10;;\n\nlet _ =\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> \nlet new_index = index + 1 in\nlet results = bigAdd rest ((mulByDigit x l1)@clone 0 index)", "type": "scope", "out": "Error: Unbound value l1\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index + 1, \nbigAdd rest ((mulByDigit x l1)@clone 0 index)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index + 1, \nbigAdd rest ((mulByDigit x l1)@clone 0 index)) in\nlet base = (0,[]) in\nlet args = List.rev (l1) in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index + 1, \nbigAdd rest ((mulByDigit x l1)@clone 0 index)) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
