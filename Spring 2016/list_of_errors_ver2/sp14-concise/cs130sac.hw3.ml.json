{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet sqsum xs =\n  let f a x = (x * x) + b in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = (x*x) + b in\nlet base = 0 in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value b\n"}, {"min": "", "in": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a b = a + (b*b) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun a x ->  x  in \nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let pipe fs = failwith \"boo!\" in\n  let f a x a x = x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = failwith \"boo!\" in\nlet f a x =  fun a x ->  x  in \nlet base = fun x -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value fs\n"}, {"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n > 0 then x :: (clone ((x n) - 1)) else x;;\n", "in": "let rec clone x n = \nif n > 0 then x::clone(x n-1)\nelse x", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int\n"}, {"min": "", "in": "let padZero l1 l2 = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n > 0 then x :: (clone (x (n - 1))) else [];;\n", "in": "let rec clone x n = \nif n > 0 then x::clone(x (n-1))\nelse []", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         int -> 'a\n       The type variable 'a occurs inside int -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone (x (n - 1)));;\n", "in": "let rec clone x n = \nif n < 1 then []\nelse x::clone(x (n-1))", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         int -> 'a\n       The type variable 'a occurs inside int -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n < 1 then []\nelse x::(clone x (n-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n = \nif n > 0 then x::(clone x (n-1))\nelse []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = match l with\n| []   -> []\n| h::t -> \nif h = 0 then removeZero t\nelse l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if lenght1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif lenght1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero(0::l1)\nelse padZero(0::l2)", "type": "scope", "out": "Error: Unbound value lenght1\nHint: Did you mean length1?\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero(0::l1)\nelse padZero(0::l2)", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero(0::l1, l2)\nelse padZero(l1, 0::l2)", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero((0::l1), l2)\nelse padZero(l1, (0::l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero(0::l1), l2)\nelse (padZero l1, (0::l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1), l2)\nelse (padZero l1, (0::l2))", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a b = a + (b*b) in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x x = a (x y) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x =  fun x -> a ( x y )  in \nlet base = fun x -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value y\n"}, {"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x x = a (y x) in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x =  fun x -> a ( y x )  in \nlet base = fun x -> x in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value y\n"}, {"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x =  fun y -> x ( a y )  in \nlet base = fun x -> x in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n", "in": "let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type string -> string list -> string\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,result) = a in\n      let (d1,d2) = h in\n      let s = (d1 + d2) + cin in ((s / 10), ((s mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (cin, result) = a in\nlet (d1, d2) = h in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value h\n"}, {"min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (cin, result) = a in\nlet (d1, d2) = x in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (d1, d2) = x in\nlet (cin, result) = a in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (eFromList1, eFromList2) = x in\nlet (cin, result) = a in\nlet sum = eFromList1 + eFromList2 + cin in\nlet tens = (sum / 10) in\nlet ones = (sum mod 10) in\n(tens, ones::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (big 1 1) (mulByDigit (i - 2) l);;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd (big 1 1) (mulByDigit (i-2) l)", "type": "scope", "out": "Error: Unbound value big\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd 1 1) (mulByDigit (i - 2) l);;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd (bigAdd 1 1) (mulByDigit (i-2) l)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd 1 1) (mulByDigit (i-2) l) )", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd 1 1) (mulByDigit (i-2) l) )", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) )", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) )", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}, {"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) )", "type": "type", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = match i with\n| (-1) -> []\n| 0  -> []\n| 1  -> l\n| _  -> bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = match i with\n| (-1) -> []\n| 0    -> []\n| 1    -> l\n| _    -> bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd base g;;\n", "in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd base g", "type": "scope", "out": "Error: Unbound value b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd base g;;\n", "in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd base g", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n", "in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd [] g", "type": "scope", "out": "Error: Unbound value g\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet thisFun = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd [] thisFun", "type": "", "out": ""}], "event": "eval"}
