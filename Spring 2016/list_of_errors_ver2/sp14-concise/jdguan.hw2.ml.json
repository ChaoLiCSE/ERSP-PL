{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 50) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 25) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 2) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 3) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 4) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 25) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 24) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 23) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 22) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 512) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 500) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 513) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 600) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 20) in\nwwhile (f, 3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 28) in\nwwhile (f, 3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)", "type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)", "type": "type", "out": "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)", "type": "type", "out": "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "in": "let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)", "type": "type", "out": "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else (((f b), true), b));;\n", "in": "let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if x = (f x) then (b, false) else ((b, true), b));;\n", "in": "let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if x = (f x) then (x, false) else ((x, true), b));;\n", "in": "let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else ((b, true), b));;\n", "in": "let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((if b = (f b) then (b, false) else (b, true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile ((helper b), b);;\n", "in": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)", "type": "type", "out": "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) in\nwwhile (helper,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (b, true) in\nwwhile (helper,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (f b, true) in\nwwhile (helper,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "let fixpoint (f,b) = wwhile (let x -> (if x = (f x) then (x, false) else (f x, true)),b)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "let fixpoint (f,b) = wwhile (let x = (if x = (f x) then (x, false) else (f x, true)),b)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = l;;\n", "in": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "", "in": "let rec exprToString e = match e with\n| Varx -> \"x\"\n| Vary -> \"y\"\n| Sine e -> \"sin (pi*\" + exprToString e", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Varx  -> \"x\"\n  | Vary  -> \"y\"\n  | Sine e -> \"sin (pi*\" + (exprToString e);;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" + exprToString e", "type": "scope", "out": "Error: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" + (exprToString e);;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average e1 e2 -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "type": "scope", "out": "Error: Unbound value <.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         unit\n"}, {"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "in": "):(eval(e4,x,y))", "type": "type", "out": "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "type": "scope", "out": "Error: Unbound value <.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         unit\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)\nwhen eval (e1,x,y) < eval (e2,x,y) ->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)\nwhen eval (e1,x,y) < eval (e2,x,y) ->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = match rand (depth>0?rand 0 1:rand 2 6) with\n| 0 -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, depth') in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "scope", "out": "Error: Unbound value depth'\nHint: Did you mean depth?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand 0 4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match (rand 0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand 0 4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match (rand 0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0 4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet _ = build (rand, 2);;\n", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "scope", "out": "Error: Unbound value rand\nHint: Did you mean land?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then let e = build(rand,depth-1) in\nmatch rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then let e = build(rand,depth-1) in\nmatch rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (fun x -> if x = (f x) then (x, false) else (f x, true),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = (f x) then (x, false) else (((f x), true), b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun x->if x = (f x) then (x, false) else (f x, true)),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 28) in\nwwhile (f, 3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (\n(fun x -> \nif x = (f x) then \n(x, false) \nelse \n(f x, true))\n, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,5) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4|5 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,5) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rand = makeRand(10,39) in \nlet _ = build(rand,12)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,7) with\n| 0|1 -> buildSine(build(rand,depth-1))\n| 2|3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,7) with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2|3 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,9) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4|5 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 6|7 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildX()\n| 1|2 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildY()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildY()\n| 1|2 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildX()\n| 1|2 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,15) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (1,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (1,2) with\n| 1 -> buildX()\n| 2 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (1,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,3) with\n| 0|1 -> buildX()\n| 2|3 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (1,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4|5 -> buildSine(build(rand,depth-1))\n| 6|7|8 -> buildCosine(build(rand,depth-1))\n| 9|10 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,3) with\n| 0|1 -> buildX()\n| 2|3 -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = recu 5;;\n", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 3|4 -> buildSine(build(rand,depth-1))\n| 5|6 -> buildCosine(build(rand,depth-1))\n| 7|8|9 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "scope", "out": "Error: Unbound value recu\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet c3 () = (8, 98, 42);;\n\nlet _ = doRandomColor (c3 ());;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Divide   of expr * expr\n| MultDiv  of expr * expr * expr", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}, {"min": "", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Divide (e1,e2)        -> exprToString e1 ^ \"/\" ^ exprToString e2\n| MultDiv (e1,e2,e3)    -> \"(\" ^ exprToString e1 \n^ \"*\" ^ exprToString e2 \n^ \")/\" ^ exprToString e3", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet c3 () = (8, 98, 42);;\n\nlet _ = doRandomColor (c3 ());;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)\nwhen eval (e1,x,y) < eval (e2,x,y) ->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Divide (e1,e2)        -> eval (e1,x,y) /. eval (e2,x,y)\n| MultDiv(e1,e2,e3)     -> (eval (e1,x,y) *. eval (e2,x,y))/eval (e3,x,y)", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) / (eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Divide (e1,e2)        -> eval (e1,x,y) /. eval (e2,x,y)\n| MultDiv(e1,e2,e3)     -> (eval (e1,x,y) *. eval (e2,x,y))/.eval (e3,x,y)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g3 () = (11, 21, 76);;\n\nlet _ = doRandomGrey (g3 ());;\n", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,dept-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,dept-1),\nbuild(rand,depth-1),\nbuild(rand,dept-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "scope", "out": "Error: Unbound value doRandomGrey\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet g2 () = (12, 40, 312);;\n\nlet _ = doRandomGrey (g2 ());;\n", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "scope", "out": "Error: Unbound value doRandomGrey\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet c3 () = (8, 98, 42);;\n\nlet _ = doRandomColor (c3 ());;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "scope", "out": "Error: Unbound value doRandomColor\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "buildMultDiv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Tan      of expr\n| NegPos   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Tan (e1)              -> \"tan(pi*\" ^ exprToString e1 ^ \")\"\n| NegPos (e1,e2,e3)     -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?-\" ^ exprToString e3 \n^ \":\" ^ exprToString v ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"\n| Tan (e1)              -> \"tan(pi*\" ^ exprToString e1 ^ \")\"\n| NegPos (e1,e2,e3)     -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?-\" ^ exprToString e3 \n^ \":\" ^ exprToString e3 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Tan e1                -> tan (pi*.eval (e1,x,y))\n| NegPos(e1,e2,e3) when eval (e1,x,y) < eval (e2,x,y)\n-> -.eval (e3,x,y)\n| NegPos(e1,e2,e3)      -> eval (e3,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square   of expr\n| NegPos   of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Square e1             -> eval (e1,x,y) ** 2.\n| NegPos(e1,e2,e3) when eval (e1,x,y) < eval (e2,x,y)\n-> -.eval (e3,x,y)\n| NegPos(e1,e2,e3)      -> eval (e3,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildSquare(e1)                = Square(e1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e2,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) when eval (e1,x,y) < eval (e2,x,y) \n->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  ->  eval (e4,x,y)\n| Square e1             -> eval (e1,x,y) ** 2.\n| NegPos(e1,e2,e3) when eval (e1,x,y) < eval (e2,x,y)\n-> 0.-.eval (e3,x,y)\n| NegPos(e1,e2,e3)      -> eval (e3,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf(rv)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf rv;;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf(\"%d\" !rv)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf (\"%d\" (!rv));;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%d\" !rv", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf \"%d\" (!rv);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%f\" !rv", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         'a ref\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf \"%f\" (!rv);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n\nlet _ = eval_fn (Square VarX) (2.,1.)", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         'a ref\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t when s = k-> i\n| (s,i)::t -> assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> \nd\n| (s,i)::t -> \nif s = k then \ni \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then \nseen \nelse \nh::seen \nin let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
