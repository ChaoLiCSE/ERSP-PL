{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = rest in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (number,boolean) = f b in\nif boolean then wwhile(f,b+1)\nelse number", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) = \nlet (number,boolean) = f b in\nif boolean then wwhile(f,number)\nelse number", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile (f b,b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile (y b,b)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((y b), b);;\n", "in": "let fixpoint (f,b) = wwhile (failwiaht \"to be written\",b)", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((failwiaht \"to be written\"), b);;\n", "in": "let fixpoint (f,b) = wwhile (failwith \"to be written\",b)", "type": "scope", "out": "Error: Unbound value failwiaht\nHint: Did you mean failwith?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString  s", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString d ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString d) ^ \")\");;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString e ^ \")\"", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString e) ^ \")\");;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\"", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString s", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" exprToString e4 ^ \")/2)\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ ((\"+\" exprToString e4) ^ \")/2)\"));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval (e, x, y)))\n  | Cosine e -> cos (pi * (eval (e, x, y)));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/2", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      (float_of_int ((eval (e1, x, y)) + (eval (e2, x, y)))) / 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2", "type": "type", "out": "Error: This expression has type float but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e1,x,y)\nelse eval(e2,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"}, {"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (fun y b-> \nif f b = b then (b,true)\nelse y b,b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> fun b  -> if (f b) = b then (b, true) else ((y b), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), true), b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun b  -> ((f b), true)), b);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "type", "out": "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((f b, f b = b),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fun y = (f b, f b = b),b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> \nlet x = f b in\nif x = b then (x, true)\n,b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> let x = f b in if x = b then ((x, true), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b-> \nlet x = f b in\nif x = b then (x, true)\nelse y x \n,b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun b  -> let x = f b in if x = b then (x, true) else ((y x), b));;\n", "in": "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z,b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun x  -> let z = f x in if z = b then (x, true) else ((y z), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, x)\n,b", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun x  -> (((f x), ((f x) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun x  -> ((f x), ((f x) != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b)", "type": "type", "out": "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let y b =\nlet xx = f b in\n(xx, xx != b), b)", "type": "type", "out": "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y xx, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y x, b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y , b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = rand (1, 2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\nmakeRand(1,2)", "type": "scope", "out": "Error: Unbound value rand\nHint: Did you mean land?\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ()))) makeRand (1, 2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\n\n\nmakeRand(1,2)", "type": "type", "out": "Error: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ()))) makeRand (1, 2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "type", "out": "Error: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}, {"min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet x = rand (1, 7);;\n", "in": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x", "type": "scope", "out": "Error: Unbound value rand\nHint: Did you mean land?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let x = rand (1, 7) in\n  match x with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      if depth = 0\n      then build (rand, depth)\n      else buildSine (build (rand, (depth - 1)))\n  | 4 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAverge\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "type": "scope", "out": "Error: Unbound value buildAverge\nHint: Did you mean buildAverage?\nError: Unbound value buildAverge\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildAverge\nHint: Did you mean buildAverage?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr * expr\n| AddThree of expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"**\" ^ ((exprToString e2) ^ \")\")))\n  | AddThree (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ ((\"+\" exprToString e3) ^ \")\"))));;\n", "in": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\"\n| Power (e1,e2) -> \"(\" ^ exprToString e1 ^ \"**\" ^ exprToString e2 ^ \")\"\n| AddThree (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\"", "type": "type", "out": "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString s", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString s", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString s", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) **. (eval (e2, x, y));;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)", "type": "scope", "out": "Error: Unbound value **.\nHint: Did you mean *. or **?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildPower(e1,e2)              = Power(e1,e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet s = Averge (VarX, VarY);;\n", "in": "exprToString s", "type": "scope", "out": "Error: Unbound constructor Averge\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet s = Average (VarX, VarY);;\n", "in": "exprToString s", "type": "scope", "out": "Error: Unbound constructor Average\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = exprToString sampleExpr1;;\n", "in": "let buildX()                       = VarX", "type": "scope", "out": "Error: Unbound value exprToString\n"}, {"min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY", "type": "scope", "out": "Error: Unbound constructor VarX\n"}, {"min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)", "type": "scope", "out": "Error: Unbound constructor VarY\n"}, {"min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)", "type": "scope", "out": "Error: Unbound constructor Sine\n"}, {"min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Cosine\n"}, {"min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Average\n"}, {"min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "type": "scope", "out": "Error: Unbound constructor Times\n"}, {"min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "in": "let buildPower(e1,e2)              = Power(e1,e2)", "type": "scope", "out": "Error: Unbound constructor Thresh\n"}, {"min": "\nlet buildPower (e1,e2) = Power (e1, e2);;\n", "in": "let buildAddThree(e1,e2,e3)        = AddThree(e1,e2,e3)", "type": "scope", "out": "Error: Unbound constructor Power\n"}, {"min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> ((eval(e1,x,y) +. eval(e2,x,y)) /. 2.)\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 2., 5.);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "type": "scope", "out": "Error: Unbound value eval\n"}, {"min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "in": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "type": "scope", "out": "Error: Unbound value buildThresh\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec build (rand,depth) =\n  let x = rand (0, 7) in\n  match x with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 ->\n      if depth = 0\n      then build (rand, depth)\n      else buildSine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAddThree\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "type": "scope", "out": "Error: Unbound value buildX\nHint: Did you mean build?\n"}, {"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec build (rand, depth) = \nlet x = rand(0,5) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
