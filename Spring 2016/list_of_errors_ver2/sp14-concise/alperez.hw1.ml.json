{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | h1::h2::t -> h1 + (h2 sumList t);;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| h1::h2::t -> h1+h2 sumList t", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (1 sumList xs');;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x+1 sumList xs'", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "type": "type", "out": "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> 1 sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') ->  1 sumList xs'", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "type": "type", "out": "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "type": "type", "out": "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| x::xs' -> x sumList xs'", "type": "type", "out": "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "in": "let rec digitsOfInt n = match n with\n| _     -> n%10 digitsOfInt  n/10", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "in": "let rec digitsOfInt n = match n with\n| _     -> n mod 10 digitsOfInt  n/10", "type": "type", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n<0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt  (n/10) :: (n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt (n/10) :: (n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp", "type": "scope", "out": "Error: Unbound value sum\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n", "in": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse n%10 + digitalRoot n/10", "type": "scope", "out": "Error: Unbound value %\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp >= 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count 0) in \nif temp >= 10\nthen digitalRoot temp && count(counter)\nelse counter", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         bool\nError: Unbound value sum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen digitalRoot temp \nelse counter", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersitence temp \nelse counter", "type": "scope", "out": "Error: Unbound value additivePersitence\nHint: Did you mean additivePersistence?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count 0) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nif temp = 0\nthen 0\nelse\nlet counter = (count 0) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counters = (count counter) in \nlet counter = counters in\nif temp >= 10\nthen additivePersistence temp \nelse counter", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec additivePersistence n = additivePersistence (n, 0);;\n", "in": "let rec additivePersistence n = additivePersistence (n, 0)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum n = \nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum n = \nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n", "in": "let rec sum (n, i) = \nif n < 10\nthen sumList (digitsOfInt n) i\nelse sumList (digitsOfInt n) 1+1", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif temp >= (10,0)\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif List.hd temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "type", "out": "Error: This expression has type int * int\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum [n;i] = \nif n < 10\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "in": "let rec sum [n;i] = \nif n < 10 || []\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]", "type": "type", "out": "Error: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, is) = temp in \nif num >= 10\nthen additivePersistence_helper (num, is+1)\nelse is", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum n = sumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nif n > 10 \nthen i+1\nelse \nlet temp = sum n in\nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = sum n in\nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, is) = temp in \nif num >= 10\nthen additivePersistence_helper (num, is)\nelse is", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, count) = temp in \nif num >= 10\nthen additivePersistence_helper (num, count)\nelse count", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "in": "let rec digitalRoot n = \ntemp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "type": "scope", "out": "Error: Unbound value temp\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> hd :: listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> tl :: listReverse hd", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  \nif hd != [] \nthen (listReverse tl) :: hd\nelse hd", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _ -> last l :: last l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _ -> last l :: last l :: last l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> last tl :: hd", "type": "type", "out": "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x\nelse x", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x::x\nelse x::x", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse(hd::l) tl", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l) tl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> l\n| hd::tl -> listReverse (hd::l)", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd", "type": "type", "out": "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n\nlet palindrome w = if l = (listReverse (explode w)) then true else false;;\n", "in": "let palindrome w = \nif explode w = listReverse (explode w)\nthen true\nelse false", "type": "scope", "out": "Error: Unbound value l\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = [l; x];;\n\nlet _ = f b a;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlast l :: listReverse (removeLast l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlast l :: listReverse (removeLast l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = \nfailwith \"err\"", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec listReverse l =\n  match l with | [] -> 0 | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nx :: listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nx :: listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen y\nelse\nx :: listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse\nx :: listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nreverseList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nreverseList x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nlistReverse x", "type": "scope", "out": "Error: Unbound value reverseList\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let s = listReverse a", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nlistReverse x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10))\nlistReverse x", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlistReverse reversed n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlistReverse (reversed n)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nlet y = reversed n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nreversed n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = rlistReverse reversed n;;\n", "in": "let rec digitsOfInt n = \nlistReverse reversed n", "type": "scope", "out": "Error: Unbound value rlistReverse\nHint: Did you mean listReverse?\nError: Unbound value rlistReverse\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value rlistReverse\nHint: Did you mean listReverse?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt_helper n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt_helper  (n/10)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nif (l=[])\nthen x::y\nelse \nlet x = last l in\nlet y = removeLast l in\nx::listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nif (l=[])\nthen l\nelse \nlet x = last l in\nlet y = removeLast l in\nx::listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = \nif (l=[])\nthen []\nelse \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "type": "", "out": ""}], "event": "eval"}
