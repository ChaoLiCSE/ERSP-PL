{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse bssoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "(assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse bssoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates [1;6;2;4;12;2;13;6;9]", "type": "type", "out": "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "(assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" \n\nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nmatch List.mem h seen with\ntrue -> seen\n| false -> h :: seen\nin\n\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nmatch List.mem h seen with\ntrue -> seen\n| false -> h :: seen\nin\n\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let b' = match x' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b') in\n  f b;;\n", "in": "let rec wwhile (f,b) =\nlet b' =\nmatch x' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "type": "scope", "out": "Error: Unbound value x'\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let b' = match b' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b') in\n  f b;;\n", "in": "let rec wwhile (f,b) =\nlet b' =\nmatch b' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "wwhile (f,2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "fixpoint (g, 0)", "type": "type", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f),\n      b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b)", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB , b' = fOfB) in whilesFun f), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (collatz, 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      ((whilesFun f), b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b' in (b', (fOfB = b')) in whilesFun f),\n      b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value b'\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (collatz, 1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = x + 1;;\n\nlet _ = let f = g in b = (let g' = g b in (b, (b = g')));;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b = let fOfB = f' b in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b in (fOfB, (fOfB = b)) in whilesFun f),\n      b);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB = b') in whilesFun (f)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "fixpoint (g,0)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)", "type": "scope", "out": "Error: Unbound value fixpoint\n"}, {"min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g = f in (g b, b = gb)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g = f in ((g b), b = gb)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g = f in ((g b), b = g b)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g = f in (g b, b = g b)), b)", "type": "scope", "out": "Error: Unbound value wwhile\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "type": "scope", "out": "Error: Unbound value wwhile\n"}, {"min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet VarX  = 2;;\n", "in": "expr", "type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         expr\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = failwith \"to be written\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> x;;\n", "in": "let rec exprToString e = match e with\n| VarX -> x", "type": "type", "out": "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> x;;\n", "in": "let rec exprToString e = match e with\n| VarX -> e", "type": "scope", "out": "Error: Unbound value x\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> e", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n\nlet _ = exprToString 2;;\n", "in": "exprToString VarX", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> Sine ^ (exprToString e1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Sine ^ (exprToString e1);;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(\" ^ (exprToString e1) ^ \")\"", "type": "type", "out": "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString Sine VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString Sine VarX;;\n", "in": "exprToString (Sine VarX)", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (VarX, VarY)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (VarX, VarY);;\n", "in": "exprToString (Sine (Sine VarX))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (Sine VarX)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(pi*\" ^ (exprToString e1) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (Sine (Sine VarX))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (Sine (Cosine VarX))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \"/2))\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (Sine (Cosine VarX))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2))\")));;\n\nlet _ = exprToString Average (VarX, VarY);;\n", "in": "exprToString (Average(VarX,VarY))", "type": "type", "out": "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (Sine (Cosine VarX))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Time (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Time (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)", "type": "type", "out": "Error: This variant pattern is expected to have type expr\n       The constructor Time does not belong to type expr\nHint: Did you mean Times?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString (Sine (Cosine VarX))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString sampleExpr1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString sampleExpr1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let buildX()                       = VarX", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (VarX, 1, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (VarX * VarY, 1, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n", "in": "eval", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval ((VarX * VarY), 1, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n", "in": "eval (Times(VarX,VarY), 1, 2)", "type": "type", "out": "Error: This expression has type expr but an expression was expected of type\n         int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (Times (VarX,VarY), 1, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (Sine (VarX,VarY), 1, 2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 1, 2);;\n", "in": "eval (Sine (VarX,VarY), 0.2, 0.3)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "in": "eval ((Sine (VarX,VarY)), 0.2, 0.3)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "in": "eval ((Sine (VarX, VarY)), 0.2, 0.3)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "in": "eval ((Sine (VarX)), 0.2, 0.3)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval ((Sine (VarY)), 0.2, 0.3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval ((Sine (VarX)), 1.0, 0.3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         float\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine e1                    -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1                  -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2)           -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2)             -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4)    -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine e1                    -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1                  -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2)           -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2)             -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4)    -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "exprToString sampleExpr1", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif ((eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval ((Sine (VarX)), 1.0, 0.3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (Sine(Average(VarX,VarY)),0.3,0.3)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "eval (sampleExpr,0.5,0.2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "type": "", "out": ""}], "event": "eval"}
