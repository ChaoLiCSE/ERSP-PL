{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = (+) (x a) in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (+) (x a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = (+) (a x) in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (+) (a x) in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int -> int\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (+) (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base =  0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x a = a in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x r s = a in let base r s = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun r s -> a) in\nlet base =  (fun r s -> 0) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0.0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> []) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y = x a in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y+y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x _ = x a in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = [] in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x _ = x a in let base = 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = 0 in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x _ = a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun _ -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun x -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x x = a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun x -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> y + x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun a -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun r -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (let myfun = x a in myfun) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (let myfun = x a in fun _ -> myfun) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun r -> r) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x a a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> (x y)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y = y a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun y -> (y a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x y = a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun y -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x _ x = x a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun _ x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (0) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x a in let base _ = base in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> base) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value base\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y ) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (a 0)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (fun _ -> a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (a ())) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (a [])) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x (a a) in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (x (a a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs =\n  let f a x = x (a x) in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (x (a x)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type (('a -> 'b) -> 'a) -> ('a -> 'b) -> 'b\n       but an expression was expected of type\n         (('a -> 'b) -> 'a) -> ('a -> 'b) -> ('a -> 'b) -> 'a\n       The type variable 'b occurs inside ('a -> 'b) -> 'a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs y = \nlet f a x = (x (a)) in\nlet base = y in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base _ = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> y) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value y\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (f a) in\nList.fold_left f base fs", "type": "scope", "out": "Error: Unbound value a\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (f) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (f (fun y -> y)) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (x a 0) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun y -> x y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> x z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> x a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> x z a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet pipe fs = let f a x z = z a in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (fun z -> z a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "type", "out": "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let pipe fs = \nlet f a x = (fun z -> x (a z)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in let l = (^) sep in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = (^) sep in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string -> string\n       but an expression was expected of type (string -> string) list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in let l x = x ^ sep in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = fun x -> x ^ sep in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type string -> string\n       but an expression was expected of type (string -> string) list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in\n      let l = [(fun x  -> x ^ sep)] in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l", "type": "type", "out": "Error: This expression has type (string -> string) list\n       but an expression was expected of type string list\n       Type string -> string is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet f a x = a ^ \"; \" ^ x in\nlet base = x in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = f x in List.fold_left f base xs;;\n", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left f base xs", "type": "type", "out": "Error: This expression has type 'a -> string\n       but an expression was expected of type 'a -> 'b -> 'a\n       Type string is not compatible with type 'b -> 'a \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left g base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\nList.fold_left g base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) ^ \"]\" in\nList.fold_left g base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\nList.fold_left g base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\n(List.fold_left g base xs) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\n(List.fold_left g base xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\n(List.fold_left g base xs) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "stringOfList", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "stringOfList string_of_int", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "stringOfList string_of_int [1;2;3;4]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\n(List.fold_left g base xs)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\n(List.fold_left g base xs) ^ \"s\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = \"[\" ^ (f x) in\n(List.fold_left g base xs) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nif n <= 0 then\n[]\nelse x :: clone x (n-1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n = if n <= 0 then acc else clone (x :: acc) (n - 1) in\n  clone_RT [] n;;\n", "in": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then acc\nelse clone (x::acc) (n-1)\nin\nclone_RT [] n", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n = if n <= 0 then acc else clone (x :: acc) (n - 1) in\n  clone_RT [] n;;\n", "in": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone (x::acc) (n-1)\nin\nclone_RT [] n", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2)\n  else List.append ((List.append ((clone 0 diff), len2)), len1);;\n", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)\nelse\nList.append (List.append (clone 0 (diff), len2), len1)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2);;\n", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append ((clone 0 (- diff)), len1)), len2)\n  else ((List.append ((clone 0 diff), len2)), len1);;\n", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff), len1), len2)\nelse\n(List.append (clone 0 (diff), len2), len1)", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) len1), len2)\n  else ((List.append (clone 0 diff) len2), len1);;\n", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) len1, len2)\nelse\n(List.append (clone 0 diff) len2, len1)", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(l1, List.append (clone 0 diff) l2)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = \nmatch l with \n| [] -> []\n| x::xs -> \nif x = 0 then\nremoveZero xs\nelse\nl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = 0 in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = 0 in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'a\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (1, 2) in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (1,2) in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int * int\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, 2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, 2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * int\n       but an expression was expected of type 'b list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, 0) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, 0) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 (List.length l1))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int * int list\n       but an expression was expected of type 'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, clone 0 (List.length l1)) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | ([],y) -> ([], y) | (h::t,y) -> (t, ((h + x) :: y)) in\n    let base = ((List.reverse l1), []) in\n    let args = List.reverse l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value List.reverse\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | ([],y) -> ([], y) | (h::t,y) -> (t, ((h + x) :: y)) in\n    let base = ((List.rev l1), []) in\n    let args = List.reverse l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value List.reverse\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x mod 10)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x mod 10)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, ((h + x) mod 10)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = h + x in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev l1), carry), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, carry), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "scope", "out": "Error: Unbound value carry\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], carry), y) -> \nif carry = 0 then\n(([], 0), y) \nelse \n(([], 0), 1::y)\n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], carry), y) -> \nif carry = 0 then\n(([], 0), 1::y) \nelse \n(([], 0), 1::y)\n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((0 :: ((List.rev l1), 0)), []) in\n    let args = 0 :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1, 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((0::(List.rev l1), 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((((List.rev 0) :: l1), 0), []) in\n    let args = (List.rev 0) :: l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev 0::l1, 0), []) in\nlet args = List.rev 0::l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev (0::l1), 0), []) in\nlet args = List.rev (0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nif i = 1 then l\nelse mulByDigit (i-1) (bigAdd l l)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet auxMul i acc =\nif i = 1 then acc\nelse mulByDigit (i-1) (bigAdd acc l)\nin\nauxMul i []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit (i-1) (bigAdd acc l)\nin\nmulByDigit i []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev (0 :: l1)), 0), []) in\n    let args = List.rev (0 :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let mulByDigit_RT i acc =\n    if i = 1 then acc else mulByDigit_RT (i - 1) (bigAdd acc l) in\n  mulByDigit_RT i [];;\n", "in": "let rec mulByDigit i l = \nlet mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "type": "scope", "out": "Error: Unbound value mulByDigit_RT\nHint: Did you mean mulByDigit?\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 0 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = ([], []) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| ([], _) -> ([], []) \n| (h::t, acc) -> (t, h::acc) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| ([], _) -> ([], []) \n| (h::t, acc) -> (t, (mulByDigit h l2)::acc) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| ([], acc) -> ([], acc) \n| (h::t, acc) -> (t, (mulByDigit h l2)::acc) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| ([], acc) -> ([], acc) \n| (h::t, acc) -> (t, bigAdd (mulByDigit h l2) acc) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet bigMul l1 l2 =\n  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith \"wtf\" in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> ([], acc) \n| _ -> failwith \"wtf\" in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "type", "out": "Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list * 'c\n       Type int is not compatible with type 'b list \n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> \nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc)\n| _ -> failwith \"wtf\" in\nlet base = (1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  let g a x = a ^ (\"; \" ^ (f x)) in \"[\" ^ ((List.map g l) \"]\");;\n", "in": "let stringOfList f l = \nlet g a x = a ^ \"; \" ^ (f x) in\n\"[\" ^ (List.map g l) \"]\"", "type": "type", "out": "Error: This expression has type ('a -> string) list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = let g x = (f x) ^ \"; \" in \"[\" ^ ((List.map g l) \"]\");;\n", "in": "let stringOfList f l = \nlet g x = (f x) ^ \"; \" in\n\"[\" ^ (List.map g l) \"]\"", "type": "type", "out": "Error: This expression has type string list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map (fun x  -> x ^ \"; \") l) \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map (fun x -> x ^ \"; \") l) \"]\"", "type": "type", "out": "Error: This expression has type string list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map \";\" sepConcat) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map \";\" sepConcat) ^ \"]\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\") ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map sepConcat \";\") ^ \"]\"", "type": "type", "out": "Error: This expression has type string but an expression was expected of type\n         string list\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map sepConcat l) ^ \"]\"", "type": "type", "out": "Error: This expression has type (string list -> string) list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map (sepConcat \"; \") l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map (sepConcat \"; \") l) ^ \"]\"", "type": "type", "out": "Error: This expression has type string list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList (List.map f l)) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ stringOfList (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \n\"[\" ^ (stringOfList f (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"; \" [[1; 0]; [2]; [3]];;\n", "in": "sepConcat \"; \" [[1;0];[2];[3]]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"; \" [[1; 0]; [2]; [3]];;\n", "in": "sepConcat \"; \" [[1;0];[2];[3]]", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = List.map (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n", "in": "List.map (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "type": "type", "out": "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = List.map (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n", "in": "List.map (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "type": "type", "out": "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = List.map (stringOfList string_of_int);;\n", "in": "List.map (stringOfList string_of_int)", "type": "type", "out": "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int;;\n", "in": "(stringOfList string_of_int)", "type": "type", "out": "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int;;\n", "in": "stringOfList string_of_int", "type": "type", "out": "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = List.map f l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \"[\" ^ (List.map f l) ^ \"]\"", "type": "type", "out": "Error: This expression has type 'a list\n       but an expression was expected of type string\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = (List.map f l);", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = sepConcat \"; \" (List.map f l);", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet rec clone_TR acc n =\nif n <= 0 then \nacc\nelse \nclone_TR (x::acc) (n-1)\nin\nclone_TR [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec clone x n =\nlet rec clone_TR acc n =\nif n <= 0 then \nacc\nelse \nclone_TR (x::acc) (n-1)\nin\nclone_TR [] n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec removeZero l = \nmatch l with \n| [] -> []\n| x::xs -> \nif x = 0 then\nremoveZero xs\nelse\nl", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "type": "scope", "out": "Error: Unbound value mulByDigit\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet _ =\n  bigMul [1; 9; 4; 5; 2; 3; 7; 4; 8; 1; 2; 9; 5; 8; 1; 0; 0; 5; 4; 6] [];;\n", "in": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "type": "scope", "out": "Error: Unbound value bigMul\n"}], "event": "eval"}
