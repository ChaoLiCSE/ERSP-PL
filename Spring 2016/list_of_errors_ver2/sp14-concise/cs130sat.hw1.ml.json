{"ocaml": [{"min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList List.tl xs)", "type": "type", "out": "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ n mod 10", "type": "type", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse  (digitsOfInt (n/10) )@ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse (digitsOfInt (n/10) )@ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n/10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet additivePersistence n =\n  if n > 9\n  then additivePersistence (List.fold_left (+) (digitsOfInt n))\n  else n;;\n", "in": "let additivePersistence n =\nif n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\nelse n", "type": "scope", "out": "Error: Unbound value additivePersistence\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "in": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "type": "scope", "out": "Error: Unbound value additiveHelper\n"}, {"min": "\nlet additivePersistence n = additiveHelper n 0;;\n", "in": "let additivePersistence n = additiveHelper n 0", "type": "scope", "out": "Error: Unbound value additiveHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "in": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "type": "scope", "out": "Error: Unbound value additiveHelper\n"}, {"min": "\nlet additivePersistence n = additiveHelper n 0;;\n", "in": "let additivePersistence n = additiveHelper n 0", "type": "scope", "out": "Error: Unbound value additiveHelper\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitalHelper n = \nif n > 9 then digitalHelper (sumList(digitsOfInt n))\nelse n", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with | [] -> [] | x::xs -> listReverse xs @ [x]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec listReverse l = match l with | [] -> [] | x::xs -> listReverse xs @ [x]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w = if explode w = listReverse (explode w) then true else false", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let palindrome w =  explode w = listReverse (explode w)", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1) else acc", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1) else acc", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::xs -> x + sumList xs", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10))[n mod 10])", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10)) [n mod 10])", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append( (digitsOfInt (n / 10)) [n mod 10])", "type": "type", "out": "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]", "type": "", "out": ""}], "event": "eval"}
{"ocaml": [{"min": "", "in": "let digits n = digitsOfInt (abs n)", "type": "", "out": ""}], "event": "eval"}
